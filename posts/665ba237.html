<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>《区块链安全》_翁健 | 水木时</title><meta name="author" content="水木时"><meta name="copyright" content="水木时"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="网络空间安全专业核心教材体系建设一一建议使用时间  第1章 绪论 区块链本质  一份分布式的公共记账本 共享、可信的公共记账本  区块链技术是什么  从狭义角度来讲，区块链技术是一种基于时间顺序的分布式账本，它将数据区块通过首尾相连的方式组合而成一种链式数据结构，以密码学为基础来保障数据的不可篡改、不可伪造等特性。 从广义角度来讲，区块链技术是基于密码学、时间戳等技术来传输和验证数据，通过链式数">
<meta property="og:type" content="article">
<meta property="og:title" content="《区块链安全》_翁健">
<meta property="og:url" content="https://timefy.github.io/posts/665ba237.html">
<meta property="og:site_name" content="水木时">
<meta property="og:description" content="网络空间安全专业核心教材体系建设一一建议使用时间  第1章 绪论 区块链本质  一份分布式的公共记账本 共享、可信的公共记账本  区块链技术是什么  从狭义角度来讲，区块链技术是一种基于时间顺序的分布式账本，它将数据区块通过首尾相连的方式组合而成一种链式数据结构，以密码学为基础来保障数据的不可篡改、不可伪造等特性。 从广义角度来讲，区块链技术是基于密码学、时间戳等技术来传输和验证数据，通过链式数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://timefy.github.io/img/img/6.jpg">
<meta property="article:published_time" content="2023-12-05T09:16:13.000Z">
<meta property="article:modified_time" content="2023-12-26T09:42:20.273Z">
<meta property="article:author" content="水木时">
<meta property="article:tag" content="学习记录">
<meta property="article:tag" content="区块链">
<meta property="article:tag" content="网络安全">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://timefy.github.io/img/img/6.jpg"><link rel="shortcut icon" href="/img/inc.jpg"><link rel="canonical" href="https://timefy.github.io/posts/665ba237.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《区块链安全》_翁健',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-26 17:42:20'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/img.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/web%E5%AE%89%E5%85%A8"><i class="fa-fw fas fa-shield-alt"></i><span> web安全</span></a></div><div class="menus_item"><a class="site-page" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE"><i class="fa-fw fas fa-cubes"></i><span> 区块链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/%E9%98%85%E8%AF%BB"><i class="fa-fw fas fa-book"></i><span> 阅读</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent"><nav id="nav"><span id="blog-info"><a href="/" title="水木时"><span class="site-name">水木时</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/web%E5%AE%89%E5%85%A8"><i class="fa-fw fas fa-shield-alt"></i><span> web安全</span></a></div><div class="menus_item"><a class="site-page" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE"><i class="fa-fw fas fa-cubes"></i><span> 区块链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/%E9%98%85%E8%AF%BB"><i class="fa-fw fas fa-book"></i><span> 阅读</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《区块链安全》_翁健</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-05T09:16:13.000Z" title="发表于 2023-12-05 17:16:13">2023-12-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-26T09:42:20.273Z" title="更新于 2023-12-26 17:42:20">2023-12-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">87k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>261分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《区块链安全》_翁健"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><!-- # 《区块链安全》-翁健主编 -->
<p><strong>网络空间安全专业核心教材体系建设一一建议使用时间</strong><br>
<img src="/img/blockchain_sec/0_1.jpg" alt="教材体系建设"></p>
<h2 id="第1章-绪论">第1章 绪论</h2>
<h3 id="区块链本质">区块链本质</h3>
<ul>
<li>一份分布式的公共记账本</li>
<li>共享、可信的公共记账本</li>
</ul>
<h3 id="区块链技术是什么">区块链技术是什么</h3>
<ul>
<li>从<strong>狭义</strong>角度来讲，区块链技术是一种基于时间顺序的分布式账本，它将数据区块通过首尾相连的方式组合而成一种链式数据结构，以密码学为基础来保障数据的不可篡改、不可伪造等特性。</li>
<li>从<strong>广义</strong>角度来讲，区块链技术是基于密码学、时间戳等技术来传输和验证数据，通过链式数据结构来存储数据利用共识机制来生成和更新数据，并通过设计可编程智能合约来实现的一种全新去中心基础架构与分布式计算范式。</li>
</ul>
<h3 id="区块链技术发展阶段">区块链技术发展阶段</h3>
<p><img src="/img/blockchain_sec/1_1.jpg" alt="区块链技术发展阶段"></p>
<h3 id="区块链基础特性">区块链基础特性</h3>
<p>基于区块链的链式数据结构、分布式网络以及底层的密码学原理，使区块链具有去中心化性（Decentralization ）、公开透明性（Transparency）、集体维护性（Collective Maintenance） 、一致性（Consistency ）、不可篡改性（Tamper-Resistance）和匿名性（Anonymity）的安全特点。</p>
<ol>
<li>
<p><strong>去中心化性（Decentralization）：</strong>  去中心化性是区块链技术的最基本特征。区块链是一个点对点(Peer-to-Peer)的分布式网络架构,又称对等式网络,是无中心服务器、依靠对等用户之间进行信息交互的互联网体系。区块链不依赖于中心化节点的管理,实现了数据的分布式记录和存储。在传统的中心化网络中,对单个节点(或备份节点)实行攻击即可破坏整个系统,但是在区块链系统中,只要大多数节点能正常运行,少数节点被攻击或者失效都不会影响整个系统的运作。</p>
<p>如图 1.4 所示为区块链所采用的分布式点对点网络模型,节点之间采取相互连接、协同工作的方式，每个节点既作为服务端提供服务,也作为客户端使用服务。在网络层面上来看,每个节点之间的角色都是平等的，不存在特殊的中心节点,全网节点都具有均等的权利和义务。</p>
</li>
<li>
<p><strong>公开透明性（Transparency）：</strong> 早期设计区块链系统是开放式的，也就意味着其上的数据对任何人都是公开透明的,任何用户都可以通过公开接口查看链上的数据信息。同样地,数据的更新操作对全网用户也是透明的，因此用户可以自行地验证数据的真实性,这是区块链系统被信任的基础。</p>
</li>
<li>
<p><strong>集体维护性（Collective Maintenance）：</strong> 区块链系统中参与共识并存储所有最长链数据的节点称为全节点，区块链数据的安全性实际上是由这些全节点来维护的,其他具备计算和存储资源的节点也都可以参与进来,这样通过全节点来共同维护区块链账本的可靠性。</p>
</li>
<li>
<p><strong>一致性（Consistency）：</strong> 区块链中新产生的区块会被节点广播到网络中,实现全网数据同步。在等待一定周期之后,所有全节点都会存储包含该区块在内的最长链信息,即全网诚实节点具有关于记录数据的一致性视图。</p>
</li>
<li>
<p><strong>不可篡改性（Tamper-Resistance）：</strong> 区块链中的每个区块交易记录是在上一个区块生成之后,在该区块被生成之前所产生的记录,按照时间顺序逐步地写人账本中,这也保证了数据写入的有序性。同时，区块链中每个区块头中都记录着前一区块的哈希值,一旦某一区块的内容被更改,那么其后所有区块的记录都需要跟着变更,这将耗费巨大算力。因此,区块链数据库中不包含对被记录数据在已产生区块的更新、删除操作,只能创建新的交易并将其加入新的区块,即系统一且经过验证并添加至区块链后,其中的数据信息就会得到永久的存、法更改。另一方面,区块链系统中的全节点都保存了一份区块链的完整账本,因此分布式账本使得少粉用户持有了被更改过信息的假账本也不会对区块链整个系统的安全性有任何影响。在大部分节点保持诚实可信的前提下,整个系统以数量最多的账本作为最终的账本。该特点保证了基于区块链数据的有效性,即无法被篡改。</p>
</li>
<li>
<p><strong>匿名性（Anonymity）：</strong> 区块链系统中用户使用的是与真实身份信息无关的一串数字作为转账地址，虽然任何用户都可以从链中查到与该地址相关的交易信息,但是很难追溯到该地址所对应的实际操作人,这也就保证了区块链的匿名性。<strong>在比特币网络中,由于交易可以被链接,因此其匿名被称为伪匿名(Pseudo-anonymity)</strong>。在其后发展的区块链技术中，如 Zcash、门罗币,利用<strong>零知识证明</strong>的技术可以实现完全匿名的数字货币。</p>
<p>需要注意的是,虽然节点与节点之间无须公开身份,但区块链基于一套共识协议和签名、哈希算法实现了节点间的互信问题。这使得区块链节点间无须公开身份,利用一个与身份无关的交易地址在保证一定匿名情况下完成数据交换或交易操作。</p>
<p>区块链技术凭借公开透明、不可篡改及可追溯等特性,解决了数据共享开放与交易过程<br>
中存在的安全问题,为实现去中心化场景下的数据流通和价值交换提供了一套解决方案。</p>
</li>
</ol>
<h3 id="区块链引发的深刻变革">区块链引发的深刻变革</h3>
<ol>
<li>
<p><strong>金融领域</strong></p>
<ul>
<li><strong>去中心化的支付系统：</strong> 区块链技术通过去中心化的特性，使得跨境支付和本地支付更加便捷和高效。交易的确认不再需要传统金融机构的中介，降低了交易成本和时间。</li>
<li><strong>智能合约和金融衍生品：</strong> 区块链上的智能合约使得金融交易更加透明、安全，减少了欺诈和错误。智能合约还可以用于创建金融衍生品，如期权和合成资产。</li>
<li><strong>数字货币和加密资产：</strong> 区块链驱动了数字货币的发展，例如比特币和以太坊。这些数字货币可以作为替代传统货币的一种形式，提供更快速、低成本的跨境交易。</li>
</ul>
</li>
<li>
<p><strong>数据管理</strong></p>
<ul>
<li><strong>去中心化的数据存储：</strong> 区块链允许数据的去中心化存储，消除了单一点的故障，并提高了数据的可靠性和安全性。</li>
<li><strong>数据透明性和可追溯性：</strong> 区块链的不可篡改性确保了数据的真实性，每一次数据变动都被记录在区块中，使得数据的历史可追溯，增加了数据的透明性。</li>
</ul>
</li>
<li>
<p><strong>物联网应用</strong></p>
<ul>
<li><strong>设备身份和安全：</strong> 区块链可以为物联网设备提供唯一的身份标识，并通过智能合约确保设备之间的安全通信，防止未经授权的访问。</li>
<li><strong>数据共享和互操作性：</strong> 区块链技术可以提供一个安全的、去中心化的平台，促进不同物联网设备之间的数据共享和互操作性。</li>
</ul>
</li>
<li>
<p><strong>产品防伪</strong></p>
<ul>
<li><strong>溯源和真实性验证：</strong> 区块链可以用于建立产品的溯源系统，追踪产品的生产、运输和销售过程。通过在区块链上存储相关信息，可以实现产品真实性的验证，防止假冒伪劣产品的流通。</li>
</ul>
</li>
<li>
<p><strong>知识产权</strong></p>
<ul>
<li><strong>版权保护：</strong> 区块链可以记录数字内容的产权信息，确保创作者的权益得到保护。这有助于防止盗版和未经授权的复制。</li>
<li><strong>智能合约和版权交易：</strong> 利用智能合约，艺术家和创作者可以更直接地参与到版权交易中，确保他们收到应有的报酬。</li>
</ul>
</li>
<li>
<p><strong>智能合约</strong></p>
<ul>
<li><strong>自动化合同执行：</strong> 智能合约是一种基于区块链的自动化合同，能够自动执行合同中规定的条件。这降低了合同执行的成本，减少了争议的可能性。</li>
<li><strong>供应链管理：</strong> 智能合约在供应链中的应用可以自动化和优化整个流程，提高透明度、降低欺诈风险，并实现供应链各方之间的信任。</li>
</ul>
</li>
</ol>
<h3 id="智能合约">智能合约</h3>
<ol>
<li><strong>定义：</strong> 一套以数字形式定义的承诺，包括合约参与者可以在上面执行这些承诺的协议。</li>
<li><strong>特征</strong></li>
</ol>
<ul>
<li><strong>承诺（Commitment）：</strong> 承诺在这里指的是合约参与者协商后同意的各自的权利和义务，承诺的各项内容共同定义了某个特定的合约的本质与目的。</li>
<li><strong>数字形式（Digitally）：</strong> 数字形式是指合约必须以机器语言而非自然语来进行具体的实现，由计算机程序自动执行，且一般合约以代码形式执行后就不可更改。</li>
<li><strong>计算机协议（Computer Protocol）：</strong> 协议是技术实现，在选择的协议基础之上，合约承诺被最终实现，并且其执行的全过程被记录下来。</li>
</ul>
<h3 id="公有链、私有链、联盟链对比">公有链、私有链、联盟链对比</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>公有链</th>
<th>私有链</th>
<th>联盟链</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>参与者</strong></td>
<td>公众可加入，去中心化</td>
<td>受限制的参与者，通常由单一组织或实体控制</td>
<td>多个组织或实体共同控制</td>
</tr>
<tr>
<td><strong>权限控制</strong></td>
<td>完全去中心化，任何人都可以参与和验证交易</td>
<td>高度集中化，由单一组织或实体掌控</td>
<td>中度去中心化，由多个组织或实体共同控制</td>
</tr>
<tr>
<td><strong>共识机制</strong></td>
<td>公开的共识机制（例如工作量证明、权益证明）</td>
<td>通常由中心化的共识机制（例如拜占庭容错）控制</td>
<td>多方共同控制的共识机制（例如拜占庭容错或权益证明）</td>
</tr>
<tr>
<td><strong>隐私性</strong></td>
<td>相对较低，所有交易对公众可见</td>
<td>高，仅授权的参与者能够查看和验证交易</td>
<td>中，由参与方确定信息的共享程度</td>
</tr>
<tr>
<td><strong>效率</strong></td>
<td>相对较低，因为需要通过共识达成一致</td>
<td>相对高，因为参与者较少，交易速度更快</td>
<td>取决于联盟链的具体设计，通常在公有链和私有链之间</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>高，由去中心化的共识机制保障</td>
<td>由集中化的参与者和权限控制提供较高的安全性</td>
<td>中，取决于共识机制和参与者的信任度</td>
</tr>
<tr>
<td><strong>特性记账权</strong></td>
<td>所有参与者均具有相同的记账权</td>
<td>由中心化的参与者拥有记账权</td>
<td>由多个共同控制的参与者共享记账权</td>
</tr>
<tr>
<td><strong>激励机制</strong></td>
<td>通常通过代币激励，如比特币和以太坊</td>
<td>可以由中心化机构提供激励，也可以采用其他机制</td>
<td>取决于具体设计，可能结合公有链和私有链的激励机制</td>
</tr>
<tr>
<td><strong>中心化程度</strong></td>
<td>完全去中心化</td>
<td>高度中心化</td>
<td>中度去中心化</td>
</tr>
<tr>
<td><strong>突出特点</strong></td>
<td>匿名性、公开性</td>
<td>高度隐私、集中化控制</td>
<td>多方参与、中度隐私、共同控制</td>
</tr>
<tr>
<td><strong>承载能力</strong></td>
<td>通常较低，因为要处理大量的公开交易</td>
<td>相对较高，因为面向特定组织或实体</td>
<td>取决于联盟链的设计和规模，通常介于公有链和私有链之间</td>
</tr>
</tbody>
</table>
<h3 id="区块链技术演进">区块链技术演进</h3>
<p><strong>1.侧链技术（Sidechain）</strong><br>
2012 年,侧链的概念首次出现在比特币聊天室中,它是为了解决如何改进比特币协议、增加新的功能模式。2014 年以来,已经出现了很多具有新功能的区块链,许多与比特币竞争的数字货币,如莱特币、狗狗币等竞相迅猛发展。比特币的开发团队为了减少这些竞争币给比特币带来的影响,开始计划升级比特币的功能。他们考虑到直接在比特币链上进行功能添加有一定的风险,因为一旦新功能在实践中发生软件故障,已运行的比特币网络将会面临不可预测的潜在安全问题。此外,由于比特币本身的特性,如果要对其进行较大规模的改动,需要获得多数比特币矿工的支持。但是,在全球范围内获得多数比特币矿工的同意显然十分困难,出于对这些现实因素的考虑,比特币核心开发者便提出了侧链技术。</p>
<p>一方面,侧链技术最重要的作用就是支持用户去访问和使用新的服务。基于侧链技术,比特币可以作为一种存储货币,在侧链上开发和设计新的功能,以此来提升比特币的竞争力。例如,用户可以通过比特币从本区块链网络转移到另外的区块链网络进行使用，利用其他区块链网络的隐私特性、智能合约以及高效的交易处理功能来弥补比特币网络的不足。另一方面,新功能的添加通过侧链技术完成以后,即使由于安全升级导致侧链异常,主链也不会受到任何的影响,仍然可以正常运行,这也是侧链技术所带来的突出优势。</p>
<p>从本质上来看,侧链技术是一种跨区块链网络的解决方案,能够实现将数字资产从第一个区块链网络转移到第二个区块链网络,之后又可以在某个时间节点将该数字资产从第二个区块链网络安全地转回第一个区块链网络,如图 1.6 所示。通常来说，第一个区块继被称为主区块链或者主链,第二个区块链就被称为侧链。这种数字资产在不同区块18为了实现侧链技术,几位比特币的核心开发者,Adam Back、Matt Corallo 等人共同链之间进行安全转移的技术为区块链应用提供了新的发展空间。发起创立了Blockstream公司,明确了侧链技术的协议实现及方案细节。最初开发设计的侧链技术,一般主链专指比特币区块链网络，随着技术的更新发展,主链同样也可以是任何正式上线运行的区块链网络。</p>
<p><img src="/img/blockchain_sec/1_2.jpg" alt="主链和侧链"></p>
<p>严格来说,侧链并非区块链的一种类型,它只是在区块链的现实应用过程中,开发者对区块链的一种功能扩展,因此也不能特指某一个区块链,而是所有遵守侧链技术的区块链网络的通称。侧链可以被理解成一个独立的区块链网络,侧链上的数据及运行程序也是与主链相互独立的。因此,它在运行过程中并不会增加主链的负担,在解决数据过度膨胀的问题上,不失为一种有效的手段。</p>
<p>侧链的实现主要基于双向锚定(Two-Way Peg,2WP)方式。基于 2WP 技术,数字资产在主链中将被锁定起来,同时等价的数字资产将会在侧链中得到释放。相应地，当需要对侧链中的数字资产进行锁定的时候,主链中等价的数字资产也会被释放出来。2WP 实现过程中的主要挑战在于如何兼容主链,保证侧链协议的运行不会对主链的正常运行流程产生影响。</p>
<table>
<thead>
<tr>
<th>作用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>扩展性</strong></td>
<td>通过使用侧链，在不影响主链的情况下扩展区块链网络的处理能力。</td>
</tr>
<tr>
<td><strong>定制化应用</strong></td>
<td>允许创建适用于特定用途的自定义区块链，满足特定企业或组织的需求。</td>
</tr>
<tr>
<td><strong>隐私保护</strong></td>
<td>提供更高级别的隐私保护，通过侧链实现特定的隐私功能，避免直接影响主链。</td>
</tr>
<tr>
<td><strong>交互操作性</strong></td>
<td>有助于不同区块链网络之间的互操作性，通过创建支持跨链通信的侧链。</td>
</tr>
<tr>
<td><strong>新型协议和功能实验</strong></td>
<td>用于测试和实验新的区块链协议和功能，而不会影响主链的稳定性。</td>
</tr>
<tr>
<td><strong>资产跨链转移</strong></td>
<td>允许在不同的链上传输和交换资产，解决数字资产互通性的问题。</td>
</tr>
</tbody>
</table>
<p>侧链技术则是将交易处理转移到一个与主链并行的区块链上。侧链与主链之间可以通过桥接技术进行连接，以实现资产的转移。侧链可以根据需要设计不同的参数，以满足不同的扩容需求。</p>
<p><strong>2.闪电网络（Lightning Network）</strong><br>
比特币作为最大的数字货币体系,每秒处理交易的数量为 7笔,每笔交易最终确认需要等待至少6 个块的时间，这样的处理效率显然无法满足现实应用的需求,与金融系统的交易速率更无法相比。为了解决比特币中存在的交易处理慢问题，闪电网络应运而生，它实际上也属于侧链技术的一种,通过在不同交易方之间建立一条链下可扩展的微支付通道,多方之间在链下完成频繁的双向交易操作,无须链上交易全网确认,显然会提升比特币交易处理的效率。</p>
<p>闪电网络模型如图 1.7 所示,假设 Alice 和 Bob 两人之间需要频繁地进行交易，显然这将会产生高昂的交易费用,并且,其交易效率也难以满足一般的商业场景的要求。基于以上困难,两人通过闪电网络开启一条微支付通道。在开启支付通道中,Alice 和 Bob 各自将 10 个比特币转给一个由双方共同控制的地址账户,该地址账户的共同管理可以通过多重签名技术来实现。开启支付通道的过程是一笔普通的交易上传到比特币网络当中日交易最终确认,则双方可以在链下的支付通道里进行频繁的交易操作。直至双方确认不会再发生交易，想通过类似提现的方式来获取最后的金额,则可共同约定关闭该通道。</p>
<p><img src="/img/blockchain_sec/1_3.jpg" alt="闪电网络模型"></p>
<p>在闪电网络中,主要通过 RSMC(Recoverable Sequence Maturity Contract)和HTLC(Hashed TimeLock Contract)两种方法来解决链下交易中面临的一些安全问题，RSMC 称为可撤销的顺序成熟度合同,支持了双向的支付通道,开始时两方都向共同地址中发送一笔资金进行锁定。通过设定惩罚机制,假定某一方中途退出,则需要等待一段确认时间。而另一方确认对方有非法操作,可无须等待立即拿走所有的资金,以此来保证交易的双方不出现抵赖或者反悔行为。在微支付通道中的每一步交易操作都由密码学技术来保证执行的有效性。</p>
<p>RSMC实现了两方之间的双向支付通道(Alice 和 Bob),但存在的一个问题是,如果任意的两人之间进行交易都需要相互协商来建立一条支付通道，显然不是很高效的。为了支持不同用户在无须建立支付通道的前提下实现链下的安全交易,就产生了 HTLCHTLC称为哈希时间锁合约,它是为了支持在不同节点之间在微支付通道交易而产生的。假设 Alice 和 Bob 之间存在一条支付通道,Bob 和 Carl之间也存在这样一条支付通道。当Alice和 Carl之间需要进行交易时,可以无须再建立一条新的通道,基于 HTLC就可以实现 Alice 和Carl之间的交易操作:Alice 通过 HTLC 锁定一定金额的资金 y,同时选取一个秘密参数值,通过设定一定的时间期限 T,如果 Bob 能够在 T 时间内向Alice 出示 H(z),Bob 就能获得这笔资金;如果在约定 T时间内无法提供 H(x),则这笔金额将被自动解锁并返还给 Alice。同理,Bob和 Carl之间的交易操作也可以按照此过执行,这样Alice和Carl 两方之间完成链下的 HTLC交易操作,如图 1.8 所示。</p>
<p><img src="/img/blockchain_sec/1_4.jpg" alt="闪电网络模型"></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>RSMC（Recoverable Sequence Maturity Contract）</th>
<th>HTLC（Hashed Time-Locked Contract）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>用途</strong></td>
<td>主要用于支付通道内部的资金管理和通道的关闭。</td>
<td>用于实现闪电网络中的跨支付通道的支付。</td>
</tr>
<tr>
<td><strong>合约类型</strong></td>
<td>二者间有共同点，是比特币脚本合约的一种。</td>
<td>具体实现了HTLC概念，是跨通道支付的基础。</td>
</tr>
<tr>
<td><strong>交易延迟</strong></td>
<td>RSMC具有相对较短的交易延迟，支持快速的资金锁定和解锁。</td>
<td>HTLC引入了时间锁，支付可能需要一些时间来完成。</td>
</tr>
<tr>
<td><strong>资金锁定和解锁</strong></td>
<td>RSMC允许通道内的资金被快速、灵活地锁定和解锁。</td>
<td>HTLC在支付开始前会锁定资金，支付完成后解锁资金。</td>
</tr>
<tr>
<td><strong>可撤销性</strong></td>
<td>RSMC支持支付通道的双方都能主动撤销未广播的交易，提供较强的可撤销性。</td>
<td>HTLC本质上支持原子交换，具有更强的可撤销性。</td>
</tr>
<tr>
<td><strong>冗余交易</strong></td>
<td>RSMC的撤销交易较为冗余，因为每次更新通道状态都需要新的撤销交易。</td>
<td>HTLC引入的Revocable Sequence Maturity Contract（Revocable RSMC）减少了冗余。</td>
</tr>
<tr>
<td><strong>支付追踪和解密</strong></td>
<td>RSMC的支付更易于追踪，因为没有对支付金额进行加密。</td>
<td>HTLC的支付通过哈希锁定，对支付金额进行了加密。</td>
</tr>
<tr>
<td><strong>隐私性</strong></td>
<td>相对较低，因为支付金额是公开的，可能泄露用户的交易信息。</td>
<td>相对较高，支付金额是加密的，提高了用户的交易隐私。</td>
</tr>
<tr>
<td><strong>典型应用场景</strong></td>
<td>通道内部的资金管理，通道的开启和关闭。</td>
<td>实现闪电网络中的跨支付通道的支付。</td>
</tr>
</tbody>
</table>
<p><strong>3.zk-SNARK（Zero-Knowledge Succinct Non-Interactive Argument of Knowledge）</strong></p>
<p>区块链技术实现了一套无须依赖可信机构的去中心化应用,所有的交易信息都需通过广播、验证和确认的方式最终被写人区块链,且生成的交易信息无法抵赖，也无法定。然而,这些交易详情是在众目腰瞬之下完成验证和确认的，这也意味着，交易的发肃者、接收者、接收时间、金额数量等信息都是公开的。然而,在很多的应用场景里，这些有易信息属于敏感信息,用户不愿对外公布,包括对区块链平台的维护者。那么，如何在即保证数据是真实、准确的情况下,又能同时保证对数据进行可验证呢? 基于零知识证明技术就可以被用来解决此问题。</p>
<p>20 世纪 80 年代初,S.Goldwasser,S, Micali 及 c.Rackoff 等人提出了零知识证明的概念,他们设想在一些特殊场景之下,证明者需要让验证者相信某个论断是正确的，但是出于隐私性的考虑,却又无法将证明的对象直接呈现给验证者,而零知识证明旨在使得证明者在不向验证者提供任何隐私信息的情况下,达到证明者的目的。在零知识证明协议过程中,可能涉及两方或更多方完成一项任务所需采取的一系列步骤。证明过程中证明者在不向验证者泄露任何关于被证明消息的信息的情况下,向验证者证明并使其相信自己知道或拥有被证明消息。交互式零知识证明是指在证明过程中,证明者和验证者之间必须经过交互才能完成的零知识证明,与此相反,在定理证明过程中证明者和验证者不需要交互的零知识证明被称为非交互零知识证明。零知识证明是密码学为我们提供的强大利器之一。如果将零知识证明用于安全验证,许多场景下的数据安全问题可以得到有效解决。</p>
<p>零知识证明是一种密码学技术，它可以让一个人向另一个人证明自己知道某个秘密，而不需要透露这个秘密本身。零知识证明具备以下三个特性：</p>
<ul>
<li><strong>完备性</strong>：如果证明方和验证方都是诚实的,并且它们都遵循证明过程的每一步来进行正确的计算,那么这个证明一定会是成功的,验证方一定会接受证明方。</li>
<li><strong>可靠性</strong>：任何其他人都无法假冒证明方身份使得一个伪造的证明成功被验证方接受。</li>
<li><strong>零知识性</strong>：证明过程执行完之后,验证方只获得了“证明方拥有这个知识”的信息,而没有获得关于这个知识本身的任何信息。</li>
</ul>
<p>在零知识证明过程中,存在两方角色: 证明者(Prover)、验证者(Verifier)。下面以一个例子来说明零知识证明技术。图 1.9 所示的是一个山洞示意图,在山洞深处有一扇门。</p>
<p><img src="/img/blockchain_sec/1_5.jpg" alt="零知识证明示例"></p>
<p>只有知道咒语的人才能将其打开。证明者想向验证者证明,他知道打开这扇门的咒语,但 具不想当着验证者的面将门打开,否则咒语就会被验证者知道。那证明者如何实现这个过程呢? 证明者进人山洞里面,验证者随机地喊出从右边进人,证明者随即从右边进人从左边出来。无论验证者选择让证明者从左还是从右，只要证明者能从相对应的门走出来,则说明证明者确实知道打开门的咒语。而在这个过程中,证明者没有向验证者透露任何关于咒语的信息,在确保咒语隐私的情况下,向验证者证明了“我知道咒语这个事实。</p>
<p>另一个例子,有一个盲人手中拿了两个颜色不一样的圆球,一个正常人如何向这个盲人证明这两个圆球的颜色不一样? 并且这个正常人不能够向盲人透露球的颜色,也不能够找第三个人来参与。证明者(即正常人)要向验证者(即盲人)证明他知道球的颜色不一样,但盲人不能够知道其他任何信息包括球的颜色,以及不能够加入第三个人来帮助证明者证明球的颜色。那应该如何完成呢? 首先盲人每只手拿一个球,给正常人看过之后让他闭上眼睛,盲人可以选择交换两只手中的球或者不交换,然后让正常人睁开眼睛并说出盲人手中的圆球是否交换。经过多轮测试之后,如果盲人手中的球颜色不一样,那么正常人每轮都可以回答正确,这样就完成了零知识证明的过程。</p>
<p>这两个是零知识证明中的典型例子。在区块链中将零知识证明引人,可以实现在不需要泄露交易敏感信息的前提下实现对交易的有效性验证,这就是 k-SNARK。zk.SNARK 的全称是 Zero-Knowledge Succinct Non-interactive Argument of Knowledge.即零知识-简洁的非交互式知识证明。系统要求证明者在不透露自己敏感信息的前提下,向验证者(Verifier)证明其确实知道某个信息，而且是真实的。zk-SNARK 是一种简洁且非交互式的零知识证明,首先 k-SNARK 的构造必须简洁,简洁的零知识证明只需要毫秒就可以完成验证,证据(Proof)长度只有几百字节。在传统的交互式零知识证明构造中,证明者和验证者需要来回发送几轮消息才能完成验证,而非交互式零知识证明只需要证明者向验证者发送一次证据即可让验证者相信证明人的论断(Statement)是可信的。</p>
<p><strong>4.有向无环图（Directed Acyclic Graph，DAG）</strong><br>
为了解决区块链交易确认速率慢、资源消耗大的问题,有向无环图(Directed AcyclicGraph,DAG)技术被提出来。DAG 本质上是一种数据结构,同样属于分布式账本技术。与原有由区块组成的单链区块链不同,DAG 是由交易所组成的网络。DAG 中的交易在角色上类似于区块链的区块,这些交易被当作网络节点,共同组成了复杂的网络拓扑结构,如图1.10 所示。</p>
<p>DAG 是异步共识的,基于图的方式以交易本身作为基础单元进行数据存储,有效提升了区块链在存储和效率方面的性能,包括 DagCoin,IOTA,ByteBall 等在内的系统采用的是基于 DAG结构的区块链技术</p>
<p><img src="/img/blockchain_sec/1_6.jpg" alt="区块链结构与有向无环图"></p>
<h2 id="第2章-区块链构造">第2章 区块链构造</h2>
<h3 id="比特币网络概览">比特币网络概览</h3>
<p><img src="/img/blockchain_sec/2_1.jpg" alt="比特币网络概览"></p>
<h3 id="区块的具体结构">区块的具体结构</h3>
<p><img src="/img/blockchain_sec/2_2.jpg" alt="区块的具体结构"></p>
<h3 id="区块难度-目标值">区块难度/目标值</h3>
<ol>
<li><strong>区块计算公式</strong></li>
</ol>
<p>比特币的新目标值是由难度值决定的，难度值是一个指数形式的十六进制数。难度值的计算公式如下：</p>
<p>$$<br>
\text{target} = \text{coefficient} \times 2^{8 \times (\text{exponent} - 3)}<br>
$$</p>
<p>其中，<code>coefficient</code> 是一个十六进制数，<code>exponent</code> 是一个整数。</p>
<p>比特币的新目标值会根据系统的平均出块时间来动态调整，以保证每10分钟出一个区块。调整的规则如下：</p>
<ul>
<li>每2016个区块产生后会调整一次（大约2周14天）</li>
<li>调整的计算公式是：</li>
</ul>
<p>$$<br>
\text{新难度值} = \text{旧难度值} \times \frac{\text{最近2016个区块的真正时间}}{\text{最近2016个区块的预期时间}}<br>
$$</p>
<ul>
<li>最近2016个区块的预期时间，当然是：$2016 * 10min$。即：</li>
</ul>
<p>$$<br>
\text{预期时间} = 2016 \times 10 \text{分钟}<br>
$$</p>
<ol start="2">
<li><strong>哈希目标值</strong><br>
<img src="/img/blockchain_sec/2_3.jpg" alt="哈希目标值"></li>
</ol>
<h3 id="交易">交易</h3>
<ol>
<li>交易过程</li>
</ol>
<blockquote>
<p>一个地址的$UTXO（Unspent Transaction Output）$数值不能被分割花费，除非通过交易由该$UTXO$生成多个新地址的$UTXO$。</p>
</blockquote>
<p><img src="/img/blockchain_sec/2_4.jpg" alt="哈希目标值"></p>
<p>在比特币中,矿工只把验证有效的交易放入新的区块,同时,其他矿工在验证区块有效性时,也会验证交易的有效性,若该交易不是有效的,则该区块不会被接受。参与节点在验证交易过程中,除了需要验证交易数据结构的正确性外,还需要验证交易输入的所有权(见2.4节),以及检查输人的$UTXO$是否已经被花费过。之所以检查$UTXO$是否被花费是为了防止双重支付攻击。在现实世界中,1 元钱一旦花出去,不可能被重复花费然而数字形式的货币花费出去之后,很有可能再次被用来与其他人进行交易。区块链技术可以抵御双重支付攻击,这是由于区块链的每个全节点存有一个 $UTXO$ 数据库，可以通过该数据库来检查交易输人是否为未被花费的 $UTXO$。此外,区块链还提供了简单支付验证机制$(Simple Payment Verification,SPV)$,其他参与节点(如轻量级节点)也可以借助该机制对交易进行快速验证。具体方法是计算交易的哈希值和默克尔树根节点值并在必要时向全区块链参与节点请求构造默克尔树的中间节点的哈希值,即可验证该笔交易是否存在于历史区块中。</p>
<p>比特币地址的生成是通过对公钥进行双重哈希,它可以被公开用来接收 UTXO。公钥相对应的私钥则由用户秘密保存,它是有权花费对应地址 $UTXO$ 的证明。目前，比特币地址的格式被分为两种:发送到公钥地址的格式$(Pay-to-Pubic-Key-Hash,P2PKH)$和发送到脚本地址的格式$(Pay-to-Script-Hash,P2SH)$。下面主要介绍 $P2PKH$ 的生成方式,后一种格式与其类似。</p>
<p>比特币地址采取了基于 $Base58 $编码的方式来生成地址,主要是为了消除一些易混淆的字符。实现过程相比于其他的 $Base64$ 编码,在字符的选择上有一些细微的差别,它不包含字符$0、O、I$和$l$,以及$+$和$/$。如图 2.8 所示,首先,使用 $RIPEMD-160$ 哈希算法和$SHA-256$ 哈希算法计算版本号加上公钥的双重哈希结果。版本号指明了格式的类别，使用$0x00$ 表示前一种格式,$0x05$ 表示后一种格式,$P2PKH$的版本号为$3$。然后,将 $20$字节的双重哈希结果加上版本号通过两次 $SHA-256$ 哈希计算得到 $36$ 字节的校验码，用来检验地址的正确性。最后,只取校验码的前$ 4 $字节加上 $1$字节的版本号和 $20$ 字节的双重哈希结果通过$ Base58$ 编码得到 $26-35$ 个字符不等的地址。可以看出，经过如图 2.8 所示的计算步骤之后,生成的地址相比于公钥长度要短。</p>
<p><img src="/img/blockchain_sec/2_5.jpg" alt="比特币网络地址产生过程"></p>
<h3 id="区块链网络拓扑">区块链网络拓扑</h3>
<p>与比特币网络类似,大多数公有链采用了基于点对点$(Peer-to-Peer,P2P)$非结构化的网络拓扑结构来构建区块链网络。在该拓扑结构中,网络的各个参与节点被认为是资源对等的,共同提供网络服务。这种网络结构能够使一个区块链系统快速、随机化地组织网络,支持网络参与节点的频繁接入和断开,具有较高的容错性。对于联盟链和私有链它们的区块链网络的规模通常比公有链网络小,所以倾向采用全连接的网络拓扑结构总体而言,根据通信目的的不同,区块链节点之间的通信可以分为以下两种方式。</p>
<p>(1)为了维持节点与区块链网络之间连接的通信。通信内容包括索取其他节点的地址信息和广播自己的地址信息。当有新的节点加人区块链网络时,该新节点首先会读取种子节点的地址信息，然后向这些种子节点请求其相邻节点的地址信息,当新节点连接上这些相邻节点后,它继续向这些相邻节点请求更多的相邻节点地址信息并与其建立连接，直到节点的相邻节点数量达到稳定。节点加人区块链网络以后,各个节点会定期以 ping的方式确认其相邻节点是否可达,如果存在不可达节点,就使用新节点替代这些不可达节点。另外,节点也会定期向其相邻节点广播自己的地址信息,以确保新节点的信息被更多节点接收。</p>
<p>(2)为了完成区块链上层业务的通信。通常来说,通信的内容包括转发交易信息和同步区块信息(在这里,交易和区块是区块链中的数据结构,将在交易层介绍)。在转发交易信息方面,节点采用的是中继转发模式。具体来说,发送节点先向其相邻节点转发此交易,待相邻节点收到交易后,它们再转发给自己的相邻节点,并以这样的方式进行下去,直到将交易传输到整个区块链网络。在同步区块信息方面,节点采用的是请求-响应模式具体来说，一个节点可以向其相邻节点发送自己本地所保存的区块链高度,若该高度小于其相邻节点所保存的区块链高度,该节点就请求自己欠缺的区块;若大于其相邻节点所保存的区块链高度,则其相邻节点反向请求区块信息。在这种模式下,每个节点不断地和各自的相邻节点交换本地保存的区块信息,从而使整个网络中所有参与节点都同步存储一致的区块链信息。</p>
<h3 id="区块链网络协议">区块链网络协议</h3>
<p>一般来说,随机组织网络的网络协议主要有两种:<strong>基于 DNS 服务器协议和基于Kademlia 协议</strong>。本节就以一个新节点准备加人比特币网络时随机发现网络节点的例子来介绍这两种网络协议。对于基于 DNS 服务器协议的区块链网络来说,一个节点新加入时会首先去询问区块链系统中已经编好码的 DNS 服务器,得到一组随机化的已经存在于区块链网络的节点的 IP 地址,然后节点会将这些地址填充到它的对等节点连接列表中对于基于 Kademlia 协议的区块链网络来说,由于网络中的每个节点都维护了$160$个存有网络信息的哈希列表,一个新加人的节点可以获取任意网络节点中存储的节点信息,它通过向网络节点发送查询命令来填充自己的列表。由于随机化连接节点的方式可能存在某些对等节点的连接路径不是最优路径的问题，一些研究者提出了以连接最近节点来组成区块链网络架构的方法。</p>
<p>在比特币中,大多数的参与节点基于DNS服务器协议加人网络。通常情况下，参与区块链网络架构的方法。节点通过监听 $8333$端口来接收外来连接,每个节点最多同时可以向其他节点发起$8$条连接,且同时接收不超过$125$ 条的连接。比特币网络为了检测参与节点的加人和离开状态它要求参与节点每隔$24$小时发送 $addr $消息向全网广播自己的$IP$ 地址，得到$addr$消息的节点可以向相邻节点转发该消息。参与节点除了通过 $addr$ 消息发现其他节点之外,也可以发送 $getaddr$ 消息请求以获得其他节点的$IP $地址,从而获得网络中大多数节点的$IP$地址。</p>
<h3 id="区块链数据传播">区块链数据传播</h3>
<p>如图2.10所示,在数据传播方面,参与节点通过发送$inv$ 消息向所有邻居节点发送区地址。块或者交易的哈希数据,邻居节点首先判断接收到的哈希数据是否为新的数据,如果是新的数据，则向节点发送$getdata$ 消息获取哈希数据所对应的区块或者交易的实际数据,然后验证数据的有效性,并以同样的方式向它们的所有邻居节点传播数据。由接收者主动发送$getdata $请求数据的方式避免了不必要的网络流量。另一方面，比特币网络会每隔$100$毫秒随机地中转部分$inv$消息以实现将交易传播给网络的大多数节点。对于主动发送$inv$ 消息的参与者来说,如果它们的交易没有被处理,可以多次重发交易数据。</p>
<p><img src="/img/blockchain_sec/2_6.png" alt="比特币交易传播"></p>
<p>在P2P的网络架构下,对等节点之间是通过洪泛的方法发送消息的，这使得区块链网络很容易随着网络节点的增多而加大负载.甚至有些网络连接因网络资源有限而断开进而造成网络分片现象。例如,针对比特币区块链提出的网络 BlockNDN 无法防止网络分片现象发生。同时,采用基于 P2P 的网络结构也是导致区块链系统延展性受限的影响因素之一，目前一些试图提高比特币区块链延展性的工作没有考虑这种因素,因此这些方案的有效性还有待分析。例如,试图增加区块大小容纳更多的交易数据来提高区块链的交易吞吐量,但是由于网络带宽的限制,这反而增加了块传播时间。此外,还有试图增加节点连接度来使区块尽快传播到更多的网络节点,然而这进一步加大了网络负载,容易导致网络分片。为了应对 P2P应用层网络的局限性,研究者陆续提出了优化后的区块链网络协议,如BCXP。</p>
<h3 id="区块链节点">区块链节点</h3>
<p>一般来说,根据一个区块链系统的身份管理机制的不同,节点加人网络的限制也不同。对于公开链,节点可以任意地加人或者离开区块链网络,而对于联盟链或者私有链系统对节点的加人有严格的身份验证机制。区块链中长期参与的节点彼此之间并没有功能和角色上的区分,每个节点的作用是对等的,一个节点既可以作为客户端同时也可以作为服务器。如图2.11所示,区块链中的节点通常是路由、共识、钱包区块链数据库多个功能的集合。路由功能是指节点在全网络中提供路由转发功能。钱包包括以下两种:冷钱包(Cold Wallet)和热钱包(Hot Wallet)。冷钱包指的是脱离了网络连接的离线钱包利用离线存储的方式对数字货币进行管理。相反地,热钱包需要连接网络来进行交易，因此也是极易遭受攻击的一种钱包类型。</p>
<p><img src="/img/blockchain_sec/2_7.jpg" alt="区块链节点功能"></p>
<p>在某个特定时间段内,依据区块链节点执行操作的不同,节点可以被分为3种:全节点、轻量级节点和共识节点。具体来说,全节点存储了整个区块链数据的完整备份,因此可以独立地验证任意一笔交易数据的有效性。轻量级节点只备份了区块头数据,因此在验证某笔具体交易时,需要向全节点请求相应的区块数据协助验证。对于共识节点,它可以是全节点也可以是轻量级节点,主要参与运行区块链的共识协议,同时与其他节点通信并交换信息来保证区块链数据的一致性,它也被称为矿工。</p>
<p>本质上讲,整个区块链系统的安全性取决于所使用的共识协议。通常情况下,区块链系统所采用的共识协议决定了系统中所能容忍的恶意节点数量。为了保证系统的安全性,恶意节点在全节点中所占的比重不能超过一定的阙值。假定全节点数量为 n,对于比特币来说,恶意节点数不能超过 50%,即n/2。其他基于拜占庭共识协议的区块链容忍较低的恶意攻击者数量为 n/3,这部分内容将在第 4 章进行阐述。</p>
<h2 id="第3章-区块链密码学基础">第3章 区块链密码学基础</h2>
<h3 id="群的基本定义及性质">群的基本定义及性质</h3>
<h4 id="群的定义">群的定义</h4>
<p>在非空集合$G$上定义一个二元运算符“$·$”,并且该集合满足下面4个属性。</p>
<ol>
<li>封闭性:对于任意$a,b∈G$,有$a·b∈G$.</li>
<li>结合律:对于任意$a,b,c∈G$,有$a·b·c=(a·b)·c=a·(b·c)$。</li>
<li>存在单位元: $∃i∈G$,对于元素$a∈G$,都可以得到$a·i=i·a=a$。</li>
<li>存在逆元:对于任意$a∈G$,存在一个元素$a^{-1}∈G$,使得$a·a^{-1}=a^{-1}·a=i$。</li>
</ol>
<p>$a^{-1}$则为元素$a$在集合$G$上的逆元。</p>
<p>如果某个代数系统满足上述所有性质，则称其为群(Group),记为$(G，·)$。</p>
<p>交换律:对任意的$a,b∈G$,有$a·b=b·a$。</p>
<p>如果某个群除了满足以上封闭性、结合律、存在单位元、存在逆元4 个属性之外,还满足交换律,则称该群为交换群或者阿贝尔群。</p>
<h4 id="群的性质">群的性质</h4>
<ol>
<li>群中的单位元是唯一的。</li>
<li>群中任一元素的逆元是唯一的。</li>
<li>对于任意的$a,b,c∈G$,如果有$a·b=a·c$,则有$b=c$。</li>
<li>对于任意的$a,b∈G$,有$(a·b)^{-1}=b^{-1}·a^{-1}$。</li>
<li>对于任意的$a∈G$,元素$a$与自身的$n$次运算,其中$n∈N$,可以表示为<br>
$a^n=a·a·…·a$</li>
</ol>
<p>这里需要注意$n=0$的情况,定义$a^0=i$,其中元素$i$是$G$中的单位元。</p>
<p>如果分别使用普通乘法和普通加法的符号来定义$G$ 中的二元运算“$+$”和“$·$”,则对于乘法运算,$a^n$表示$a$ 的$n$ 次幂,加法运算 $na=a+a+…十a$,可以得到如表 3.1所示的性质。</p>
<p>如果群$G$中包含的所有元素个数是一个有限整数,则称$G$为有限群,否则称为无限群。有限群$G$ 中元素的个数,称为这个有限群的阶。若$G$ 是一个有限群,它的阶表示为 $|G|$ 。</p>
<p>特别地，如果一个集合在某种运算上是一个群,但其在其他运算上未必是一个群。</p>
<h4 id="有限域">有限域</h4>
<p>有限域指的是包含有限个元素的域。显然，$Z_q$（$q$为素数）就是一个有限域。可以得到关于有限域的性质为有限域的阶必为素数的幂。举例而言，假设 $F$ 是一个有限域，则存在素数 $p$ 和正整数 $n$，使得 $|F| = p^n$，将这个有限域记为 $F^n_p$ 或 $GF(p^n)$。反之，对于每一个这样的素数幂 $p^n$，都存在这样唯一的阶为 $p^n$ 的有限域。当 $n=1$ 时，把有限域 $GF(p)$ 称为素数域。密码学中普遍采用的域是阶为 $p$ 的素数域 $GF(p)$ 和特征为 $2$ 的 $GF(2^m)$ 域。</p>
<h3 id="整数群、椭圆曲线群和双线性映射群">整数群、椭圆曲线群和双线性映射群</h3>
<h4 id="整数群">整数群</h4>
<p>由整数集合$Z$构成的群,即为整数群。整数群有如下的一些性质。</p>
<ol>
<li>整数集合$Z$在加法运算上可以构成阿贝尔群,写作$(Z,+)$,它的全部元素都是$1$生成的,$0 $是这个群的单位元,每一个元素的逆元是自身的相反数。</li>
<li>整数集合$Z$在乘法运算上不能够构成群,因为除了元素 $1$和$-1$外，其他所有素的乘法逆元都不存在。</li>
</ol>
<p>特别地,$(Z_p,+)$称为模 $p$ 的整数群,它包含的元素是模$p$的$p$ 个剩余类$([0],[1],[2],…,[p-1])$。显然,$Z_p$是一个加法循环群,$Z_p=&lt;[1]&gt;$,其中$[1]$就是它的一个生成元。对于任何与$p$互素的整数$r,[r]$都是$Z$的生成元。</p>
<h4 id="椭圆曲线群">椭圆曲线群</h4>
<p>椭圆曲线密码(Elliptic Curves Cryptography,ECC)是基于圆曲线数学理论的算法,属于公钥加密算法,是迄今为止被实践证明安全有效的三类公钥密码体制之一,其以高效性能在实际系统中被广泛应用。椭圆曲线离散对数问题的困难性决定了 ECC 算法的安全性。椭圆曲线离散对数问题是一个比大整数因子分解问题(RSA 算法基础)以及离散对数问题(DSA 算法基础)更困难的问题。相比于 RSA 算法,ECC算法的优势在其能够用更少的位长度获得与 RSA 同等强度的安全性，因此 ECC 算法可以节约计算开销、密钥管理存储开销以及通信带宽,使得ECC算法可以适用于一些计算能力较弱或者对移动性要求较高的设备,例如<br>
手机、智能卡等小型或移动型设备。</p>
<p>所有满足椭圆曲线方程点的集合就构成了椭圆曲线群下面将介绍 3 种基于不同域的椭圆曲线。</p>
<ol>
<li>实数域上的椭圆曲线</li>
</ol>
<p>椭圆曲线并非字面上理解的椭圆,只是它的曲线方程与计算椭圆的周长方程类似(见图 3.2)。一般来说,椭圆曲线指的就是维尔斯特拉斯(Weierstrass)方程，即<br>
$y^2+axy+by=x^3+cx^2+dx+e$</p>
<p>椭圆曲线是由满足方程的全体解集$(x,y)$再加上一个无穷远点$O$  构成的集合,该方程中的参数 $a,b,c,d$ 是满足某些定条件的实数。上述曲线方程通过坐标转化为以下的简化式,即<br>
$y^2=x^3+ax+b$</p>
<p>由这个方程确定的椭圆曲线记为 $E(a,b)$或$E$。椭圆曲线是关于 x轴对称的。椭圆曲线的加法运算可以定义为:如果椭圆曲线上 $3 $个点位于同一直线,那么它们的和为$O$。椭圆曲线上的加法也具有加法运算的一般性质,如交换律、结合律等。</p>
<ol start="2">
<li>有限域$GF(p)$上的椭圆曲线<br>
有限城$GF(p)$上的椭圆曲线定义为满足式(3.3)同余式的所有几何解$(x，y)∈GF(p)$和一个无穷远点$O=(x,\infty)$构成的集合:<br>
$$y^2=x^3+ax+b(mod\ p)$$<br>
式中$p$是一个大于$2^{100}$的素数;$a,b∈GF(p)$是满足$4a^3+27b^2\neq0(mod\  p)$的常数。这类椭圆曲线通常用$E_p(a,b)$来表示,即</li>
</ol>
<p>$$E_p(a,b)={(x,y)∪Ο | y^2≡x^3+ax+b(mod\ p)}$$</p>
<p>该椭圆曲线上只有有限个点数 $N$(称为椭圆曲线的阶,包含有无穷远点)。$N$ 越大,安全性越高,即群中元素越多,越能抵抗穷举搜索攻击。</p>
<p>比特币系统的区块链实现采用的是椭圆曲线 $sep256k1$,$secp256k1$ 是基于有限域$GF(p)$上的椭圆曲线,其中$p=2^{256}-2^{32}-2^9-2^7-2^4-1$。</p>
<ol start="3">
<li>有限域$GF(2^m)$上的椭圆曲线<br>
有限域 $GF(2^m)$中的元素是$ m $位的字符串,这些字符串可以表示为系数在 $GF(2)$上<br>
的多项式:</li>
</ol>
<p>$$\lbrace a_{m-1}x^{m-1}+a_{m-2}x^{m-2}+···+a_1x+a_0:a_i∈\lbrace 0,1\rbrace\rbrace$$</p>
<p>$GF(2^m)$上的椭圆曲线是定义为满足同余式(3.6)的所有几何解$(x，y)∈GF(2^m)$和一个无穷远点 $O=(x,\infty)$构成的集合。</p>
<p>$$y^2+xy=x^3+ax^2+b$$</p>
<p>其中,$m&gt;160,a,b∈GF(2^m)$且$b\neq0$。这类椭圆曲线通常可以用 $E_2(a,b)$来表示,即$$E_2(a,b)=\lbrace(x,y)∪O | y^2+xy=x^3+ax^2+b\rbrace$$</p>
<h4 id="双线性映射群">双线性映射群</h4>
<p>双线性映射也称双线性配对,一个双线性映射是由两个向量空间中的元素,一起生成第三个向量空间中的一个元素的函数,并且该函数对每个参数都是线性的。总而言之,给出一个双线性群组的定义$(G_1,G_2,G_T,p,g_1,g_2;e)$,其中 $G_1,G_2和G_T$是阶为素数 p的乘法循环群,$g_1和g_2$分别是$G_1和G_2$的一个生成元。一个映射 $e:G_1×G_2→G_T$称为双线性映射,当它满足如下3个性质。</p>
<ol>
<li>双线性:对于$∀a,b∈Z_p,均有e(g_1^a,g_2^b)=e(g_1,g_2)^{ab}$</li>
<li>非退化性:$∃g_1∈G_1,g_2∈G_2,使得e(g_1,g_2)≠1$。</li>
<li>可计算性:对于$∀u∈G_1,v∈G_2$,存在有效的算法计算 $e(u,v)$。<br>
若$G_1=G_2$,则称这个双线性映射是对称的,否则是非对称的。</li>
</ol>
<h3 id="密码学困难问题">密码学困难问题</h3>
<h4 id="离散对数问题">离散对数问题</h4>
<p>基于离散对数的公钥加密算法作为常用的公钥加密算法之一,其加密算法的安全性要远远高于基于大整数分解的 RSA 加密算法，而且离散对数问题(Discrete LogarithmProblem,DLP)的计算复杂度要比大整数分解问题更高。经过多年研究，人们无法构造出一个概率多项式时间来解决离散对数问题的方案。</p>
<h5 id="离散对数问题定义">离散对数问题定义</h5>
<p>离散对数问题的定义为:当给定一个素数 $p$,以及有限域$Z_p$上的一个本原元$a$时，对$Z_p$上的任意正整数$b$,都可以找到唯一的整数$c,0&lt;c&lt;p-2$,使得$a^c≡b(mod\ p)$,通常用$log_a^b$来表示$c$。一般而言,如果仔细选择$p$,则可以认为该问题是难解的,目前还没有找到可以在多项式时间内计算离散对数问题的算法。为了抵抗已知的攻击，选择的素数$p$需要满足以下两个条件:一是为至少 $150 $位的十进制整数;二是$p-1$至少有一个大的素数因子。</p>
<h5 id="离散对数问题性质">离散对数问题性质</h5>
<p>离散对数问题的困难性与有限域上的生成元无关,任何可以计算$log_a^b$ 的离散对数算法同样可以用来计算任意其他底数的离散对数问题。</p>
<h4 id="大整数分解问题">大整数分解问题</h4>
<p>大整数分解问题(Integer Factorization Problem,IFP)指的是对于任意给定的两个大素数的乘积,找出该乘积的因子,这个问题是困难的。大整数分解问题是数论中的一个基本问题,普遍认为不存在高效的概率多项式时间算法能够分解一个大整数，因此它是一个非常重要的研究问题。</p>
<p>将大整数分解问题具体定义为:任意选定两个长度为$λ$的大素数$p$ 和$g$,并计算 $n=pq$。对于给定 $n$,若存在一个可忽略的函数$negl(λ)$,使得n能够被分解为 $p$ 乘以 $g $的概率不大于 $negl(λ)$,则可以称该大整数 $n$ 的分解问题是一个困难问题。</p>
<h4 id="CDH-DDH-问题">CDH/DDH 问题</h4>
<p>计算 Diffie-Hellman(Computational Diffie-Hellman,CDH)假设是 Whitfield Diffi和 Martin Hellmn 两位教授在构造密协议协商的时候提出来的。一般把任意群 $G$的三元素组$(g^x,g^y,g^{xy})$称为DH组。对于任意为素数q的循环群$G$,$g∈G$ 是一个生成元，二元函数$dh_g:G^2→G$的定义为:随机选择两个元素$X,Y∈G$,令$X=g^x,Y=g^y$,计算函数$dh_g(X,Y)=g^{xy}$。CDH同题的困难性指的是在已知$G,g,g^x,g^y$的情况下,计算二元函数$dh_g$是困难的,即存在一个可忽略的函数 $negl(λ)$,使得计算出二元函数 $dh_g$ 的概率不大于 $negl(λ)$。</p>
<p>判定 Difie-Hedlman(Decisional Difie Helman,DDH)假设是 CDH 假设的判定形式,也就是计算问题对应的判定问题,用来判断不可分辨性。DDH 假设具体定义如下:对于任意阶为素数$ g$ 的循环群$G$，$g∈G$ 是一个生成元,随机选取$3$个元素 $X,Y,Z∈G$，其中$X=g^x,Y=g^y,且有 dh_g=g^{xy}$。存在一个可忽略的函数$negl(λ)$,使得区分 $Z=dh_g$;或者$Z$是随机选取的概率不大于$negl(λ)$。</p>
<h3 id="BDH-DBDH-问题">BDH/DBDH 问题</h3>
<p>双线性 Diffie-Hellman( Bilinear Diffie-Hellman,BDH)问题是对给定的 $3$ 个元素$g^a,g^b,g^c$,计算$e(g,g)^{abc}$。具体定义如下。</p>
<p>计算 BDH 假设是对于任意阶为素数$ q$ 的循环群$G_1,G_2,G_3$,其中 $g∈G_1,h∈G_2$是两个生成元,存在一个可高效计算的同构 $\phi:G_1→G_2$,使得对于生成元$g,h$,有$\phi(g)=h$。随机选择$a,b,c∈Z_q$,有 $g^a,g^c,h^a,h^b$,BDH 问题的难解性在于计算 $e(g,h)^{abc}$是困难的,即存在一个可忽略的函数 $negl(λ)$,使得计算出 $e(g,h)^{abc}$的概率不大于 $negl(λ)$。</p>
<p>同样地,BDH 假设的判定形式是 DBDH(Decisional Bilinear Diffie-Hellman)假设。对于任意阶为素数 $q$ 的循环群$G_1,G_2,G_3$,其中 $g∈G_1,h∈G_2$是两个生成元,存在一个可高效计算的同构 $\phi:G_1→G_2$,使得对于生成元 g,h,有 $\phi(g)=h$。随机选择$a,b,c∈Z_q,W∈G_3$,已知 $g^a,g^c,h^a,h^b,e(g,h)^{abc}$,存在一个可忽略的函数 $negl(λ)$,使得区分$W=e(g,h)^{abc}$或者 $W $是随机选取的概率不大于$negl(λ)$。</p>
<h3 id="哈希函数">哈希函数</h3>
<h4 id="哈希函数定义">哈希函数定义</h4>
<p>密码学上的哈希函数(Hash Funtion),也称杂凑函数。其目的是将任意长度的消息$m$ 压缩或者映射为某一固定长度的消息摘要,表示为 $H(m)$,该映射是一个多对一的映射。$H(m)$也可以当作消息 $m$ 的指纹,一旦 $m$ 发生变化,$H(m)$也会随之改变。</p>
<p>根据是否需要密钥,哈希函数可分为以下两类。</p>
<ol>
<li>带密钥的哈希函数:有两个不同的输入,分别为消息和密钥。一个带密钥的哈希函数通常用来作为消息认证码,即消息验证码(Message Authentication Code,MAC)。</li>
<li>不带密钥的哈希函数:只有一个消息输人,这样产生的消息摘要必须被安全存放,不能被篡改。</li>
</ol>
<p>根据设计结构,哈希函数可以分为 3类。</p>
<ol>
<li>标准哈希函数。</li>
<li>基于分组加密的哈希函数。</li>
<li>基于模数运算的哈希函数等。</li>
</ol>
<p>目前,主要的标准哈希函数可以分为两类。</p>
<ol>
<li>$MD$系列的哈希函数,例如 $MD4、MD5、MDS、HAVAL、RIPEMD$等</li>
<li>$SHA$系列的哈希函数,例如 $SHA-1,SHA-256、SHA-384、SHA-512$等</li>
</ol>
<h4 id="哈希函数主要性质">哈希函数主要性质</h4>
<p>哈希函数H必须满足以下6 种性质。</p>
<ol>
<li>$H$的输人可以是任何大小的数据块,即 $H$ 的输人可以是任意长度的。</li>
<li>$H$的输出是固定大小的数据块。</li>
<li>对任意消息$x$,求 $H(x)$是可行的,并可用软件或硬件实现。</li>
<li>对任意给定的哈希值 $h$,找到 $y$ 且满足 $H(x)=h$,计算上是不可行的。</li>
<li>对任意给定的值,找到 $y$,满足 $H(x)=H(y)$并且$x\neq y$,计算上是不可行的。</li>
<li>找到任意的 $x,y$ 且$x\neq y$,使得 $H(x)=H(y)$,计算上是不可行的。<br>
基于以上性质,可以将哈希函数分为两大类:弱碰撞哈希函数和强碰撞哈希函数。弱碰撞哈希函数与强碰撞哈希函数必须同时满足前 3 个条件,主要区别在于后 3 方面。</li>
</ol>
<p><strong>弱碰撞哈希函数</strong><br>
满足上面性质(4)和(5)的哈希函数,称这个哈希函 $H(x)$是碰撞的。</p>
<p><strong>强碰撞哈希函数</strong></p>
<p>满足上面性质(4),(5)和(6)的哈希函数,称这个哈希函数 H(x)是强碰撞的在以上的性质中,性质(4)的意义是指哈希函数是单向性的,通常也称抗原像性,那么H(x)也是单向杂凑函数;性质(5)代表弱碰撞性,可以称为抗第二原像性;性质(6)代表强碰撞性，也可以称为抗碰撞性,用来防止攻击者对哈希函数实施自由起始碰撞攻击，即生日攻击。</p>
<h4 id="哈希函数安全性">哈希函数安全性</h4>
<p>哈希函数在密码系统中使用十分广泛，包括加密方案、签名方案等都有哈希函数的存在,因此哈希函数也已经成为很多黑客攻击的目标。对哈希函数的攻击主要在于破坏其某些特性。例如,可以根据其输出求得输人,找到某条消息使得它的输出与原消息的输出相同,或者找到不同的两条消息,使它们的输出相同。最具有代表性的对哈希函数的攻击为以下两种。</p>
<ol>
<li>
<p><strong>字典攻击</strong><br>
字典攻击(Dictionary Attack)的定义是,在破解密码或密钥过程中,通过逐一尝试用户自定义词典中所有可能的密码(单词或短语),这种攻击方式称为字典攻击。字典攻击与暴力破解相似,区别在于,暴力破解会逐一尝试所有可能的组合密码,没有预先预定好的单词列表,而字典攻击会使用一个预先定义好的单词列表(可能的密码)进行逐一尝试因此,字典攻击对用单向哈希函数加密的口令文件特别有效。攻击者通过编制含有多达几十万个常用口令的表,然后用单向哈希函数对所有口令进行运算,并将结果存储到文件中,攻击者通过非法途径获得加密的口令文件后,比较这两个文件,观察是否有匹配的口令密文,这种攻击方式的成功率非常高。</p>
</li>
<li>
<p>生日攻击<br>
生日攻击(Birthday Attack)的原理是一个统计问题。一个房间里有多少人才能够使得最少有一人与你的生日相同的概率大于 1/2 呢?答案是 253。那么应该有多少人才能够使得他们中至少有两人的生日相同的概率大于 1/2 呢?23 人即可。寻找特定生日的某人,或者是寻找两个随机的具有相同生日的两个人,与对单向哈希函数进行穷举攻击的方法是相同的原理:前者对应了给定消息$m$的哈希值$H(m)$,攻击者不断生成其他消息$m’$,以使得 $H(m)=H(m’)$;后者对应的场景是,攻击者寻找两个随机的消息 $m$和$m$并使得 $H(m)=H(m’)$,而后者称为生日攻击,这种攻击方式没有利用哈希函数的结构和任何代数弱性质,只依赖于消息摘要的长度,即哈希值的长度。为了抵抗生日攻击,哈希函数安全性的一个必要条件就是消息摘要必须足够长。</p>
</li>
</ol>
<h4 id="哈希函数主要应用">哈希函数主要应用</h4>
<p>在密码学中,哈希函数有非常多的应用场景,包含数据认证、数字签名、伪随机数生成和密钥生成等。</p>
<ol>
<li>
<p><strong>数据认证</strong><br>
哈希函数的重要应用之一就是生成文件或者消息 $m$ 的摘要值 $H(m)$,该值被安全地存储,对消息$m$的任意改动都可以通过对改动后的 $m $进行相同的哈希运算而被检测出来,这样的操作保证了数据的完整性,也可以实现对消息的安全认证。对于哈希函数的不同应用,包括 HMAC,即基于哈希函数的消息验证码,其基本思想就是用密钥和消息一起进行哈希操作,确保消息的完整性,使得在传输过程中对消息的任何修改都能够被接收者检测到。</p>
</li>
<li>
<p><strong>数字签名</strong><br>
哈希函数经常被应用在数字签名算法中。在现实应用中,需要签名认证的消息$ m $本身非常大,如果直接在消息 $m$ 上做数字签名效率会非常低。通常情况下,为实现对消息$m$ 的高效数字签名,首先计算出 $m$ 的哈希值 $H(m)$,然后采用私对 $H(m)$进行签名操作,所得到的 $Sig(H(m))$就是用户对消息 $m$ 的签名。利用哈希函数进行数字签名的优势是,可以实现对于消息的不可否认性,消息发布者只能用自己的私钥对哈希值进行签名,接收者使用发布者的公钥进行解密,从而确认消息确实由该消息发布者发出。</p>
</li>
<li>
<p><strong>伪随机数生成</strong><br>
从哈希函数的定义来看,哈希函数具有生成随机性质的数据序列的特征。通过选择一个随机函数,把消息的随机函数值作为它的哈希值来产生,从而得到伪随机数。因此，哈希函数也可以用作伪随机数的生成器。</p>
</li>
<li>
<p><strong>密钥生成</strong><br>
利用哈希函数的单向性,用旧的密钥计算出新的密钥序列,从而使得现有密钥具有泄露后不危及先前所用的密钥的性质,也就是使用哈希函数能够产生具有前向安全的密钥总体而言,哈希函数在密码学的应用中一直发挥着重要的作用,在区块链中也有着十分广泛的应用,如区块链中的链式结构就是通过让每一个区块包含上一个区块的区块头哈希值来实现的。此外,区块链中的默克尔树构造、工作量证明算法、钱包地址等都用到了哈希算法。</p>
</li>
</ol>
<h3 id="默克尔树">默克尔树</h3>
<ol>
<li><strong>基本概念</strong><br>
默克尔树(Merkle Tree),也称 Hash Tree,是用于存储哈希值的二叉树。默克尔树<br>
包含叶节点和非叶节点,其中叶节点用于存放数据块(例如,文件或者文件的集合)的哈希值,所有非叶节点是其对应所有子节点的组合结果的哈希值。<br>
图3.5为一个默克尔树的结构。在树的最底层,也就是叶节点,类似于哈希列表，需要计算的数据被分制成不同的数据块,将数据块的哈希值存放于叶节点。接着计算时并不是直接计算叶节点的哈希值,而是把相邻的两个叶节点的哈希值合并成一个字符串，然后运算这个合并字符串的哈希值。例如,图 3.5 中 $H_6= H(H_2,H_3)= H(H(L_1),H(L_2))$，从而得到一个“子哈希值”。如果最底层的叶节点总数不是双数,那么必然出现一个无法配对的单身哈希数据块，这种情况就直接对它进行哈希运算,也能得到它的子哈希值。以此类推,就可以得到数目更少的新一层的哈希值,最终必然形成一个哈希树结构,直到树根的位置,就只剩一个根哈希值,称为默克尔树根节点值(Merkle Tree Root)。</li>
</ol>
<p><img src="/img/blockchain_sec/3_1.jpg" alt="默克尔树示意图"></p>
<ol start="2">
<li>
<p><strong>主要特点</strong><br>
默克尔树相比其他数据结构,具有一些特殊的性质。</p>
<ol>
<li>默克尔树是一种树状结构,大多数是二叉树，也有可能是多叉树,但无论是几叉<br>
树,它都具有树状结构的所有特点。</li>
<li>默克尔树的所有叶节点的值是数据集合的单元数据的哈希值。</li>
<li>默克尔树非叶节点的值是根据它左右子节点的值,按照特定的哈希算法计算<br>
得出。</li>
</ol>
</li>
</ol>
<p>一般而言,通常采用SHA-2 和 MD5 作为加密的哈希算法。但如果仅仅防止数据不是蓄意的损坏或篡改,可以改用一些安全性较低但效率较高的校验和算法,如循环冗余校验(Cyclic Redundancy Check,CRC)。</p>
<p>在区块链中,假设一个默克尔树包含 N 笔交易数据当需要验证一笔指定的交易是否存在于某一区块中时，参与者至多花费 $2log_2(N)$次的计算就可以得到结果。这主要是由Merkle 树的构建方式来决定的,它的叶节点值由交易数据的哈希计算得到,并自底向上计算哈希值构建更新上一层节点的数值,直到计算得到默克尔树根节点值,并验证其是否发生变化。假设区块中的交易数量为奇数,则可以重复某笔交易来获得偶数笔交易,避免叶节点无法配对的现象出现,并实现默克尔树的构建。</p>
<h3 id="布隆过滤器">布隆过滤器</h3>
<ol>
<li>
<p><strong>基本概念</strong><br>
20世纪70 年代,Burton Howard Bloom 教授提出了布隆过滤器(Bloom Filter)的概念,它的核心包含一系列哈希映射函数和一个很长的二进制向量,用于快速检索判断一个元素是否存在于某个集合中。布隆过滤器的优点在于空间效率和查询效率非常高,远远区块链安全超过一般的算法,因为它在进行查询时,采用位数组表示一个集合,这样的算法结构大大节省了存储空间,提高了效率,但它也有不足之处:删除困难,以及存在一定概率的误识别,也就是假正例(False Positives)的现象，即当布隆过滤器经过运算向系统报告某一元素在集合中时,事实上它判断错误,该元素并不在集合中,布隆过滤器将一个不属于集合的元素误检测为集合中的元素。相对于假正例现象,布隆过滤器不会发生假反例(False Negatives),也就是如果一个元素不在查询集合中,那么布隆过滤器是不会向系统报告该元素属于集合。换句话说,布隆过滤器判断一个元素不在集合中,就一定不在，但当它判断一个元素在集合中,就存在一定的判断误差,可能导致结果不准确。布隆过滤器的优缺点反映了它是用较小的错误率来换取较高的运算效率,适用能容忍容错率的应用场景，而无法适用“零错误”的场景。</p>
<p>布隆过滤器的常用的应用场景包含:判别某个元素是否存在于一个集合中,为实现这个目标,通常的做法是采用哈希表(Hash Table)数据结构,它可以通过一个哈希函数将一个元素映射成一个位阵列中的某个点,并且这些位阵列的初始值都为 0,当有元素映射到位阵列中的某一点时,就将这一点的值设置为 1。因此,要知道某个集合中是否有该元素,只需要判断这个点在哈希表中对应的位置是否为 1,就可以知道集合中有没有该元素。这就是布隆过滤器的基本思想,算法的具体过程如图 3.6 所示。将所有元素通过布隆过滤器保存至集合中,然后通过比较确定该元素是否存在于该集合。链表、树等结构也采用同样的方式进行判断。</p>
<p><img src="/img/blockchain_sec/3_2.jpg" alt="默克尔树示意图"></p>
<p>但采用这样的方式进行数据存储和查询,存在着一些难以避免的问题:首先，随着集合中元素的增加,哈希表所需要的存储空间越来越大,检索速度也会变得越来越慢。其次,这样的结构面临的另一个问题就是冲突,假设哈希函数是合适并且良好的，如果位阵列长度为 m 个点,那么若想将冲突率降低到 1%,这个哈希表就只能容纳 m/100 个元素显然就无法实现所有空间有效的要求:为解决无法实现所有空间有效的问题，解决方法是可以使用多个哈希函数,数据可以采用多个哈希函数进行映射存储,便可以实现空间有效,正确判断某个元素是否在集合中。</p>
</li>
<li>
<p><strong>布隆过滤器的算法过程</strong></p>
<ol>
<li>选取$ k$个哈希函数,每个函数可以把目标数据 $d $哈希为 $1$个整数</li>
<li>初始化一个长度为$n $位的数组,每位初始化为 $0$。</li>
<li>在某个数据$d$ 加人集合时,用个哈希丽数计算出 个哈希值，并把数组中对应的位置为 $1$。</li>
<li>在判断数据 $d$ 是否存在于该集合时,用k个哈希函数计算出 个哈希值,并查询数组中对应的位,如果所有的位都是 $1$,则认为该$ key$ 在集合中;反之,则不存在。</li>
</ol>
</li>
<li>
<p><strong>布隆过滤器的主要特点</strong><br>
<strong>布隆过滤器的优势有以下 5 点:</strong></p>
<ol>
<li>空间上的低存储量和时间上的高效性,布隆过滤器的存储空间、插人和查询时间都是常数,相比于其他的数据结构,布隆过滤器有着天然具备的高效性;</li>
<li>布隆过滤器中采用的哈希函数相互之间没有关系,具有硬件并行实现的编辑性;</li>
<li>布隆过滤器不需要存储元素本身,因此对于某些保密要求非常严格的数据和场合,在安全性上相比其他数据结构具有绝对优势；</li>
<li>布隆过滤器可以用于表示全集数据,实现数据的完备性;</li>
<li>布隆过滤器还具备的特点是,当哈希函数的数量k和阵列数量 m 相同时,使用同一组哈希函数的两个布隆过滤器的交并差运算可以使用位操作进行。</li>
</ol>
<p><strong>布隆过滤器也存在一定劣势:</strong></p>
<ol>
<li>随着存人的元素数量增加,数据查询的误算率也会随之增加。</li>
<li>从布隆过滤器中安全地删除元素信息较为困难,通常采用的方法是把位列阵变成整数数组,对插人元素进行计数,每插人一个元素相应的计数器加 1,这样删除元素时将计数器减 1。然而,这样的操作可能导致信息的泄露,因为首先必须保证删除的元素的确在布隆过滤器里面,而这一点单凭过滤器是无法保证的。</li>
</ol>
</li>
</ol>
<h3 id="数字签名">数字签名</h3>
<h4 id="基本概念">基本概念</h4>
<ol>
<li>
<p><strong>数字签名性质</strong></p>
<ol>
<li>唯一性。对一个文档的签名,是指对文档的哈希结果进行签名,从函数的角度来说,文档和签名之间存在一一对应的映射关系,不同文档的哈希值不同,对它的签名结果也是不同的。</li>
<li>不可否认性。签名者采用自己的私钥对某个文档进行签名,一旦签名完成,签名者不能否认该签名，同时其他人在不知道签名者私钥的情况下,不能够伪造该签名者的签名。</li>
<li>时效性。为了避免一个签名被重复使用,文档的签名需要具备时间属性,保证签 名的时效性。</li>
</ol>
</li>
<li>
<p><strong>数字签名分类</strong></p>
<ol>
<li><strong>按照签名用户分类</strong>。依照用户的个数分类,数字签名方案包括单个用户或多个用户的签名,通常情况下数字签名都是单个用户的操作,当有特别需求时会用到多个用户共同计算的数字签名,它被称为多重数字签名,依照签名的步骤中是不是有序,多重签名分为有序多重数字签名和广播多重数字签名。</li>
<li><strong>按照数字签名的特性分类</strong>。根据签名的特性分类,数字签名包括自动回复和不自动回复的签名方案。</li>
<li><strong>按照数学难题分类</strong>。依照签名方案根据的问题难解程度分类，数字签名包括基于离散对数问题的数字签名方案和基于大整数分解问题的数字签名方案。更进一步,著名的 EIGamal,DSS 签名方案便是基于离散对数问题的数字签名方案,RSA 签名方案是最突出的基于大整数分解问题的数字签名方案。离散对数问题中还包括一类椭圆曲线离散对数,椭圆曲线签名方案的安全性便是基于椭圆曲线离散对数问题的难以解决特性。</li>
<li><strong>按照数字签名的实现分类</strong>。按照数字签名的实现分类,数字签名包括仲裁数字签名和直接数字签名。仲裁数字签名涉及三方:签名者、接收者和仲裁者。完整的签名过程需要三方协作完成,其中仲裁者是一个可信第三方。直接数字签名的操作是在数据签名者和数据接收者之间完成的。</li>
</ol>
</li>
</ol>
<h4 id="椭圆曲线数字签名">椭圆曲线数字签名</h4>
<p>1985 年,Neal Koblitz 和 Victor Miller 提出了椭圆曲线密码(ECC)系统,它可以看作是离散对数密码系统的演化,只是元素的选取变换为椭圆曲线上的一个点。椭圆曲线密码系统的优势在于可以达到和离散对数密码系统同等安全性的同时,具有更小的参数、钥长度和更快的运算速率,因此能够适用存储、计算环境受限的场景。在椭圆曲线密码:统中,基于椭圆曲线离散对数问题(Elliptic Curve Discrete Logarithm Problem,ECDLI的难解性,可以构造数字签名方案,也就是椭圆曲线数字签名算法(Elliptic Curve DigiSignature Algorithm,ECDSA),下面重点介绍算法的执行步骤。</p>
<ol>
<li>
<p><strong>数字签名算法</strong><br>
Alice 要将一份签名的消息发送给 Bob,为了保证通信的安全性,双方首先需要定义一组如下的椭圆曲线签名算法的参数:$(CURVE,G,n)$</p>
<p>具体来说,CURVE是选取的椭圆曲线的几何方程和点域,$G $是圆曲线上的基点表示可倍积阶数(Multiplicative Order),它是一个很大的质数,几何意义在于满足 $nG=0$,即点倍积 $nG$ 的结果是没有意义的,而任何一个小于$n$的正整数$m=[1,n-1]$,点倍积$mG$ 都可以映射为该椭圆曲线上的一个点。</p>
<p>然后,Alice 生成一对公钥和私钥。私钥是从$[1,n-1]$随机选取的,即$d_A=rand(1,n-1)$<br>
公钥计算如式(3.17)所示:$Q_A=d_A×G$</p>
<p>Alice 通过以下步骤对消息$ m $进行签名。</p>
<ol>
<li>采用哈希函数(MD5或 SHA-1)计算消息m的哈希值,得到$e=H(m)$。</li>
<li>对$e$进行二进制分解，将最高位$L$个位记为$z$,其中$L_n$表示的二进制长度。<br>
需要注意的一点是,$z $的取值可能大于 $n$,但长度不会比 $n$ 更长。</li>
<li>选择一个随机整数$ k ∈[1,n-1]$。</li>
<li>计算椭圆曲线上的点$(x_1,y_1)=kG$。</li>
<li>计算$r=x_1mod\ n$,若$r=0$,返回3。</li>
<li>计算$s=k^{-1}(z十rd_A)mod\ n$,若$s=0$,返回3。</li>
<li>Alice 生成的数字签名为 $ρ=(r,s)$。</li>
</ol>
</li>
<li>
<p><strong>数字签名的验证</strong><br>
消息接收者 Bob 收到的文件包含两部分内容:一个是签名文件 $ρ$,另一个是发送者的公钥,因此 Bob 需要分别验证这两部分的真实性、有效性和正确性。</p>
<ul>
<li>验证公钥
<ol>
<li>公钥的坐标$Q_A$应该是有效的,不会等于一个极限值空点。</li>
<li>对公钥 $Q_A$的坐标进行验证,它必须是圆曲线上的一点。</li>
<li>公钥$Q_A$与n的关系必须满足条件:$ n×Q_A = O$</li>
</ol>
</li>
<li>验证签名文件
<ol>
<li>验证$ρ=(r,s)$均是处于$[1,n-1]$范围内的整数,否则验证失败。</li>
<li>计算$e=H(n)$。</li>
<li>计算$e$的二进制分解,并取最高位$L_n$个位，记为$z$。</li>
<li>计算$w,w=s^{-1}mod\ n$。</li>
<li>计算参数$u_1,u_2$,其中$u_1=zw\ mod\ n,u_2=rw\ mod\ n$。</li>
<li>计算$(x_1，y_1)$,判断$(x_1，y_1)$这个点是否属于椭圆曲线，若不是则验证无效,具体的验证方法是计算式(3.19),判断左右两边是否相等:$(x_1,y_1)=u_1×G+u_2×Q_A$；如果不成立,那么对消息$ m $的签名验证失败。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="EIGamal签名">EIGamal签名</h4>
<p>基于有限域上离散对数问题难以解决的特性,1985年,有名的EIGamal数字签名方案得以提出。下面是获得签名结果所需要完成的具体步骤。</p>
<ol>
<li>任选一个大素数 $p$,群$G$上的一个本原元$α$和一个随机整数$d,d[1,p-2]$。</li>
<li>计算$β,β=a^d\ mod\ p$。</li>
<li>令$p,α,β$作为公钥，$d$ 作为私钥。</li>
<li>签名过程:计算消息的哈希值$x=H(m)$,任选整数$k,k∈[1,p-2]$,且$(k,p-1)=1$,然后令$r=α_k\ mod\ p,s=(x-dr)k^{-1}\ mod\ (p-1)$,则最终的数字签名结果是$(r,s)$。</li>
<li>对数据完成签名后,将最终的数据签名结果和明文数据共同传输给数据接收者</li>
<li>接收者收到消息后,计算$t=β^rα^s\ mod\ p$。</li>
<li>当满足:$t=α^x\ mod\ p$时,说明签名结果有效,消息在传输过程中是完整的,没有被篡改,否则表明签名无效。</li>
</ol>
<p>由于有限域上的离散对数问题是难解的,攻击者不能根据已知信息推测出私钥，保证了 EIGamal 数字签名方案的安全性。一般地,素数 $p$ 的长度不得少于 $1024 $位,签名方案由$(r,s)$数对组成,其中$r$和$s$的位长度都与$p $相同。</p>
<h4 id="多重签名">多重签名</h4>
<p>在数字签名领域,除了一个人对一份文件进行签名的情况,有时还需要多个人同时对一份文件进行签名,这种需求常常发生在电子商务、资金监管等场景。简单来说,就是多个用户对一份文件具有签名权,共同来产生文件的签名,这就是多重数字签名的含义。具体地,假定有 $N $个用户${1,2,…,N}$,每个用户都拥有一对公钥和私钥，用户用各自的私钥签署文件 $m$,最后得到关于文件 $m$ 的多重签名。</p>
<p>在多重签名的场景中,按照要不要提前约定签名者的签名序列,可以将多重签名分为有序多重数字签名和广播多重数字签名。顾名思义,有序多重数字签名就是将数据依照既定的排列顺序发送给签名者完成签名。与有序多重数字签名相反的广播多重数字签名方案中,每个签名成员各自完成单个签名数据,发给数据收集者,由收集者最终合成多重签名的数据,然后发给验证者来完成验证操作。多重签名主要包含 3 个参与方:消息发送者、消息签名者以及签名验证者。但需要注意的一点是广播多重数字签名中还需要引人消息收集者。常规地,多重签名包括 3 个算法:系统建立、获得签名和签名验证。</p>
<p>下面通过一个基于椭圆曲线的广播多重数字签名算法的例子来展示多重数字签名的<br>
过程。</p>
<ol>
<li>
<p><strong>系统建立</strong><br>
令$GF(g)$代表一个包括$q$个元素的有限域,这里 $q$ 是一个大于$2^{160}$的大素数,抽取$GF(q)$上一条安全的椭圆曲线 $E: y^2=x^3+ax十b(a,b∈GF(q))$,$G$ 是$E$ 的基点(即$nG=0$),$M$ 是需要签名的数据。设有 $m$ 个数据签名者 $U_1,U_2,…,U_m$,对每个签名者$U_i(i=1,2,…,m)$随机抽取一个隐藏值 $d_i(d_i∈Z_q)$作为自身的私钥,设置公钥 $Q_i=d_iG$并公布出去。$P$ 是一个预设的正整数。</p>
</li>
<li>
<p><strong>获得签名</strong><br>
对于每个签名者 $U_i(i=1,2,…,m)$和签名验证者$U_v$消息拥有者发送消息$(M,T)$，其中$T$是签名时间标志,要求签名者在给定时间 $△T$ 内完成签名。对消息 $M$，消息拥有者计算$e=H(M,T)$,并发送给$U_i$,和$U_v$,然后$U_i$和$U_v$进行如下操作。</p>
<ol>
<li>每一个签名者$U_i(i=1,2,…,m)$选取一个随机整数 $k_i$;,其中$k_i∈[1,m-1]$。</li>
<li>计算$R_i=k_iG=(x_i;y_i)$,若$x_i=0$ 转回1;否则计算 $r_i=x_i\ mod\ m$。</li>
<li>签名者$U_i$计算$s_i=k_ie+d_ir_i\ mod\ m$,若$s_i=0$转1;反之将数据签名$(M,(r_i,s_i))$发送给数据收集者 $U_c$。</li>
<li>数据收集者 $U_c$收到签名数据后,依次对单个的签名完成验证,若验证不正确则要求该签名者重发,但重发次数不能超过$ P$。</li>
<li>若是全部签名者的签名所得 $s_i$ 验证都是有用且正确的,数据收集者 $U_c$ 设置$\sum_{i=1}^m s_i$，则$s$ 作为最后的广播签名$U_v$。将 $sig(M)=(M,(r_1,r_2…r_m,s))$ 发送给签名验证者$U_v$。</li>
</ol>
</li>
</ol>
<h4 id="群签名">群签名</h4>
<ol>
<li>
<p><strong>群签名的定义</strong><br>
群签名概念的提出首次出现在 1991 年的欧密会上。从字面上理解,群签名首先包含系列合法的群成员，在一个群签名方案中,群组中任意一个群成员都能够以匿名的形式代表整个群组对一个消息进行签名,与普通的数字签名方案类似,群签名结果也是可以公开验证的，系统中的验证者可以采用群公钥对签名进行验证,确认该签名确实来自群组，证明签名由群组里的合法成员生成,但并不能确定群组里签名者的身份,只有当签名结果发生争议时,群管理员利用系统权限可以追踪到群组里签名成员的真实身份。</p>
<p>一般情况下，群签名方案涉及3个实体:群中心群管理员和群成员。其中,群中心负责方案的初始化建立;群管理员负责在签名发生争议时,追踪群组里签名者的真实身份信息;群成员构成一个完整的群组,可以以群组的名义对数据签名。另外,群签名方案还包括以下5个算法。</p>
<ol>
<li>系统建立<br>
系统建立算法由群组中的权威机构群管理中心执行,输入系统的安全参数入,输出方案中群组的公钥和私钥对。</li>
<li>成员加入<br>
成员加人算法由权威机构群中心与群成员交互履行,获得群成员的公钥$k_P$和私钥$k$,群管理中心获得公钥$k_P$信息,私钥$k$ 由群成员保存。</li>
<li>签名<br>
签名算法由群组里的一个合法成员执行,输人消息 $m$ 和自己的私钥$k$,输出消息m的群签名$SIG$</li>
<li>验证<br>
验证算法由验证者履行,输人消息 $m$、群签名 $SIG$ 以及群公，作出关于该群签名是 否正确的判定。</li>
<li>打开签名<br>
打开签名算法由群管理员履行,输人消息 $m$、群签名 $SIG$以及群管理员的私钥,可以追踪到群组里签名成员的真实身份。</li>
</ol>
</li>
<li>
<p><strong>群签名的特性</strong></p>
<ol>
<li>代表群组对消息进行签名的只能是群组里的合法群成员。</li>
<li>方案中的验证者只能作出签名是否正确的判定,而他不可以获得签名成员的身份信息。</li>
<li>当签名得到的结果出现争议时,只有群管理员可以打开签名，追踪到签名者的身份信息。</li>
</ol>
</li>
<li>
<p><strong>群签名的安全性</strong><br>
一个好的群签名方案除了具有优质的算法,还需要满足如下的安全要求。</p>
<ol>
<li>正确性<br>
群组里的每一位合法群成员只有按照正确的步骤进行签名,得到的签名结果才能被验证者验证通过。</li>
<li>匿名性<br>
在群签名系统中,除了群管理员和其他权威机构,任何人都不能从签名中获得签名者的身份信息。</li>
<li>防伪造性<br>
群组里的合法成员用自己的私钥能够产生消息的合法签名,其他人不能盗用合法成员的私钥,伪造其签名结果。</li>
<li>非关联性<br>
除权威机构外,任何人想通过多个签名信息获得签名成员更多的身份信息,在计算上是不可行的。</li>
<li>可追踪性<br>
在签名结果产生争议时,群管理员或权威机构利用系统权限能够打开签名,查找到签名者的身份,即每一个群签名都是可被跟踪的。</li>
<li>不可否认性如果群组中任意一位合法成员用自己的私钥代表群组对消息进行签名,那么对于该群签名，他不能否认和抵赖。</li>
</ol>
</li>
</ol>
<h4 id="环签名">环签名</h4>
<ol>
<li>
<p><strong>环签名的定义</strong></p>
<p>环签名的概念首次由 3 位著名的密码学家于 2001 年提出，是指签名者在签名的过程中,通过引人其他人的公钥来隐藏自己私钥的一种签名方案。环签名的提出晚于群签名，一者有相似也有不同,可以把环签名看作是群签名的一种特殊形式或者是简化版的群答名。在环签名方案中,没有管理中心，没有环的创建,只有环成员,而且环成员之间不需要协同互助。当某个合法的环成员要对消息进行签名时,他首先创建一个临时群组，然后用自己的私钥和其他环成员的公钥独立地对一个消息进行签名，这样就能将自己的私钥信息隐藏在多个公钥中,不需要群组中其他环成员的帮助,同时这些环成员也不一定知道自己包含在某个群组中。</p>
<p>假设签名集合中有 $n$个环成员，一个完整的环签名方案主要由以下3个步骤组成。</p>
<ol>
<li>密钥产生<br>
输人安全参数$ λ$,对于系统中的每一位环成员,产生相应的公钥和私钥对$(k_{p_i},k_{s_i})(i=1,2,…,n)$,需要注意的一点是，这些公钥和私钥对可能来自不同的公钥密码体制。</li>
<li>签名<br>
输人数据$m$、签名者的私钥$k_{s_j}$和其他环成员的公钥$k_p={k_{p_i}|i=1,2,··,n,i\neq j}$,得到数据$m$的环签名$r$。</li>
<li>验证<br>
输人数据 $m$ 和环签名$r$,验证者作出该签名是否正确的判定,即签名者是不是群组中有效的环成员。</li>
</ol>
</li>
<li>
<p><strong>环签名的特性</strong></p>
<p>环签名具有良好的特性:可以实现签名者的无条件匿名,环签名是特殊的群签名,没有权威机构和初始建立阶段,签名者的身份信息对于验证者来说是完全匿名的;签名者对需要匿名的匿名区域和跨度具备决议权,即环成员的个数 是由签名者决议的;显而易见,对于群签名能够实现的功能,环签名也可以完成,并且参与方更少,不需要权威机构和管理员。</p>
</li>
<li>
<p><strong>环签名的安全性</strong></p>
<ol>
<li>正确性<br>
环成员依照既定的算法执行得到环签名结果,并且在传输过程中不存在篡改的情况那么签名结果就可以被验证通过。</li>
<li>无条件匿名性<br>
攻击者根据环签名,无法确定是哪个环成员生成了这个签名，即使他采用非法途径获得了所有可能的环签名者的私钥,攻击者确认真实签名者身份信息的概率不高于 1/n,n是可能的签名者的个数。</li>
<li>不可伪造性<br>
非签名者的环成员不能够捏造真实数据签名者的签名,对外部攻击者即便他截获了一个正确的环签名,可是他不知道任何环成员的私钥,不能够形成对该签名的捏造，捏造正确的概率是可以忽略不计的。</li>
</ol>
</li>
<li>
<p><strong>环签名与群签名的比较</strong></p>
<ol>
<li>相同点<br>
环签名和群签名都是某个成员代表整个群组对消息进行签名,对于验证者来说，他能够验证这个签名是否来自群体中的成员,而无法知道这个签名者到底是群体中的哪一个.即验证者只能验证签名的有效性,不能获得签名者的身份信息，以此来实现签名者的匿名性。</li>
<li>不同点</li>
</ol>
<ul>
<li>在群签名中,每一个签名都是可被跟踪的,只有群管理员具有系统权限，必要的时候可以追踪到签名者的真实身份信息;而环签名中没有管理员，因此签名无法做到可追踪性,除非签名者主动暴露自己的身份信息。</li>
<li>群签名中的群管理员负责系统的维护,环签名没有环的建立,签名者只是选取临时群组中环成员的公钥,每一个环成员的身份都是平等的。</li>
</ul>
</li>
</ol>
<h2 id="第4章-区块链共识协议">第4章 区块链共识协议</h2>
<h3 id="CAP原理">CAP原理</h3>
<p>CAP 原理是用于设计分布式系统的基本原理,由计算机科学家 Eric Brewer 所提出。CAP 原理定义一个分布式系统不可能同时满足一致性、可用性和分区容错性。CAP 原理阐述了这 3 个特性不能在异步通信网络环境中同时满足,只能满足其中任意两个特性，即满足一致性和可用性、一致性和分区容错性,或者可用性和分区容错性,如图 4.1 所示。具体来说,3 个特性的定义如下。</p>
<ol>
<li>一致性($Consistency$):指分布式系统中节点对事务操作具有原子性,每个操作都可以及时被完成,以至于所有的事务都是有序的。</li>
<li>可用性($Availability$): 指分布式系统必须响应正确节点发出的每个事务请求。</li>
<li>分区容错性($Partition-Tolerance$): 允许分布式系统中的部分节点接收不到其他节点发送的事务信息。例如,当分布式系统分区以后,一个分区的节点接收不到另一个分区的节点发送的事务信息。</li>
</ol>
<p>其中,一致性和可用性是依据一个分布式系统是否满足分区容错性的需要来定义的。换句话说,如果一个分布式系统必须具备一致性,那么即使有些节点没有接收到其他节点的信息,系统也要维持一致性这一特性。类似地,如果可用性是必需的,那么即使存在分区现象,系统也必须响应每一个正确节点的请求。因此,CAP 问题可描述为这样的问题:异步网络中的分布式系统在满足分区容错的情况下,可用性和一致性二者取其一。</p>
<p>用一个通俗的例子来理解 $CAP$ 问题:假设现在存在一个 A 地和 B 地共同维护的分布式数据库,用户 Alice 在 A 地的数据库修改了一项数据。在 A 地的数据跟 B 地的数据库同步该用户事务操作结果的时间内,B 地的用户 Bob 请求读取 B 地数据库的数据由于是在异步的网络环境下,存在网络延迟问题,A 地所发生的事务操作结果还没同到B地。如果要保证可用性,B 地的数据库必须对用户的读请求进行及时响应，而 Bol得到的数据肯定和 Alice 的数据不一样,这样显然不满足一致性。而如果要保证一致性那么B地数据库这时应该要锁定数据库且与 A 地数据库同步事务操作结果，然而,这个时候 B地的用户不能访问到 B 地的数据库,这样就失去了可用性。</p>
<p><img src="/img/blockchain_sec/4_1.png" alt="区块链扩展“不可能三角”"></p>
<p>区别于上述的 CAP原理,以太坊创始人 Vitalik Buterin 将区块链的可扩展性问题描述为“扩展不可能三角”问题。该问题在要求每个参与者验证每一笔交易的情况下,区块链最多只能满足如下 3 个特性中的两个特性:区块生成的去中心化性、安全性和可扩展性,如图 4.3 所示。实际上,区块链为了达到安全性和去中心化的特性,牺牲了可扩展性(可用性),因而无法满足很多实时应用场景的需求。然而,如果区块链系统要达到较好的可扩展性，同时满足较高的安全性,那么系统就不得不牺牲去中心化特性。同样地，既要实现高可扩展性以及完全的去中心化特性,安全性又会被削弱。实际上,如果要量化这3个特性，区块生成的去中心化性根据块生成者的数量来评估,安全性指攻击者发起拜占庭攻击成功的开销,而可扩展性可以通过区块链单位时间内处理的交易数量来评估。</p>
<h3 id="Paxos-算法">Paxos 算法</h3>
<p>Paxos 算法由著名计算机科学家 Leslie Lamport 提出，它是实现异步通信环境下容<br>
错分布式系统中共识问题的经典算法之一。值得注意的是,这里所说的容错是指容忍计算机崩溃而引发的错误$(Cash Fault Tolerance,CFT)$,如硬件错误、软件错误或内存错误,并非指容忍拜占庭错误。</p>
<p>首先，让我们来先回顾一下分布式共识问题。假设存在多个参与者,每个参与者都可以发出提议,每个提议中包含一个值,这里的共识问题是指有且仅有一个提议的值被选中。如果没有一个参与者提议值,则没有任何提议值被选中。如果一个提议的值已经被选中,那么所有参与者都会承认已选中的这个值。Lamport 将这个共识问题中的一致性描述成 3 个必须满足的条件。</p>
<p>(1)只有提议的值被选中。<br>
(2)有且只有一个值被选中。<br>
(3)每一个参与者仅承认被选中的值。</p>
<p>接着,Lamport 教授提出了支持容错的 Paxos 算法，以实现在异步网络环境下满足上述3个条件的共识算法。Paxos 算法主要解决用户在低可靠的服务器环境中,满足一定条件下即可实现可靠、确定的共识一致性。即使在不满足条件的情况下,也可以保证服务器实现一致性。</p>
<p>在介绍 Paxos 算法之前,首先先介绍该算法对参与者角色的定义和每个角色的职能具体来说,参与者被定义为三种角色:提议者、接受者和承认者。其中,提议者负责给出提议值,接受者接受和选中提议者提议过的值,承认者则是承认接受者选中的提议值。初步分析来看,只有一个接受者时是选中一个提议值最简单的情况,接受者接受并选中第一个由提议者发送给它的提议值就可以了。然而在这种单个接受者情况下,如果出现因机器导致的单点故障问题,就会直接导致接受者失败处理,共识问题就进行不下去了。因此,本节主要讨论存在多个接受者的情况,并且规定只有那个被大多数接受者接受并选中的提议者才被最终选中和被承认者承认(任意两个大多数接受者集合中都至少有一个相同的接受者)。为了更好地理解 Paxos 算法,需要了解描述算法应该满足什么样的要求才能解决共识问题。</p>
<p>首先,考虑实现即使只有一个提议者提议出一个值,也要选中一个提议值的情况。假定一个接受者必须接受它收到的第一个提议值(记为 P1),是否可以呢?答案是否定的因为当多个提议者提议出不同的值且每个接受者只接受了一个提议值时,不存在一个提议值被大多数接受者接受的情况。以只有两个不同提议值的简单情况为例,假设各有一半的接受者分别接受了一个提议,任何同时在两个大多数接受者集合的接受者如果出现失败的情况,都会导致没有一个提议者被选中。</p>
<p>P1 要求不完备,应该允许一个接受者可以接受不止一个提议值。通过给一个接受者可能接受的每一个提议值标上序号,不同的提议值一定有不一样的序号,先提议的值比后提议的值有更小的序号。现在我们考虑实现当一个提议值已经被大多数接受者接受了它就被选中的情况。在这个情况下,允许有多个提议值被选中的情况,但这些被选中的提议值必须确保是相同的一个值。</p>
<p>基于以上的考虑,定义如果一个提议值  被选中,那么任何一个具有更大序号、被选中的提议值也应该是 v(记为 P2)。如果 P2 被满足,那么就实现了只有一个提议者被选中。由于提议值被选中之前要先至少被一个接受者接受,那么设置条件 P2a: 如果一个提议值被选中,那么任何一个具有更大序号的、被一个接受者接受的提议值也应该是v。然而,P2a 满足了条件 P2 但不满足条件 P1。因为最初已经声明了网络是异步的,所以可能存在这样一种情况:一个刚刚“苏醒”的提议者提议了一个具有更大序号的不同于”的值,然后被某个刚刚“苏醒”的还没接受任何提议值的接受者接受了。注意到这个情况满足 P1 但破坏了条件 P2a,因此需要加强 P2a 的条件,定义条件 P2b 为如果一个提议值被选中,那么任何一个具有更大序号的、由任何提议者提议的值也应该是 v。条件P2b蕴含了 P2a,所以条件 P2b 也蕴含了条件 P2。接下来证明如果条件 P2b 被满足,才能解决共识问题。</p>
<p>假如某个序号为 m 的提议值 被选中了,那么证明任何由提议者提议的序号为n(n&gt;m)的值也是 就相当于证明任何由提议者提议的序号为 m,…,(n1)的值是。因为序号为 m 的提议值 被选中了,所以必须存在大多数接受者已经接受了这个提议值,记这个大多数接受者为集合 C。基于序号 n 的提议值,序号为 m 的提议值 被选中意味着C 中的每一个接受者已经接受了序号从 m 到(n-1)的一个提议值，且它们的值都为v。此外,由于任何一个大多数接受者集合和 C 至少包含一个共同接受者,因此在满足如下 P2c 条件的情况下,可以得出序号 n 的提议值也是v。</p>
<p>P2c: 如果一个序号为n 的提议值 被提议，那么存在一个大多数接受者集合 S 满足S 中没有一个接受者已经接受了任何序号小于n 的提议值，或者被 S接受的所有小于序号n 提议值中那个具有最大序号的提议值就是。</p>
<p>现在讨论满足 P2c 的情况,从而来证明序号 n 的提议值是。一个提议者提议序号为n 的提议值必须先承认已经(或即将)被大多数接受者接受序号最大的提议值。由于预测提议值是否将要被接受者接受比较困难，因此这个提议者只是承诺不存在这样的情况,也就是说,要求接受者不能再接受任何小于序号为 n 的提议值,具体定义如下。</p>
<p>(1)准备阶段。一个提议者选择一个序号 n,然后向每个接受者发出请求,要求接受者承诺:①小于序号 n 的提议值不会被接受;②已经接受的最大序号(序号小于 n)的提<br>
议值为 v。<br>
(2) 接受阶段。如果这个提议者收到的承诺是来自大多数接受者的,它就提议一个提议值 v,序号为 n;如果收到的承诺中没有包含提议值 即②不成立),它就提议一个自己选择的提议值 v,序号为 n。</p>
<p>在上述的定义下,我们得出这一结论:当且仅当一个接受者没有在准备阶段回复一个序号大于 n 请求的承诺,他就会接受一个序号为  的提议值。如果一个接受者在准备阶段接收序号为 n 的请求,而且他也回复过一个序号为 n+1 请求的承诺,那么他将不再接受序号为 n 的提议值,并且直接忽略序号为  的提议值。注意,接受者必须记住已经接受的序号最大的提议值和其序号。因此,Paxos 算法分为两个阶段,每个阶段包含以下两个步骤。</p>
<p><strong>阶段一</strong><br>
(1) 一个提议者在准备阶段发出一个序号 n 的请求给大多数接受者。<br>
(2) 如果一个接受者收到的请求所包含的序号大于他之前回复过的请求的序号，则他回复一个不再接受的序号小于 n 的提议值以及一个他已经接受的序号最大的提议值v。</p>
<p><strong>阶段二</strong><br>
(1)如果这个提议者收到来自大多数接受者的承诺,则他在接受阶段发送一个序号为 n 的提议值v。<br>
(2)如果一个接受者在接受阶段收到一个序号 n 的提议值同时他之前没有回复过为n的提议值V。备阶段序号为n+1的请求的承诺,那么他将接受这个序号为 n 的提议值。</p>
<p>假设存在1个提议者,3个接受者和2个承认者。图 4.4 展示了既不存在网络错误不存在机器错误情况下的 Paxos算法。其中V是指${V_a,V_b,V_c}$中最后的那个值或是提议者自己选择的值。图4.5展示了在有一个接受者因机器错误出现失败情况下,Paxo.算法仍然能实现共识。</p>
<p><img src="/img/blockchain_sec/4_2.png" alt="Paxos算法交互过程:不存在错误的情况"></p>
<p><img src="/img/blockchain_sec/4_2.png" alt="Paxos算法交互过程:存在一个错误接受者的情况"></p>
<h3 id="Raft-算法">Raft 算法</h3>
<p>4.3 节解析了第一个实现共识协议的算法-Paxos 算法,它在过去的几十年内一直是共识协议的代名词,但是该算法本身晦涩难懂,这使得它很难投人实际的应用。一些著名的计算机科学家甚至在 2012 年的计算机网络顶级会议 NSDI(USENIX Symposium onNetworked Systems,Design and Implementation)上表达了对 Paxos 算法的不满。于是同样解决了分布式共识问题的 Raft 算法以一种更易理解的方式被提出。</p>
<p>Raft 算法被分解为 3 个子问题,分别为选举领导节点、日志备份和一致性问题。Raft算法基于领导节点实现分布式节点对日志数据的共识,只要当前不存在领导节点,新的领导节点就会被选举。领导节点从客户端节点接收写人日志的新数据,同时发送消息同步其他节点的日志数据。在算法中,日志数据的数据项和它们的顺序是以状态机的形式进行更新的，一致性要求所有分布式节点的状态要保持相同。</p>
<p>在Raft 算法中,分布式网络节点被分为 3 种,即领导节点(Leader)、随从节点(Follower)和候选节点(Candidate)。在正常情况下,领导节点只有一个,其余的节点都是随从节点。领导节点的职责在于接收并处理客户端的所有请求，随从节点负责响应领导节点和候选节点发出的请求。而候选节点用于产生新的领导节点。另一方面,Raft 算法给出了任期这一定义,任期是指任意时长的时段,同时有一个连续的整数标识。开始一个任期意味着新的领导节点从候选节点中根据大多数投票原则选举产生,被选中的候选节点就成为该任期内的领导节点。值得注意的是,由于在异步网络环境下,网络可能出现通信分片的现象,这样可能导致在分布式节点中不存在大多数投票选出的领导节点。在这种情况下,该任期被中断,新的任期被开启,这保证了在任何情况下,一个任期内都最多只有一个领导节点。</p>
<p>图4.6 展示了节点在不同状态下的状态机迁移过程。每个随从节点各设置了一个任意随机时长的倒计时器(Election Timeout),通常为 150~300ms。一般情况下,节点在收到选举请求或者收到领导节点的心跳(Heartbeat)信息时会重新设置计时器。首先,节点从加人网络开始,假设网络中还不存在领导节点,它们会首先成为随从节点。此后,在一个计时器结束计时之后,这个节点状态自动变为候选节点。这时一个任期开始,候选节点向其他节点发出选举领导节点的请求消息。假设该节点获得大多数(超过半数)的投票，则该节点状态就变为领导节点,以上的过程称为选择领导节点。在领导节点任期内,它持续给其他的随从节点定时地发送心跳消息,从而确保其他节点状态的一致性。当网络中不存在领导节点向外发出心跳包时,开启新任期，随从节点变成候选节点重新选择新的领导节点。注意,每次收到领导节点的心跳包时,随从节点都要重置计时器。若在一个任期内,同时又有两个随从节点变成候选节点,并且都收到同样来自其他节点的票数,那么这个任期被中断,新的任期被开启。Raft 算法根据轮数来进行,每一轮的节点状态都会被记录下来,如果出现新一轮的选举过程,则原来的领导节点自动降级为随从节点。如果候节点 B转发请求给其他随从节点时,不能收到大多数随从节点承认请求的响应,于是它<br>
不可以执行“写人 3”的操作。当客户端 C2 向领导节点C发出“写人 8”的请求时,领导节点C最终可以收到大多数随从节点的承认响应,于是更新日志操作成功。如图4.9 所示假设节点 A、B、C、D 和E可以通信,领导节点 B收到任期序号更高的领导者C的心跳,于是停止发送心跳包。同时,节点 A 和 B 回滚它们没有收到承认的更新日志请求(“写人3”的请求)且与领导节点 C同步日志数据。</p>
<p><img src="/img/blockchain_sec/4_4.png" alt="网络分片时领导节点情况"></p>
<p><img src="/img/blockchain_sec/4_5.png" alt="Paxos算法交互过程:不存在错误的情况"></p>
<p><img src="/img/blockchain_sec/4_6.png" alt="结束网络分片时的同步节点日志"></p>
<h3 id="拜占庭问题与算法">拜占庭问题与算法</h3>
<p>拜占庭容错指的是一个可靠的分布式计算系统必须能够处理计算过程中的任意错误，除了容忍 Paxos 算法中的机器崩溃而导致的错误以外,还包括网络拥塞和遭到恶意攻击引起的错误。从拜占庭问题很容易联想到拜占庭将军问题，假设有 $n$ 个将军各自坚守在相互隔离的战地，通过信差相互通信并达成“进攻”或是“撤退”的一致性指令。然而,这$n $个将军中存在一些叛徒将军可能发送错误的指令，以此来阻挠所有忠诚的将军达成一致性指令的行为。计算机科学家 Lamport 教授形式化地证明了当叛徒将军至多为$m(m&gt;0)$,将军总数不小于$3m+1$的情况下,所有忠诚的将军都获得一致的指令。他把拜占庭将军问题归纳为一个施令将军向其他 $n-1$个副将军发送指令的问题。这个过程要实现指令一致性必须满足以下两个条件。</p>
<p>(1) 所有忠诚的副将军遵循一样的指令<br>
(2) 如果施令将军是忠诚的,则每个忠诚的副将军都会遵循施令将军发送的指令。</p>
<p>Lamport 教授指出当存在 1个叛徒将军、将军总数为3 时,拜占庭将军问题不能解决。如图 4.10 中所示,施令将军和副将军 1是忠诚的,副将军 2 是叛徒。施令将军向副将军 1和副将军 2 发送“攻击”的指令,忠诚的副将军 1 报告“攻击”指令给副将军 2,而叛徒副将军 2 会报告给副将军 1 其收到的是“撤退”的指令。副将军 1 必须执行“进攻”指令，上述条件(2)才可以满足。</p>
<p>假设施令将军是叛徒,副将军 1 和 2 是忠诚的,施令将军发出“攻击”指令给副将军1而发出“撤退”指令给副将军 2,如图 4.11 所示。由于副将军1不能判断施令将军和副将军 2哪一个是叛徒,因此对于副将军 1来说当前的情况与上面讨论的情况其实是相同的他都遵循“攻击”的指令。而对于副将军 2,为满足条件(2),他将执行“撤退”指令。最终将军们不能达成一致性的指令,上述条件(1)不满足。因此,基于这个例子,推广到有m个叛徒将军而将军总数少于 $3m十1$ 的情形时,解决拜占庭将军问题的方法是不存在的。</p>
<p><img src="/img/blockchain_sec/4_7.png" alt="将军总数为3、叛徒将军为1的情形"></p>
<p><img src="/img/blockchain_sec/4_8.png" alt="将军总数为3、施令将军为叛徒的情形"></p>
<p>接下来讨论在 $m$ 个叛徒将军总数不少于$3m +1$的情形下解决拜占庭将军问题的算法$OM(m)$。$OM(m)$算法规定一个施令将军使用口头消息直接向其他$n-1$个将军发出指令。默认情况下,口头消息满足$3$个假设。</p>
<p>(1)每条口头消息都被正确地传输。规定了叛徒不能干扰任意两个将军之间的消息传输。<br>
(2)接收者知道消息的发送者,不允许叛徒伪造其他将军发送的消息。<br>
(3)任何丢失的消息可以被检测到。允许将军发现叛徒不发送消息的行为,在这种情况下,接收者默认该消息为“撤退”指令。</p>
<p>此外,算法还定义了大多数投票函数 $majority(·)$用于从$n-1$个消息 $v_1,v_2,…,v_{n-1}$中获得大多数相同的消息 ,若不存在大多数相同的消息，则输出“撤退”。基于上述假设和大多数投票函数,算法$ OM(m)$的定义如下。</p>
<p>$OM(m)$定义:当$m=0$时,算法执行如下的操作<br>
(1)施令将军发送指令给每一个副将军。<br>
(2)每一个副将军执行从施令将军获得的指令,当没有收到任何指令时,执行“撤退”指令。</p>
<p>当$m&gt;0$时,算法执行如下操作。<br>
(1)施令将军发送指令给每一个副将军。<br>
(2)每一个副将军，收到施令将军的指令,记为$v_i$,若没有收到任何指令,则记为“撤退”;每个副将军作为施令将军执行算法 $OM(m-1)$,向其他$n-2$个副将军发送$v_i$。<br>
(3)每一个副将军，收到从其他副将军$j$($i$不等于$j$)获得的指令,记为$v_j$ ,若没有收到任何指令,则记为“撤退”。最后,副将军:执行大多数投票函数得出的指令$majority(v_1,v_2,…,v_{n-1})$。</p>
<p>实际上，$OM(m)$属子一种递归算法,递归调用 $n-1$次 $OM(m-1)$算法,这$n-1$次中每一次调用了$n-2$次$OM(m-2)$算法,如此递归下去，直到$ m=0$。</p>
<p>为了让读者更易理解 $OM(m)$算法,图 4.12 展示了$m=1、n=4$ 的拜占庭将军问题，4个将军中,副将军3是叛徒,其他将军是忠诚的将军。首先施令将军执行 OM(1)算法，发送指令v给3个副将军;然后,副将军1 执行 OM(O)算法发送指令v 给副将军 2。同时叛徒副将军3发送其他指令x给副将军 2,最后(上述定义(3)),副将军 2 获得了两个指令$v$和一个指令$x$,因此,他通过大多数投票函数得出指令 。</p>
<p><img src="/img/blockchain_sec/4_9.png" alt="将军总数为 4、徒副将军个数为1的情形"></p>
<h3 id="区块链共识基本需求">区块链共识基本需求</h3>
<h4 id="激励兼容">激励兼容</h4>
<p>区块链共识协议需要确保每位参与者能够基于他在区块链的实际贡献获得最高的收益,这称为激励兼容性(Incentive compatible)。在激励兼容的环境下,任何一个参与者不可以采取自私策略谋取更高的收益,否则,整个区块链的安全性不能得到保证。实际上，这一特性也体现了参与者节点在区块链获益的公平性,例如,在比特币中,矿工可以获得的收益与其在区块链上贡献的算力成正比，比特币的作者把这称为“一个 CPU 一个投票权”。</p>
<p>现实世界中对比特币的攻击,如自私挖矿(Self-mining)、女巫攻击(Sybil Attack),破坏了类似于比特币的区块链的激励兼容性。为提高交易吞吐量,有些区块链协议增加区块的大小和区块的生成速率,但这种措施也破坏了激励兼容性。这是因为当区块变大,该区块在网络中传播到所有节点的时间也变长。例如,网络中的参与节点可能还没收到之前的区块,新的区块就已经产生了,从而加重了区块链的分叉现象，破坏了激励兼容性。因此,如何设计支持高吞吐量又能满足激励兼容性的区块链是一个有挑战的问题。</p>
<h4 id="最终共识">最终共识</h4>
<p>最终共识(Final Consensus)是指所有诚实的参与者最终会对区块链的交易数据拥一致性视图,这主要是针对类似于比特币的区块链系统来说的，其他类型的区块链可以法到即时共识(Instant Consensus)。</p>
<p>在比特币区块链系统中,在大部分的参与者都是诚实的情况下,提交到块的交易数报被全网最终确认至少需要 6个区块的确认时间,这就是最终的由来。交易用户要等待丝1小时才能确信交易被最终写进了区块链,这使得比特币区块链系统不适合一些实时交易的场景,而实现即时共识的区块链则可以保证。即时共识指一旦某个区块被添加到区块链上,这个区块就再也不会被区块链抛弃。这类区块链的共识协议往往是基于传统的拜占庭共识算法实现的,属于这类区块链系统的包括 Hyperledger、PeerCensus 等。</p>
<h4 id="活跃性">活跃性</h4>
<p>活跃性是指区块链的参与者愿意持续地创建交易、处理交易和维护区块链的交易历史。区块链的活跃性受两个因素的影响:@参与者的收益贡献比;@区块的生成时间与传播时间。第一个因素指对参与者的金钱激励,它应该与参与者对区块链的贡献成正比,在这一方面,不少研究者讨论如何合理地设置交易费来保证参与者能持续有动力参与区块链。如果交易费太低,且相应的交易又总能被处理,那么久而久之,交易用户就会不愿意支付高的交易费用,进而导致矿工不会有动力去积极地处理交易、维护区块链。另一方面，区块的生成速率与传播时间也关系到区块链的安全性,较高的区块生成速率和较长的传播时间都会降低区块链的活跃性。</p>
<h4 id="正确性">正确性</h4>
<p>正确性是指区块链交易和区块数据的正确性。对于一般的数字加密货币系统来说最关键的安全特性是能够抵抗双重支付攻击。具体来说,签名算法保证了交易不能被伪造，同时有效的交易被添加到区块链后经过一段时间的确认时间最终成为被全网节点承认的正确交易,例如,在比特币区块链系统中,需要等待 6 个区块被确认的时间,大约为1小时。矿工通过竞争解答一个密码学困难问题,并生成一个正确区块,产生的区块的正确性被其他参与节点共同验证。</p>
<h2 id="第5章-区块链安全与隐私">第5章 区块链安全与隐私</h2>
<h3 id="区块链数据安全威胁">区块链数据安全威胁</h3>
<p>区块链之所以能够在以数字货币为代表的应用领域中大放异彩，同时也能够得到其他应用领域的广泛关注,是由于区块链系统具有去中心化、可追溯、不可篡改、不可伪造不可否认和可编程等特点。然而,区块链在安全和隐私方面的挑战仍然制约着区块链的快速发展。</p>
<p>首先,区块链是集信息安全与隐私保护于一体的新型技术,其相应的安全评估检测方法还处于发展过程中,这些技术(包括共识算法、激励机制、智能合约等)在某些关键环境下存在一定的安全隐患,并且已有的安全检测手段还无法完全应用到区块链中。例如,共识协议中的攻击问题:在 Pow 中存在的问题是集中51%算力攻击的问题,即攻击者若获得了整个区块链网络的 51%算力,就有控制整个区块网络的能力,其中也包括篡改和伪造。在比特币应用中,上述提到的 51%的攻击问题带来的后果是攻击者可以实现双重支付(Double Spending),于是提出了 PoS 协议来替换 PoW 协议,上述协议的替换有效避免了某种程度上 51%算力攻击的问题,然而新的问题会随之产生。现有的新的攻击问题有Nothing at Stake,此问题会导致共识节点不计成本地对区块链进行分叉处理，这样会造成区块链网络中不断地产生很多分叉。漏洞检测是安全问题的一个重要方面，从漏洞检测的角度出发，区块链无法提供有效的代码漏洞检测。例如在以太坊中,虽然提供了一些模板和测试环境以方便开发者开发智能合约,但由于智能合约逻辑的复杂性和分布式运行的特性,使得智能合约在代码的编写和密码模块的利用上不可避免地让黑客有可乘之机。同时,网络架构的不一致性使得传统的人侵检测技术无法直接适用到区块链系统中,这也是导致区块链上各种安全问题无法解决的重要缘由之一。其次,量子计算机、人工智能、大数据分析等计算机技术的快速发展同样给区块链带来了安全威胁。尤其是量子计算机的出现会对区块链的安全性造成巨大冲击,量子计算机一旦产生,任意大整数的快速分解从理论上就变得极其容易,破解长度为 1024 位的非对称加密密钥只需要很短的时间,一些传统的计算性理论假设不再成立,例如基于数论的困难假设不再是密码学上的“困难”问题。2019 年 10月 24 日,科技公司巨头谷歌的量子计算机研究团队在 Nature发表论文,此论文正式向世界宣告量子计算机已被成功研发,该计算机可以有效解决当前计算机不能解决的难题,量子计算机只用 3 分 20 秒就可以完成当前第一超算需要计算10 000 年的实验,这也表明基于传统非对称密码学的区块链技术在安全性上面临挑战。</p>
<p>此外,区块链的理论安全与实际应用安全之间还存在一些鸿沟。2014 年,JuanA.Garay、Aggelos Kiayias 和 Nikos Leonardos 3 位教授最先给出了有关比特币区块链的安全形式化分析和证明,列举了比特币有关的两个安全特性:公共前缀和链质量并通过协议分析得出比特币协议实现区块链的 3 个特性(活跃性、一致性和正确性)。虽然从理论上分析区块链的网络安全性比较高,但实际网络环境、用户自身安全意识和黑客主动攻击等方面的问题,仍然给区块链系统的应用带来了不可低估的安全威胁。鉴于区块链采用的网络结构是不同于传统的 P2P 结构,攻击者无法通过控制少部分节点的方式来实现对整个网络控制,但是由于实际网络部署时,各个节点之间配置的安全防护等级不同，导致攻击者可有针对性地从低安全防护等级的节点开始发起攻击,通过控制大多数节点阻碍区块链系统的正常运行。另一方面,用户在使用过程中对密钥的管理不严格,安全意识不足,或被钓鱼网站所诱骗,丢失自己的密钥,也会引发安全问题。以金融领域为例,由于区块链与金融紧密关联,相关的用户或者机构成为黑客的重点攻击目标,而一些传统用户应用层的攻击手段在区块链技术中依然可行,因此就其存在的安全问题,不论是用户自身引发的还是传统攻击手段引起的都不可忽视。</p>
<p>最后,匿名性、去中心化、防篡改性、自治化等特点虽然是区块链的技术标签,但与此同时也给区块链系统的安全监管带来了一系列难题。<br>
(1) 区块链的匿名性使得区块链网络系统中发生的漏洞利用等安全事件以及骗取数字货币等网络犯罪的溯源难度增加。当非授权用户利用区块链技术进行违法犯罪活动或者对系统实施攻击使得系统变得不安全时,系统很难追踪并从系统中剔除恶意用户和攻击者。例如勒索病毒，黑客利用操作系统漏洞将用户的文件进行加密处理,需要用户发送-定量的比特币来获取解密密钥。虽然比特币地址在用户交易的过程中是公开的,但其较高的匿名性使得无法链接到现实中的非法参与者。<br>
(2) 区块链的去中心化特性导致攻击者可以在更多方面进行攻击,使得系统的安全监管的难度增大,基于区块链的分布式存储模式,数据存储在不同的节点而不是集中式的服务器,且用户的通信传输方式为点对点,不需要通过可信的集中服务器或平台，因此用<br>
户交易过程中很难获取监管数据,监管的技术接口也难以实现。(3)区块链的防篡改特性为恶意信息的传播提供庇护,使对数据内容的监管变得异常困难。具体地说,攻击者通过交易的方式向区块链中写人一些非法信息,利用区块链自身的同步机制实现非法信息的迅速传播,由于防篡改特性使这些非法信息难以被删除,加大了互联网监管的难度。<br>
(4)数据安全责任边界不清晰。在实际应用中,节点通常指的是区块链平台、应用系统、数据所有者等实体,区块链中的这些实体互不信任,这会导致在出现安全问题时,难以划清安全责任界限。<br>
总而言之,区块链本身存在诸多呱须解决的安全问题,这些问题随着区块链应用技术的迅速发展变得更加突出。因此,确保区块链的安全性是当前区块链广泛应用面临的最棘手的问题之一。</p>
<h3 id="区块链隐私泄露威胁">区块链隐私泄露威胁</h3>
<p>5.1.1 节主要从与区块链相关的一系列安全问题进行了阐述,与此同时,由于区块链在各个应用领域迅速的扩展延伸,使其在隐私泄露方面的问题也受到广泛关注。区块链技术之所以能够迅速发展并应用到相应的各领域,其优势在于数据的存储和处理不依赖于某个中心节点,从而避免了单点故障和权限滥用的恶意行为,是传统的中心化架构、集中式服务无法比拟的。然而,区块链中的数据需要分布式网络中的各个节点来共同维护从而达到一致性共识,因此交易中的信息需要公开,让所有节点都能进行验证,这就使得区块链(主要指公有链、联盟链)上的公开信息毫无隐私可言。</p>
<ol>
<li><strong>身份信息泄露</strong><br>
公有链没有准人机制,任何节点(包括攻击者节点)都可加人网络中进行数据维护,监听区块链网络节点之间传输的数据。因此,当攻击者想要推测出某个交易者的身份信息时,首先分析获取到的交易数据,其次通过给出的背景知识,将二者结合得到最终的交易参与者的真实身份，上述攻击可以成功的原因在于区块链上交易数据是可以关联的。通过交易的关联性关系,攻击者可以削弱区块链地址的匿名性,甚至暴露用户的真实身份例如,Alice 在某个区块链交易平台上购买了一个比特币,它利用信用卡来进行支付,由于在美国 2000 美元以上的交易都需要实名,因此实名制使得攻击者可以通过交易的地址金额和时间等相关数据从支付地址关联到实际支付人,从而达到获取交易者身份信息的目的。</li>
</ol>
<p>数据挖掘技术为攻击者得到关联的交易地址提供了可能性。具体地,攻击者可以通过分析交易与交易之间的关系,得到某个地址的所有相关交易数据流。由于每笔交易都记录了所有的输人地址和输出地址的信息,通过对特定地址进行检索,就能够发现该地址的全部相关交易,只要任意一个地址对应的用户真实身份信息被暴露,其他所有和该地址有关的地址都可能属于这个用户或相关用户,会致使更多的用户隐私数据泄露。此外,区快链服务提供商也有可能存在某些漏洞被攻击者利用，泄露用户隐私。如 2015 年，比特而论坛 Bitcointalk 就遭受网络攻击,被攻击者窃取了 49.9 万用户数据,包括用户名、密码、电子邮箱等。</p>
<p>数据的公开透明既是区块链技术的优势,也是区块链技术的劣势,它使得敏感信息得不到保护,通过从区块链网络中提取有价值的敏感数据,联合不同网络和平台下的用户数据,即使用户的交易费用通过比特币进行支付,也无法保证其隐私的安全性。具体地，通过利用区块链浏览器,与比特币相关的每笔交易信息都是公开可查询的,包括资金流向(即发送地址、接收地址)、交易金额、交易时间等。虽然用户使用的是匿名地址,无法直接利用交易地址查询到交易者真实的个人信息,但要查询到用户的真实信息还是有迹可循的。根据现有的研究表明,即使通过隐私保护的方法实现身份隐私,但是利用数据挖掘等手段对比特币交易信息统计分析，同时结合一些现实非比特币的交易记录,能够确认出40%的比特币用户的真实信息。因此,简单地通过比特币的地址来实现用户交易的匿名性,这种匿名体制是不完善的,确切地说,是一种伪匿名性。</p>
<ol start="2">
<li><strong>交易数据泄露</strong><br>
大数据分析处理技术不断进步,基于大数据挖掘的分析技术可以将用户的真实身份和资金使用情况识别出来。《纽约时报》曾报道,根据用户的购物习惯、消费记录、出行数据等信息,可以准确地预测个人的隐私信息。例如,数据分析师可以通过用户的消费行为预测出某些女性购物者是否已经怀孕。一些看似无关紧要的数据可能揭示用户的敏感信息,而且一旦恶意用户出于经济利益等考虑去挖掘这类数据并进行非法利用,就很有可能损害其他合法用户的经济财产安全,甚至人身安全。</li>
</ol>
<p>在区块链与其他具体应用相结合的情形中,会涉及大量高度隐私的数据。例如,在金融业务场景中,用户与银行之间的交易记录或者银行之间的相互交易记录都是极其敏感的数据,属于银行的核心数据,因此不论是用户还是银行,都不希望彼此之间的交易记录被其他非授权用户查看。此外,在医疗场景中,多个医院组成的联盟链可以有效促进数据的共享、有利于病情的诊断,但是个人病情同样属于极度隐私的数据,患者并不想将个人的医疗数据公开地放置在区块链环境中。由此可以看出,若想要区块链技术及其应用覆盖到其他的应用场景，隐私泄露应该是最先需要解决的问题。</p>
<p>区块链的多节点共同维护、公开透明等特性是把双刃剑,这项技术在带来安全性的同时,也造成了新的数据隐私性问题。第 4 章中的区块链经典理论一一不可能三角,也即中心化、可扩展性和安全性三者之间的相互制约关系。同样,对于区块链的隐私性(安全性)和性能(可扩展性)之间的权衡也一直是实际应用中需要考虑的问题。为了做到安全的隐私保护,势必会影响系统的可扩展性,如何实现在保护数据隐私的同时依然能够支持不同节点针对数据进行安全、高效地验证是区块链领域中的热点研究方向,如何更进一步地保障区块链的隐私性就成为该领域的重要问题之一。</p>
<p>目前,从两方面考虑，既能保护隐私同时兼顾性能,有一种解决的方法就是提升硬件性能,例如,可以采用具有隐私保护功能的硬件设备 Intel SGX 同时保障效率。SGX 是由英特尔公司开发的,旨在为商用计算机上进行的安全敏感计算提供完整性和机密性的指令集扩展,SGX 的核心技术是封装,即通过提供硬件安全的强制性保障将合法的运行软件封装在 Enclave 中,为软件的执行提供可信的环境,防止恶意者的攻击以及软件的越权访问,但此技术并不能对所有的攻击都能够识别和隔离,只能保证 Enclave 中运行数据的机密性和完整性。</p>
<p>通过密码协议来增强区块链的隐私性保护也是研究的热门方向,包括使用零知识证明、安全多方计算等技术来解决链上交易公开透明的问题。目前针对区块链隐私保护机制的研究按照层级来划分,主要包括网络层、数据层以及应用层 3 方面的隐私保护。</p>
<p>总体而言,区块链利用自身的优势为去中心化的分布式系统提供了强大的技术支撑,但是区块链本身会面临不同的安全问题和隐私威胁。为了满足实际应用的需求,需要识别这些安全问题,同时要引人有效的机制来避免安全问题的产生。</p>
<h3 id="区块链安全目标">区块链安全目标</h3>
<p>虽然区块链被证明了在满足一定的条件之后在理论上是安全的,这包括区块链所使用的密码学技术,但是在实现过程和应用过程中,由于开发者没有充分预估系统的使用环境,使得区块链系统遭受了各种攻击行为。区块链的安全性问题涵盖范围较广,从用户应用端到底层数据端都有安全问题存在。本节以区块链存在的安全问题为切人点,依次介绍区块链应用过程中包含的安全性问题。具体来说,区块链的安全目标是指利用一些现有的密码学技术手段和实施方法来保障区块链系统的应用安全,其中,应用安全主要涉及应用过程中的数据安全、共识安全、智能合约安全、内容安全、密钥安全、跨链交易安全、隐私保护以及具体的密码算法安全的设计和证明等,如图 5.2 所示。在上述的主要标中,首先要实现的是数据安全,数据安全是其他方面各层级安全的基本前提。</p>
<p><img src="/img/blockchain_sec/5_1.png" alt="区块链的主要安全目标"></p>
<h4 id="数据安全">数据安全</h4>
<p>区块链实质上是一种去中心化的分布式存储系统,其保存有大量的与区块链相关的敏感数据,如用户的支付信息、交易过程、智能合约执行代码和具体的中间执行的状态等.如何保护敏感数据的隐私性是实现区块链安全的关键所在。下面基于信息安全方面的保密性、完整性、可用性、可控性和不可否认性 5 个特性定义区块链的数据安全。</p>
<ol>
<li>保密性</li>
</ol>
<p>保密性是指避免合法用户或者实体的敏感数据泄露给非授权的或者恶意的参与者在基于区块链的应用中,为了实现敏感数据的保密性,要求应用系统采用符合要求的、可靠的、具有安全性证明的身份认证算法、访问控制协议和安全审计机制。其中,身份认证算法是用来在计算机及网络环境中判断用户是否合法的一组认证规则,它是访问控制的基础。在传统的身份认证体系中最常用的方法是基于可信第三方的身份认证,主要是通过用户的口令或指纹等预存在平台的信息来确认用户身份。在区块链的身份认证中,每个区块或用户的加入方式和有效的身份鉴别认证方式都是确定的。例如,在公有链(如比特币中),身份认证是通过验证用户是否有合法的私钥(即口令)来验证用户身份的。为了实现身份认证又不破坏匿名性,学者们利用零知识证明方法提供相应的身份认证服务,被称为 ChainAchor 框架，此架构使得合法用户的身份可以有选择地打开,因为每个参与者都拥有多个有效交易身份。访问控制是一种按用户预设的身份来设定用户对某些信息项访问权限的技术。此技术是实现访问控制的一种最基本的方式,它允许授权用户按照权限级别来访问或使用系统的资源,任何非法用户对系统资源的访问都会被禁止。一般来说,通过对数据进行加密来实现访问控制,合法用户只有拥有与加密公钥相对应的解密私钥,才能满足访问权限,解密查看信息。对于公有链,其访问控制是通过私钥来实现的.用户可以任意加人公有链中查看数据、发送交易等操作,但在联盟链和私有链中,它有-套严格的准人机制,用户需要获得其他节点的同意才能有权限操作和访问链上的数据。</p>
<p>审计监管是指区块链能够对非授权的数据泄露事件进行监管,包括事件的监控、分析和追责等。它主要从法律层面保障区块链数据的保密性,确保非授权的数据泄露等不安全行为得到相应的惩罚,从管理角度来控制攻击者的恶意行为。</p>
<ol start="2">
<li>完整性</li>
</ol>
<p>完整性是指数据接收者得到的数据和数据发送者发送的数据是一致的,即在数据传输的过程中没有遭受恶意者的篡改。区块链利用冗余性较大的分布式数据库系统来保障链上数据的不可篡改性。区块链中的完整性主要指用户发布的交易信息、智能合约执行的中间状态不可篡改和不可伪造。在区块链中,任何已经确认的交易记录都不能被修改，已经发生的所有行为不可抵赖,例如,区块链系统中的攻击者若进行双重支付,则此行为无法抵赖。对于底层数据,数据完整性通常是基于相应的密码组件实现的,如数字签名哈希函数等。其中,区块链中最为典型的哈希值体系结构是基于默克尔树的,使其能够维护数据完整性,同时验证数据的有效性。在共识层面上,数据存储的一致性是依靠各类共识机制(如 Pow、PoS 等)实现的。</p>
<ol start="3">
<li>可用性<br>
可用性指合法用户可以对区块链系统中的数据随时地进行访同和使用。区块链系能的可用性首先应该具备抵抗单点放障和分布式容错的能力,使得系统在遭受各类攻击的仍然能够提供可靠的服务。同时,由于区块链网络主要是点对点的分布式结构,所以少分的节点受到攻击或产生放障将不会对整个区块链系统的运行产生较大的影响,系统可以对外提供正常的服务。然而现有的一些攻击行为,例如自私挖矿,通过控制少部分点来获取全网络超过 50%的资源,会影响区块链系统的可用性。此外,可用性还要求统在遭受实际攻击时,能够在一定时间内完成修复和重构,保证系统的正常运行。其次区块链系统的可用性还表现在能够为合法用户提供无差别服务,每个参与的节点都可以获得有效的、正确的数据,即使是新加入系统的节点也可获取相应的服务。</li>
</ol>
<p>在限定时间内响应用户的访问数据请求是可用性非常重要的一方面,在区块链系统中有限时间内响应用户的访问数据请求的主要表现形式为可扩展性。可扩展性在区块销中要求系统具有低延时、高交易吞吐量等特性,考虑到区块链体系结构存在着不可能三问题,为了使实现的系统具有更好的可扩展性,会在安全性、去中心化两个特性中牺牲基部分性能满足实际应用的需求。</p>
<ol start="4">
<li>可控性</li>
</ol>
<p>可控性指系统或数据在传输范围和存储空间的可控程度。对于区块链,可控性主要指区块链的数据在链上存储的可控安全程度。公有链中允许任何节点在任意时间都可加人,支持任意交易数据的发送,但是一定的匿名性使得非法的交易行为难以追踪。例如暗网中有许多的用户利用比特币来进行黑市交易,甚至成为比特币的最大用户,这在一定程度上对区块链系统的可控性造成很大的冲击。因此,构建安全可控的联盟链更加符合数据安全的要求。此外,对于使用区块链技术的合法用户,可控性需要保证在不同个体之间,实现数字资产或数据在链上的安全控制权转移,防止非法用户对这些资产或数据的操作控制。</p>
<ol start="5">
<li>不可否认性<br>
不可否认性通常指用户不能否认自己发送信息的行为以及信息的内容,也称不可抵赖性,在此处是指用户无法否认在区块链系统中的操作行为。在区块链中,用户发送的数据都通过交易的形式被记录下来,一且经过一定周期被确认后将无法修改。由于交易的产生与用户的地址唯一绑定拥有该地址的用户无法否认其在区块链中所做出的操作行为。不可否认性要求在不同参与者之间,用户无法抵赖以自己身份参与所完成的操作,需要与身份认证进行关联,同时系统支持安全审计功能.相关的审计日志需要被准确地记录下来。</li>
</ol>
<h4 id="共识安全">共识安全</h4>
<p>由于区块链网络中的节点包含个人计算机或移动客户端,与传统网络架构中的专用服务器相比,性能低、抗攻击能力差,所以这些节点很容易被攻击者或者恶意用户攻击此外,在中心化架构中,管理者只需针对一台或者少数几台服务器进行重点保护,而在区块链网络,所有节点地位平等,很难对地理位置分散的众多节点采用相同的防护措施,这样攻击者可以选取安全保护较为薄弱的节点进行人侵,破坏区块链网络中数据的同步性。</p>
<p>共识机制用来保证区块链网络中的节点能够对某个提案达成一致,例如所有节点就某个区块可以加人区块链的问题,以此来确保区块链主链上数据的一致性,这是区块链的核心思想。区块链上的共识安全是实现数据安全的基石,起着重要的作用。保证区块链系统的最终共识、激励兼容性、活跃性以及正确性是实现共识机制的核心,也是衡量共识<br>
安全的重要属性。其中，满足最终共识是共识安全中需要保证的最基本特性。</p>
<p>最终共识是不同节点在共同约定的协议的保障下,整个系统对某些操作行为产生的结果的一致认同。在区块链系统中,满足最终共识要求在数据达成共识并存储到区块链后无法被更改。也就是说,所有节点的最终共识只有在主链上达成才能对各类攻击者行之有效,因为只有在主链上形成共识,攻击者就无法通过在分叉链上达成共识、抛弃主链来实施攻击。激励兼容性和活跃性主要是指在区块链网络中,要有足够多的节点持续地参与到区块链系统的维护过程中,这需要共识协议能够提供持续可靠的激励机制吸引节点参与。如果攻击者可以通过某种方式破坏共识协议的激励机制,这就会影响正常用户参与使用或维护区块链的积极性,从而在一定程度上降低区块链的活跃性。正确性要求共识协议能够抵抗双重支付攻击。虽然理论上需要达到 50%以上的算力才能控制区块链网络实现双重支付,但是在实际的网络环境中,攻击者通过使用一些如自私挖矿之类的攻击策略,在一定周期之后,可以将全网的算力往自己设定的这条主链上来运行,使得原始的这条链被废弃,已产生的交易转账信息也随之失效。造成双重支付攻击的策略有很多种,本书将在第 8 章中进一步描述。</p>
<h4 id="智能合约安全">智能合约安全</h4>
<p>智能合约能够支持用户编写任意的代码逻辑,一旦部署之后,区块链网络中的任意节点都需要执行智能合约上的代码,且代码逻辑不可修改。当输人满足一定的条件后,合约就会自动运行程序,即使智能合约的发布者也无法阻碍程序的自动执行。正因如此,若存在漏洞问题无法通过传统补丁的方式去修改,只能重新部署合约,那么漏洞合约上涉及的金额也无法挽回。近年来,智能合约频繁出现漏洞,导致攻击案例层出不穷,给用户和社会带来了巨大的经济损失。</p>
<p>智能合约主要从软件代码层面来考虑其安全性。软件代码层面的安全由开发安全和运行安全两部分组成，同时,开发安全又包含逻辑安全和代码安全。逻辑安全即指开发人员首先应该在编写之前结合实际功能来设计符合逻辑的、简洁的、具有可行性的代码,因为代码出错的风险与复杂性是相关联的;其次,在代码的编写过程中需尽量使用安全且目前较为成熟的开发语言,并且需要确保符合规范,合约和函数可以进行模块化管理,并养成使用安全库的习惯。此外,开发人员要准确地掌握黑客常用的攻击手段,从而在代码的编写过程中尽量避免此类型的攻击,同时了解常见的智能合约漏洞,对编写的合约进行仔细地排查,保证编译后的代码不存在这些漏洞。</p>
<p>运行安全作为一种安全保护机制,它能够随时保持更新,是对智能合约在实际虚拟机平台或系统中运行的安全保护。运行安全的基础是保持更新,即当有新的漏洞被发现时，要及时检查部署智能合约是否受到影响。当用到的库或者工具有更新时,智能合约也要及时更新,并使用最新的安全技术。若智能合约的漏洞问题、甚至被攻击者攻击出现在执行过程中,运行安全的要求是不会对本地参与区块链的系统或设备造成影响,这就需要做到隔离运行,即智能合约并不运行在本地系统上,而是运行在系统的隔离环境中,如系统虚拟机等,这样在很大程度上避免了本地支持智能合约运行的系统遭受恶意者的攻击例如,以太坊为了实现代码在隔离环境中运行,专门提供了虚拟机供合约代码运行。同时运行安全也要求即使智能合约调用了有漏洞的合约,也不会执行异常。为了实现这个目标,需要确保智能合约在开发中尽量保证模块化,即合约逻辑简单化、代码函数模块化,且需要降低模块之间的依赖性,高耦合低内聚。使得智能合约能够通过接口的方式进行安全调用,并且达到阻止异常结果通过合约调用技术方式扩散到整个区块链的目的,在一定程度上有效地确保了智能合约的安全性和可用性。良好的模块化能够降低智能合约的复杂性,使得智能合约的设计、调试和维护简单化。</p>
<h4 id="内容安全">内容安全</h4>
<p>内容安全是对数据内容本身的规范性要求，它建立在数据安全的基础之上,主要描述的是存储在区块链分布式系统中的数据要达到法律法规的要求和符合用户道德规范的标准，阻止和避免不合要求的内容在网络中传播。那么要如何解决有关内容安全的问题呢主要的解决方式是有效控制不良信息在区块链上的传播和加强对信息的管理,探索对销上违法信息审核与用户隐私保护需求间的平衡，明确区块链开发者、区块链平台运行者<br>
区块链使用者等不同角色的安全责任。</p>
<p>针对区块链内容的攻击的主要形式包括恶意信息攻击和资源滥用攻击。其中,恶意信息攻击是影响区块链内容安全的主要攻击形式,它指的是攻击者刻意向区块链中写入恐怖信息、虚假信息等。这些恶意信息利用区块链数据传播速度快、达成共识后不可修改等特性,可以很快传播到全世界,造成极大的危害。区块链中的恶意信息使得区块链会被杀毒软件结束正常运行,或者引起政治敏感等问题。资源滥用攻击指的是节点之间恶频繁交互使得区块的数据量大幅度不可控制地增长,导致普通节点由于存储不足无法容纳区块数据。这就致使可以维护区块链稳定运行以及达成主链数据共识的可靠节点逐减少,从而区块链掌握在少数有计算资源、存储资源的大公司手中,从资源的存储和掌情况可以看出这与区块链的去中心化的特性不相符合。以以太坊的资源滥用攻击为例2017年 2月,攻击者利用大数量级别的垃圾交易信息来攻击以太坊 Ropsten 的测试链通过阻塞网络信道的方式导致区块链系统无法正常工作。</p>
<p>因此,内容安全可控是将区块链系统应用于各个场景的关键。内容安全也影响着政府和社会对区块链技术的接受度。在公有链中,数据一旦被用户匿名地记录就无法再对数据做出修改和追溯。因此探索基于联盟链架构的区块链应用场景对于规范内容安全重有意义,可以有计划地实施信息过滤、网络监测等技术手段为区块链的内容安全提供保魔。例如,已有研究机构(阿里巴巴)申请了与区块链内容保护相关的专利技术,该专利表明政府等机构需要以第三方管理员的身份加人系统并获取区块链中的交易数据。与此同时,该系统具有与其他区块链系统不同的特殊功能,可以向区块链发布特殊处理指令,目系统中的其他节点对于特殊指令的做法是先确认其合法,确认后才能公布到整个区块链网络,此过程是对预先设定的监管执行的智能合约的调用。</p>
<h4 id="密钥安全">密钥安全</h4>
<p>在区块链系统中,若代表着用户身份和数字资产的私钥被泄露则意味着用户丧失了对自身拥有的数字资产的支配权和控制权。因此,私钥安全为密码系统安全运行奠定了基础,也为区块链系统正常运行提供了保障。如图 5.3 所示,私钥安全指的是私钥整个生命周期的安全,主要包括私钥的随机生成,安全存储、使用,以及撤销、更新等阶段。区块链中的私钥一般由非对称算法产生,例如比特币采用基于圆曲线算法的非对称算法。非对称算法密钥主要是由随机数生成器产生的，通常使用满足随机预言机(RandomOracle,RO)模型的种子来作为随机数生成的基础。私钥的存储常常通过软件或硬件的方式来实现。软件的方式包括以文件或字符串的方式存储在服务器环境中,硬件方式一般利用现有的芯片设备或安全装置作为存储密码的工具和载体。这两种方式都存在被黑客窃取或暴力破解的风险。</p>
<p><img src="/img/blockchain_sec/5_2.png" alt="区块链的主要安全目标"></p>
<p>在私钥使用过程中,由于使用者可能遭受钓鱼、缓存侧信道等攻击,私钥将直接暴露给攻击者,这样会导致使用者失去对账户的唯一控制权。在基于中心化架构的传统应用系统中,若用户私钥丢失还可以向管理员提出申请并重新找回丢失的私钥。但在分布式的区块链中,没有管理员的角色来对参与交易的用户进行统一的私钥管理,所以用户自己就是自身私钥的管理者,而由于普通用户的安全意识不足,丢失私钥的情况就时有发生这是因为区块链系统一般存在钱包客户端(有网页版或独立客户端版),采用传统方法对用户发起的攻击形式,在区块链应用中依然存在,用户一不小心就极容易中招。因此,如可保护用户私钥的使用安全是区块链系统在设计过程中需要重点考虑的因素。</p>
<p>为了保证高可用性,区块链系统需要支持私钥的动态操作,如撤销和更新等,然而现有的比特币等公有链并不支持私钥的更新和撒销操作,只能通过重新申请的方式将数资产转移到另二个私钥所对应的公钥中。在实际的区块链集成应用场景中,需要考虑户由于意外而丢失私钥的情况,可以通过线下实名的方式找回，这类似于银行密码丢失用户通过户口或身份证来认证身份,重新设置密码。</p>
<h4 id="跨链交易安全">跨链交易安全</h4>
<p>1.6.1 节中的侧链技术是实现跨链交易的一种方式目前还存在包括公证人机制、中继、哈希锁定技术、分布式私钥控制技术等方式来构造的跨链交易方案。跨链技术出现的主要目的是实现了区块链系统中不同区块链之间的互通。大量的区块链应用平台随着区块链技术的推广应运而生,为了防止信息孤岛情形的出现,造成链与链之间的数据无法百通,实现不同链条之间的信息交互就显得十分必要。每个区块链网络都是相对封闭的独立系统,节点内部都会互不信任,因此要解决不同链之间的互信问题就非常困难。一般司以通过解决两条链之间的双向错定问题来实现链与链之间的交易，假设在 A 链上生成 p链上的铺定币,那么需要同时将 B 链上等价的数字货币进行锁定，类似于 B 链上的数字货币跳转到 A 链上进行使用。在实际操作过程中，需要解决两条链之间应用程序互操作性以及数据的无缝更新性问题,保证两条链的实时、准确交互。如果是通过设计一种中间链来对接两条链的方式,例如 FUSION 公有链分布式控制权服务(Distributed ControRights Service),利用锁人和解锁技术实现代币分布式控制权管理获得和解除，这一技术能够确保操作的准确性,防止两边同时都具有或都不具有对代币的控制权，保证跨链操作的原子性。</p>
<h4 id="隐私保护">隐私保护</h4>
<p>区块链系统中的信息在交易过程中为了实现各个节点间数据的同步和交易的共识是需要对外公开的,例如交易金额或中间状态。除此之外,攻击者可以通过用户交易之间的关联性对用户隐私信息进行推断。并且区块链系统中利用全局公开的账本存储所有用户的所有交易,因为存储账本是全局公开性的,使得攻击者可以很容易地获得交易的所有数据。通过分析交易中的关联关系,攻击者能够逐步降低区块链地址的匿名性,甚至能够发现匿名地址所关联的用户真实身份信息。因此,系统通过处理用户敏感数据减少隐私泄露的方式来保护用户的隐私。区块链中的关于数据隐私保护问题主要包含身份隐私保护和交易数据隐私保护。</p>
<p>(1) 身份隐私(Identity Privacy)保护。身份隐私是指参与交易的用户的真实身份和交易记录之间的链接关系是保密的且无法关联的。实现匿名性保护是电子现金中身份隐私的核心问题。中本聪描述了理想电子现金的 6 个标准,其中就包括隐私保护,指的是用户与其交易之间的关系必须是任何人都无法追踪的。具体地,完全匿名的数字货币模型必须满足以下两个属性。<br>
①不可追踪性(Untraceability): 对每笔交易的输人,都无法推测出是否由同一个人发起。<br>
②无关联性(Unlinkability): 对于区块链中任意的两笔交易输出,都无法链接到一个交易用户。<br>
(2)交易数据隐私(Transaction Data Privacy)保护。在区块链中,除了区块头之外其余的数据属于交易信息,它包括参与者的地址信息、交易金额、交易时间等。此外,对于以太坊这种支持图灵完备智能合约的区块链系统,如果构建一套去中心化的 DApp,交易还可以用来保存用户其他的信息，例如中间状态变量、交易总量等信息。交易数据隐私就是指这些交易中所包含的敏感记录。一般写人交易中的数据是否需要进行隐私保护是以用户的需求和场景而定的。</p>
<h4 id="密码算法安全">密码算法安全</h4>
<p>随着量子计算机的迅速发展,这给传统密码算法协议的安全性带来了严峻威胁。研究抗量子计算安全的密码算法已经成为密码学领域的一个重要课题。同样地,由密码学底层构建的区块链技术也会受到巨大的冲击。目前,量子计算机的研发在全球各地科研工作者的努力下正逐渐成为可能。2015 年,对量子计算机有很深造诣的 IBM 研究机构研发了一台能够进行量子计算云服务的量子计算机,并免费对外开放使用权,尽管此台计算机仅仅含有 5 个量子位。2018 年和 2019 年,谷歌和IBM 公司在美国物理学年会和国际消费电子展上先后推出了量子计算模型和量子计算芯片。另外,D-Wave 公司不甘落后,也积极推出量子计算机。因此,研究抗量子计算攻击的区块链技术迫在眉睫。</p>
<h3 id="区块链层级分类安全">区块链层级分类安全</h3>
<p>在 5.2 节的介绍中,主要介绍了与区块链相关的数据、共识等的安全目标。各个目标也说明了区块链在当前阶段中还存在着诸多的安全威胁,黑客的攻击手段层出不穷,如果在使用或者开发过程中不重点防范,则会出现相应的安全问题。此外,数字货币基于区块链技术去中心化的优势使得跨境交易的流程变得简单且交易效率提高,但各个国家对加密数字货币所持有的态度相差较大,缺乏国际上统一的规范，这也让监管区块链系统变得更加困难。因此,掌握已有的或可能有的安全问题对进一步开发和使用区块链技术非常重要。</p>
<p>如图 5.4 所示,可以将区块链系统分为应用层、智能合约层、共识层、网络层以及数据层。本节从五层结构出发,简要分析和列举每层可能遇到的安全风险。</p>
<p><img src="/img/blockchain_sec/5_3.png" alt="区块链层级结构"></p>
<p>(1)应用层主要功能是为了用户之间进行交互,实现分布式账本状态更新。应用层<br>
主要指各种区块链的交易平台、钱包客户端、Web 应用端等,主要关注私钥管理以及应用客户端等存在的安全问题。</p>
<p>(2)智能合约层是区块链系统的基础也是关键。关键在于它是用户用来实现去中心<br>
化DApp 的主要模块,它封装了与应用需求相对应的逻辑算法和实现代码。基础在于它是编写区块链系统的主要组成部分,从非图灵完备的脚本代码(如比特币)发展到图灵完备的智能合约(如以太坊),但由于在开发过程或合约运行过程中的安全问题,导致在智能<br>
合约层中存在的安全威胁相对较多。</p>
<p>(3)共识层主要包括各类共识算法和激励机制,包括 PoW、PoS 和 PBFT 等共识算法。在实际网络的部署和共识算法的安全假设中存在一定的鸿沟，会导致节点之间最<br>
共识的不一致性。</p>
<p>(4)网络层主要由两个机制和一个网络组成,包括传播机制、通信机制和分布式网络等技术。对于网络层来说,它涉及的安全问题属于传统安全问题范畴,例如分布式拒绝服务(DDoS)攻击、日蚀攻击(Eclipse Attack)等。此外，网络层还关注隐藏网络节点的数据接口,有一种攻击方式是利用网络节点不该暴露的接口挖掘节点和用户信息,从而实现数字货币非法转移的目的,造成用户经济损失。</p>
<p>(5)数据层主要涉及底层的区块、交易等数据的存储和管理。一般来说,数据层安全性是由密码学理论所支撑的,常用的密码学算法包括数字签名、哈希函数和零知识证明等。密码学算法经过许多年的研究和发展,技术水平已经较为成熟。但是,在一些具体的区块链项目,由于对底层技术不熟悉或者本身区块链平台的不完善,会造成项目中存在一些安全隐患。数据层作为区块链的底层基础构建,一旦出现漏洞等应用问题,就会给上层的应用带来严重危害。</p>
<ol>
<li>应用层<br>
在应用层中,用户会与该层的各种应用程序进行直接交互,无须考虑底层的技术实现。一般来说,应用层与区块链具体的应用有着密切的关系,目前区块链技术的应用场呈现出越来越广泛的趋势,典型的包括数字金融业务、数据版权保护应用、供应链管理等数字金融类场景是区块链技术的早期应用方式,除了比特币以外。目前已经出现大量的争币，例如以太币、零币、门罗币等。用户可以通过各种各样的数字货币客户端实施交易内买一些商品或者服务。这些数字金融类的应用都有各自对应的客户端,例如比特而专门的比特币钱包,而以太坊也有专门的以太坊钱包。</li>
</ol>
<p>区块链系统应用前景极为丰富，这也让区块链系统本身面临前所未有的挑战。应用层通常与区块链系统直接交互,因此它面临的安全挑战主要由以下3方面引起。</p>
<p>(1)传统攻击威胁:传统针对 We 网页或动客户端的攻击方式在区块应用层中也适用,恶意攻击者常常可以利用一些传统的攻击手段对区块链系统实施攻击,例如钓佳网站、App 伪造漏洞直接盗取用户的个人私钥。所以,防御传统攻击是区块链应用层安全中需要解决的首要问题。</p>
<p>(2)第三方服务漏洞:区块链系统还依赖区块链服务提供商和第三方中介机构。例如,用户为了管理自己的密钥,可能使用比特币钱包供应商提供的密钥管理服务，这样攻击者就可以利用后门攻击等方式窃取用户的密钥。</p>
<p>(3)客户端开发漏洞:在应用客户端开发过程中,代码漏洞是一个难以完全杜绝的问题,特别是利用第三方进行开发,很可能产生越权漏洞或遭受供应链攻击等威胁。</p>
<ol start="2">
<li>智能合约层<br>
智能合约给用户带来了可编程的区块链应用能力,用户可以无须关心如何设计区块链底层协议(如共识协议、交易模式等),只要具备一定的计算机基础都可以创建智能合约来构建去中心化应用，也可以通过调用智能合约接口的方式来使用去中心化服务。然而,智能合约技术给人们带来许多技术上的优势,但是使用该技术也不得不去应对诸多的安全挑战。主要原因在于,智能合约这一概念由来已久,但真正开始在区块链中使用的时间却不长,由于对其底层的运行机制和原理了解不深,对开发者和普通使用者还是极容易出现安全问题。据腾讯安全团队统计,2018 年上半年,仅仅由于智能合约漏洞而造成的直接经济损失就超过数十亿美元,智能合约技术当前面临的主要问题包括以下 3 点。</li>
</ol>
<p>(1)代码开发漏洞:大部分的智能合约安全漏洞是由于创建者在编写智能合约代码时无意识地埋下了安全隐患。区块链中的智能合约,如以太坊,默认采用的编程语言是Solidity。由于合约代码和传统的 Java/C++ 等代码运行模式不同,导致出现了一套新的编程需求和规范，然而很多的开发者在还没有完全掌握该语言的情况下就发布了智能合约代码,导致被攻击者利用,造成使用者的经济损失。例如,有学者发现以太坊上有上百万个智能合约不符合 ERC-20 标准的代币(Token)合约,存在潜在的安全威胁。此外,也存在部分合约漏洞是创建者有意识地在合约中设置陷阱的情况,其利用使用者对合约的不熟悉来获取某种经济利益。目前,代码开发过程中产生的漏洞形式包括可重人攻击、交易依赖攻击、时间戳依赖攻击等。</p>
<p>(2)验证机制不完善:智能合约目前还缺少有效的形式化验证机制来保证合约的运行安全。一般而言,一种语言的发展会伴随着各种的组件和工具的产生,主要是为了提供便捷的调用和安全性检查。区块链中的智能合约由于发展时间还不是很长,相应的生态<br>
还未完善,这也是导致智能合约出现安全漏洞的原因之一。</p>
<p>(3)外部调用漏洞:创建者会依赖一些可信实体,通过提供对外数据接口来实现智合约与外部系统的连接。预言机是区块链智能合约与外部 Web API 对接的实体,但是由于中心化的原因,其自身的可信度也存在疑问,而且容易遭受外部黑客攻击或发生自身单点故障的问题。</p>
<ol start="3">
<li>共识层<br>
共识层能够保证区块链的正常运行,是区块链的核心所在。共识层安全主要依据共识机制来确保区块链节点在复杂的网络通信模式中共享同一份有效的区块链视图，即它能够为全网对区块链数据的一致性提供保障。不同的共识协议或多或少都存在这样或那样的安全问题,现有的破坏共识层安全的攻击方式多种多样,如自私挖矿攻击、女巫攻击等，主要的原因包括以下 3 点。</li>
</ol>
<p>(1) 缺乏形式化安全证明:共识机制的安全性依赖于网络实际运行环境,包括时序性、节点数量、资源(算力或权益)分布等因素。传统的安全性分析方法不能全部应用于区块链场景，造成共识机制缺乏有效的安全性证明。</p>
<p>(2)安全性假设较强:与传统密码方案将安全性归结为计算困难问题不同,共识机制的安全性是基于假设节点的诚实比例,对于不同的区块链网络,由于加人节点的数量能力等不同,诚实比例的数量很容易发生动态性调整,造成共识协议的安全假设不成立。</p>
<p>(3)扩展性较差:可扩展性是区块链不可能三角重要的一方面,为了保证去中心化的特性,往往以牺牲区块链的可扩展性为代价,比特币就是最典型的例子,它要耗费 10 分钟才会生成一个新的区块,确认一批交易。如何改善区块链自身存在的可扩展性差的问题，同时保证一定的去中心化安全特性是目前区块链共识层重点考虑的方面。</p>
<ol start="4">
<li>网络层<br>
区块链系统网络层可以确保各个区块链节点之间通过点对点网络进行有效的数据传输。区块链网络采用 P2P技术进行节点与节点之间的通信,具备去中心化、动态变化等特性。在公有链中,网络中的节点由关系平等的服务器构成,散布于不同物理位置的任何节点可以在任何时刻自由地选择加入或者退出区块链节点网络。典型地，如比特币网络就是建立在互联网基础之上,来自全球各地的任何节点可选择在任意时候退出。截至2019 年6月,比特币网络的节点数量已经超过 5000 个,总体节点数量大约为10万个。</li>
</ol>
<p>网络层中的安全问题主要是 P2P 分布式网络安全和隐私保护。在 P2P 分布式网络安全中,与传统的客户-服务器架构模式相比,P2P 分布式网络无法使用防火墙来实现内外网隔离或使用人侵检测技术来有针对性地进行防御,而且 P2P 中的节点由于安全等级和防护能力不统一,更容易遭受安全攻击。另一方面,根据分布式点对点网络的拓扑结构,可以依据网络通信的路由信息有针对性地发起攻击行为,例如,日蚀攻击就是这种攻击方式的典型代表,通过破坏目标节点与主网节点数据视图的一致性为其他攻击行为提供铺垫。</p>
<p>在网络层安全中，隐私安全问题表现得更为明显,尽管对区块链中传输的数据进行了加密处理,攻击者无法查看到明文信息,但是通信的路由信息显示了节点之间的源地址和目的地址,攻击者可以通过监听不同交易发起者的 IP 信息来推测出用户的隐私信息。</p>
<ol start="5">
<li>数据层<br>
数据层是在网络层基础之上,提供区块链数据的管理功能。一般来说,可以从 3 个层而理解数据库系统的可信度:存储可信度、处理可信度和外部访问可信度,如图 5.5所示。</li>
</ol>
<p>(1)存储可信度:指当区块链上的数据结果被确认保存后会避免数据丢失或数据被篡改的情况。存储可信度要求系统能够提供传统数据库管理系统和事务处理中所要求的事务持久性,同时也要求数据库系统在出现存储错误、通信故障或遭受蓄意攻击时,仍可以保证数据存储的正确性。</p>
<p>(2)处理可信度:指数据处理(计算)的正确性,也指数据处理过程和输出结果可审计与可溯源。即使通过共识算法来保证对于主链的共识,分布式的区块链网络架构也会由于网络延时、外部攻击等问题造成各节点在同一时间点上所看到的数据视图的不-致。因此,如何在保证数据处理正确性的前提下平衡性能是处理可信度重要的考量指标。同时,多节点验证机制和链式的数据记录方式天然支持了数据的可审计性和可溯源性。</p>
<p>(3)外部访问可信度:指数据库的访问控制机制,允许具备访问权限的用户来操作和查看数据库,阻止非法用户查看和使用数据库中的数据。外部访问可信度依据不同的应用场景(如公有链、联盟链),有不同的访问控制机制。</p>
<p>一般来说,对区块链数据层的恶意攻击包括以上 3 方面。区块链上的数据主要保存在各个区块上,区块与区块之间以链式数据结构的方式链接。区块链上的数据所面临威胁主要有资源滥用和恶意信息攻击。</p>
<p>此外,数据层中非常重要的一个方面是数据的隐私保护问题。区块链中的交易记录在往是公开可查询的,没有使用任何额外的数据保护技术对其进行保护。区块链交易记梁或多或少地包含一些敏感数据,有可能泄露用户的隐私。</p>
<h2 id="第6章-应用层安全">第6章 应用层安全</h2>
<h3 id="密钥管理安全">密钥管理安全</h3>
<p>区块链中的私钥是用户进行数字货币花费的唯一凭证,它是这样的一个随机字符串，5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SClj299sBCnWjss,这串随机数直接关系着数字加密货币等资产使用的安全性。由于区块链中数字加密货币具有匿名性，攻击者只要拥有私钥就会成为对应数字加密货币的拥有者,可以随意地对数字加密货币进行转移和使用。私钥是作为保障区块链用户账户安全的重要屏障，一旦用户的私钥发生泄露将会导致巨大的经济损失。目前,由私钥的泄露造成的经济损失已达数百万美元。攻击者盗取私钥采取的攻击方式各不相同,其中较为经典的攻击方式包括字典攻击、撞库攻击、键盘记录攻击、缓存侧信道攻击、货币木马攻击。</p>
<h4 id="字典攻击">字典攻击</h4>
<p>字典攻击是指攻击者通过逐一尝试用户自定义词典中的可能密码而发起的攻击。对于比特币区块链,用户的地址并非公钥,在知道地址的交易中,如果想要获得该比特币需要经过以下 3 个过程。</p>
<p>(1) 通过词典查找的方式,随机生成一个私钥。<br>
(2) 通过该私钥计算出对应的公钥。<br>
(3)通过公钥计算出对应的地址,并确认该地址是否与比特币地址一致,如果不一致则重新回到第(1)步进行计算。</p>
<p>理论上,攻击者通过上述过程来完成对私钥的字典攻击的成功率是非常低的,尤其是需要运行至少 3 次的 SHA-256 哈希算法。但实际上,由于一些区块链系统在设计过程中使用了不准确的助记词帮助生成私钥,导致攻击者很容易就通过弱的助记词生成用户的私钥。例如,rabbit 的 SHA-256 哈希值很容易计算:<br>
d37d96b42ad43384915e4513505c30c0b1c4e7c765b5577eda25b5dbd7f26d89</p>
<p>如果攻击者建立一个数据量庞大的字典表,只要看到 rabbit 的哈希值就可以将其转换为初始文本,进而破解出用户私钥。在 2018 年曾发生相关的安全事故，旨在为商业级用户提供分布式应用的高性能、可扩展区块链平台的 EOS(Enterprise OperatiorSystem)区块链系统,被发现其账户存在字典攻击的潜在风险,主要原因是用户对 EOS密钥生成工具使用不当。该工具支持用户通过自己选择的种子来生成 EOS 密钥对，然而用户使用了较为简单的字符串作为种子,导致攻击者可以通过自动攻击的方式生成用户的密钥。<br>
如图 6.2 所示,用户为了方便记忆,通常会采用一些强度较弱的字符串作为生成密钥的种子。攻击者利用用户的这种行为习惯,通过统计分析建立字典表,有针对性地对某些字符串进行遍历查找,直到找到(击中)某个密钥对应的公开 EOS 账户,进而导致账户数字资产被盗。</p>
<p><img src="/img/blockchain_sec/6_1.png" alt=""></p>
<h3 id="撞库攻击">撞库攻击</h3>
<p>在互联网应用中,很多用户安全意识不足或为了方便记忆,对不同的系统都设置了通用的账户名和密码,攻击者通过盗取其中一个网站系统的使用密码,来尝试获取用户在其他网站系统的登录账号,这种攻击称为撞库攻击。在区块链中,这种潜在漏洞可以被攻击者积极利用,通过窃取用户在其他网站系统的登录账号密码来推测出用户的区块链账号私钥。</p>
<p>在 6.2.1 节的 EOS 例子中,用户可以使用简单的助记符生成私,其他的区块链平台由于密码设置相对复杂,需要加上一些特殊符号。但是,很多用户在设置其他平台的账号时为了方便记忆,使用和 EOS 一样的字符串,再添加特殊符号,例如 rabbit@123。这样攻击者可以发起字典攻击盗取到用户的账号,再利用盗取的 EOS 密钥加上一些特殊字符,通过尝试登录其他区块链系统是否成功判断私钥是否正确,这就是一种典型的撞库攻击行为。例如,2018 年 9月,OKEx 数字加密货币交易所就被披露遭受撞库攻击,导致了用户账户被盗事件。</p>
<h3 id="键盘记录攻击">键盘记录攻击</h3>
<p>键盘记录攻击是指通过一些软件程序或者硬件设备将用户所有的按键数据进行捕获的攻击方式。通常键盘记录被作为一种应用工具,然而这种工具可以被攻击者利用,发起键盘记录攻击,即攻击者通过在用户移动设备或者计算机安装恶意软件,对这些软件中用户键盘的操作进行记录。一旦用户在手机或移动端进行键盘输人,植人的恶意软件就会把所有用户输人的记录打包成 PDF 等文件发送给攻击者。攻击者只需要通过简单地分析,就能还原出用户的账号密码等敏感信息。因此,利用键盘记录来发起的攻击是最容易<br>
一般主要有两种形式的键盘记录器:硬件键盘记录器和软件键盘记录器。硬件键盘获取密码的方法之一。记录器通常使用 USB或物理设备连接计算机或键盘的芯片来实现，这种是很容易被察常的攻击方式。对于软件键盘记录器,由于其隐蔽性较高,这种恶意软件的安装往往是不容易察觉的,目前的检测手段也很难完整地识别出这类软件,一般的传播方式有以下两种。</p>
<p>(1)通过网络钓鱼攻击的方式,恶意攻击者通常伪装成知名机构或个人,并将恶意软件包裹在电子邮件中进行群发送,形式可以为可执行文件(.exe)、文本文件(.txt、.pdf)等<br>
用户一旦单击,就会被安装该恶意软件。<br>
(2)通过零日漏洞来主动进行扫描入侵。零日漏洞是指还没有发布正式补丁的安全漏洞,在用户未完成补丁更新之前,攻击者通过利用这种漏洞来发起攻击行为，也称零日攻击。</p>
<h3 id="缓存侧信道攻击">缓存侧信道攻击</h3>
<p>攻击者主要利用 ECDSA(圆曲线签名算法)方案中的取模运算和签名运算的代码漏洞来发起攻击,核心算法为<br>
$s=(k-1)(m+rx)(mod\ q)$</p>
<p>对于ECDSA 缓存侧信道攻击,主要实现流程伪代码如下:</p>
<p><img src="/img/blockchain_sec/6_2.png" alt=""></p>
<p>在代码的执行过程中如果出现参数 $a$ 为$[0~q-1]$时,取模运算就会终止，此时攻击者可以通过检测 DivRem 是否被调用得出参数 a 的相关信息。此外,还存在另一种常用的攻击方式:攻击者首先找到云服务供应商提供给受害站点的物理处理器,通过启动TSL 连接来触发进行 $ECDSA$ 签名;其次利用虚拟机(VM)侧通道窃听信息,利用窃听到的信息恢复出可以进行敏感操作的用户私钥;最后利用私钥来监听用户和站点之间的对话,从而盗取隐私信息。这种攻击常发生在处理器体系架构的运行状态、功耗或者电磁辐射发生变化时,这些变化会成为攻击的主要攻击源。</p>
<h3 id="货币木马攻击">货币木马攻击</h3>
<p>货币木马病毒通常指攻击者设计的一段恶意代码或者恶意软件,这些代码伪装成合法代码或者软件来控制用户终端设备的客户端。货币木马病毒是木马攻击的一种,主要目的在于窃取受害者钱包中的数字加密货币。</p>
<p>攻击者利用木马病毒来窃取数字加密货币的攻击方式原理如下:首先,攻击者通过某种方式(例如恶意邮件、钓鱼网站等),在受害者计算机或者移动设备端安装特定的木马病毒,这种特殊的木马病毒能够截取用户发起的数字加密货币交易,通过实时扫描受害者终端设备中剪贴板中的内容,查看是否出现了数字加密货币的交易地址,如比特币交易地址等。如果检测到有数字加密货币地址,在用户将交易地址复制到钱包时,攻击者会利用木马病毒将恶意地址复制到剪贴板中替换原来的合法地址,即将用户原本要发送的地址修改为攻击者预先设置好的地址。此时,如果用户没有进行地址检查,货币就会被转移到攻击者账户下。这种攻击能够很容易实现的原因是使用剪贴板不需要用户额外授权，旦遭受这种针对剪贴板的劫持木马,剪贴板上原有的内容很容易被替换和盗取。下面针对个人计算机和移动终端分别简述货币木马攻击的原理。</p>
<h4 id="针对个人计算机的货币木马攻击">针对个人计算机的货币木马攻击</h4>
<p>个人计算机上的剪贴板是 Windows 系统中预留的一段连续的、存放信息大小可变的内存空间。它是一块全局的共享内存,主要用于暂时记录来自不同进程之间需要进行交换的数据。货币木马病毒感染个人计算机后会持续不断地扫描剪贴板中存储的数据,判断其是否为电子钱包地址,一旦判断为钱包地址就将其替换成剪贴板内存里攻击者预先设置好的接收地址。</p>
<h4 id="针对移动终端的货币木马攻击">针对移动终端的货币木马攻击</h4>
<p>移动终端的安卓操作系统中同样存在剪贴板，可以被用来在内存中暂存数据,任何应用程序都可以访问剪贴板中的内容。图 6.3 是安卓操作系统剪贴板的工作流程。当进行到将 Clip 对象放入剪贴板这一步骤时,木马病毒会自动检查剪贴板的内容是否为电子钱包地址,如果是则替换成攻击者设置好的钱包地址,从而窃取用户数字加密货币。</p>
<p><img src="/img/blockchain_sec/6_3.png" alt=""></p>
<p>从原理上来说,针对个人计算机或者移动终端的货币木马攻击流程是一样的,都是通过嵌人木马病毒、实时扫描剪贴板中的内容盗取用户数字资产。</p>
<h3 id="客户端安全">客户端安全</h3>
<p>不同的区块链系统都有着各自的交易客户端,主要用来提供数字加密货币的在线交易功能,支持交易数据的发出,主流的是 Web 网站和轻量客户端形式。一般交易客户端又称钱包,主要分为两类:热钱包和冷钱包。其中,前者指的是与网络直接相连的在线式钱包,而后者的主要特点是私钥不与网络接触,相比热钱包冷钱包安全性更高。目前,主要被用来进行数字加密货币交易的客户端包括比特币 Bitcoin Core 钱包、以太坊钱Mist 及莱特币 Litecoin Core 钱包等,这些钱包客户端的安全直接与数字加密货币交易用户的账户安全息息相关,一旦客户端出现安全漏洞,将会出现严重的安全事故甚至给用户带来巨大的经济损失。例如,知名的数字加密货币莱特币,其钱包客户端曾出现严重的安全事故导致用户货币被攻击者盗取,攻击者恶意篡改客户端的公开代码、加人恶意的代码、将攻击者的恶意账号注人客户端中,一旦用户使用钱包接收转账时资金就会自动地转到攻击者的账户下。</p>
<p>如表 6.1 所示,存在大量的区块链事件是由客户端安全所造成的。破坏区块链客户端的正常运行的方式各不相同,其中包括 5种:API关键密钥窃取App 造漏洞、钓鱼攻击、恶意挖矿攻击和 Web 注入攻击。</p>
<h4 id="API关键密钥窃取">API关键密钥窃取</h4>
<p>为了迎合开发者和用户的需求,主流的数字加密货币平台(如以太坊以及比特币等)会提供相关的应用程序接口(Application Programming Interface,API),用户可以利用这些用户接口完成区块链相关交易信息的查询。其中部分需要特定密钥的 API会涉及取消和确认交易等敏感操作,因此攻击者可以利用这些 API 窃取用户的关键密钥来盗取和转移用户的资产从而导致用户的财产损失。如表 6.1 中所述,而安交易所人侵被盗事件的发生就是因为大量的密钥被盗取。2018 年7月4日,币交易所遭受 API关键密钥窃取攻击，导致多个 Token 被盗,其中被盗的 Token 以约等于 100 个比特币的价格被卖出，最终导致该 Token 的价格暴涨数百万倍。为了进一步说明 API攻击如何影响数字加密货币的价格变化,下面对数字加密货币中的 API的工作原理进行简单的说明。</p>
<p>用户利用数字加密货币提供的 API与不同的交易所进行交互，因此当 API被恶意控制后,黑客可以通过 API 窃取用户私钥并进行一系列恶意操作。在用户启用交易所提供的API进行访问时,需要先生成一组密钥，这组密会作为用于提供用户交互过程所需权限的凭证。目前,在数字加密货币系统中存在 3 类不同等级的 API权限。</p>
<p>(1) 只读权限:可以读取指定用户相关账户信息、交易记录以及市场中相关的交易活动数据。<br>
(2) 交易权限:可以利用该权限为授权的用户账户执行相应的交易。<br>
(3) 提款权限:可以利用该权限为授权用户从各个数字加密货币交易所中提取<br>
存款。</p>
<p>通常情况下,一般用户默认开启前两个权限,即只读权限与交易权限,当用户需要提款时需要开启提款权限。因为提款权限涉及的风险更高,安全级别设置较高的数字加密货币会要求用户为其预先设置 IP 白名单和双重认证。在这种情况下即使用户的身份信息或者密码等被攻击者盗取,提款权限也不会被轻易获取。在这种限制条件下,攻击者取得相应的用户信息之后一般会将存款提取到有提款权限的账户中后再进行提取。当攻击者通过 API拿到用户信息之后的一般做法如下。</p>
<p>(1) 攻击者会先选定一种交易量和交易订单较少的数字加密作为攻击对象,通过累积足够多的某类数字加密货币为攻击做准备。<br>
(2)利用之前被盗取的用户账号,通过交易所提供的 API发起足够大的交易请求,并且在这些交易请求中,交易的价格通常会被抬高,如被抬高至日常价格的数万倍。<br>
(3)出售之前大量积累的数字加密货币,攻击者可以获得在这些交易中产生的巨大的价格差值作为利润。<br>
(4) 通过将获得的巨额利润转移出交易所来套现,资金被转移之后,所有已发生的交易将无法再更改,至此攻击者套现成功,用户将承受巨大的经济财产损失。</p>
<p>现如今 API信息泄露通常会分为两种与常见违规操作相对应的 API使用模式。主要包括下面两种 API关键密钥窃取的方式。</p>
<h5 id="具有大量第三方集成的大型平台">具有大量第三方集成的大型平台</h5>
<p>具有高流量站点并提供服务的组织通常具有大量的第三方集成系统,这些集成依靠API从第三方收集数据并以无缝方式将其提供给用户。在多云环境以及传统容器化等架构为代表的基础设施的去中心化、激励共享需求日益增长,这意味着 API并不是奢侈的事情,它对于现代的大集成平台必不可少,其中有的平台具有数百个 API,所有这些 API都需要进行管理和监视。但是,攻击者如果针对性地对某些开放 API的功能模块进行分析,就能发现其中的漏洞,并获取敏感数据或者特殊权限,从而实现对用户数据的访问和修改。</p>
<p>图6.4 显示了一个具有理论微服务体系结构的大型 Web 平台,该体系结构在很大程度上依赖于 API之间功能上的通信和集成。攻击者可以利用 API上的漏洞(或者是简单地缺乏访问控制)来获取对敏感数据的访问。<br>
<img src="/img/blockchain_sec/6_4.png" alt=""></p>
<h5 id="移动应用程序">移动应用程序</h5>
<p>大多数移动应用程序都依赖 API 从服务器提取数据,使得这些应用程序可以在设备本身上使用较少的资源。由于移动应用程序保护存在一些固有的挑战，活跃的攻击者会通过反编译和逆向工程来寻找移动应用程序中的漏洞。</p>
<p>图6.5显示了一个应用程序通过移动设备专用的 API路由，用户通过 Web 界面连接相同的后端,这种适用于传统 Web 应用程序攻击的方式(例如,字典攻击货币木马攻击)也适用于移动 API。</p>
<p><img src="/img/blockchain_sec/6_5.png" alt=""></p>
<h4 id="App伪造漏洞攻击">App伪造漏洞攻击</h4>
<p>App(Application)伪造漏洞是指攻击者利用钱包客户端未进行重打包防护的漏洞在钱包客户端代码中添加自定义的恶意代码。攻击者通过这些恶意代码来监听和窃取用户私钥等关键信息，从而盗取用户财产。2017 年年底，安卓操作系统被曝出高危漏洞-Janus 签名漏洞,通过这个漏洞，攻击者可以避开安卓操作系统的签名机制,对App 程序进行修改。</p>
<p>Janus 签名漏洞产生的主要原因在于谷歌在安卓 4.4 版本中引人了新的执行虚拟机ART(Android Runtime)。相比于之前版本的执行虚拟机，ART 支持直接运行 DEX 文件,无须包装成为 ZIP 文件,因此在程序中运行时并未检查文件头部 magic 字段(为504B0304)是否为 ZIP 文件。这样攻击者可以将恶意程序放置在 APK 文件的头部。由于一般用户系统在进行 APK 文件安装时,系统都会忽略检查 APK 文件的头部 magic 字段,默认攻击者恶意程序为正常的 APK 文件,程序尾部会被直接开始读取和解压。此时,用户系统检查不出签名有任何变化,因此直接安装了被攻击者篡改过的恶意程序。</p>
<p>如图 6.6 所示,存在两个安卓 apk 应用:正常应用 apk 和恶意应用 pk。攻击者通过反编译获得正常应用程序和恶意应用程序 apk 的代码(即 smali 代码)。通过在注人点注人恶意 smali代码的同时修改配置文件,可以获得一个包含恶意代码的 apk 应用程序,攻击者对它重新打包发布。</p>
<p><img src="/img/blockchain_sec/6_6.png" alt=""></p>
<p>由于安卓操作系统的使用用户非常多,攻击者可以利用 Janus 签名漏洞修改各种钱包客户端代码,通过植人恶意代码将转账的地址全部替换成攻击者的收款地址,用户一旦使用伪造的客户端钱包进行转账操作,就会造成不可估量的经济损失。</p>
<h4 id="钓鱼攻击">钓鱼攻击</h4>
<p>攻击者通过伪造以太坊、比特币等数字加密货币常用交易钱包客户端的操作界面来伪造非法客户端(称为钓鱼平台),主要针对一些对交易钱包客户端还不太熟悉的用户。-旦用户疏忽大意,不仔细检查交易客户端的安全性,确认是否为真实的客户端平台,就有可能中招,这就是典型的钓鱼攻击。攻击者利用钓鱼平台对收集到的用户敏感数据信息进行分析,从中可以挖掘出有价值的数据,甚至钱包交易私钥。</p>
<p>例如,IOTA(基于数字加密货币)在诞生之初,用户对此数字加密货币了解得不够深人,包括客户端的操作使用。攻击者利用这一点精心设计了一个钓鱼网站,<a target="_blank" rel="noopener" href="http://xn--iotaseed-wg0mf8yq7gkxmd22e.io">注册域名为iotaseed.io</a>,专门用来为用户提供在线种子(随机数)生成器,该种子被用户用来生成公共钱包地址。从域名地址来看,用户很轻易地就相信该网站为 IOTA 官网版的种子生成器,而实际上,攻击者通过对底层代码修改,将随机数生成函数总是返回相同且可预测的数字,因此生成的种子也是相同的,进而掌握了用户的私钥信息，最终盗取了大量用户的数字加密货币资产,其价值近 400 万美元。</p>
<p>从上面的攻击方式可以看出,有些攻击手段需要的成本非常低,但是却能导致巨大的经济财产损失。为了保障客户端的安全性,一方面,各交易平台和安全企业可以通过建立完善的网络安全部门,不断地对交易平台进行审查,同时提供给用户检验交易平台真假的方法;另一方面,用户在使用这些客户端的时也需要多加小心,避免出现重复使用同一案码等不利于账户安全的行为。</p>
<h4 id="恶意挖矿攻击">恶意挖矿攻击</h4>
<p>恶意挖矿攻击(Cryptojacking)主要指在未获得用户授权时,强行劫持用户的计算设备进行数字加密货币的挖掘操作的恶意行为。在大多数情况下,被劫持用户的设备所拥有的计算处理资源以及通信带宽资源等会被攻击者恶意利用。目前,数字加密货币需要使用大量的计算资源和带宽来进行挖掘工作,为了减少挖掘成本以及获得尽可能多的计算资源,攻击者可以利用这种攻击手段收集被劫持用户的设备,以较少的成本获得较高的收益。</p>
<p>目前,攻击者通常会在恶意程序中注人数字货币挖掘代码以劫持用户设备，或者在恶意网站中注人恶意脚本来劫持用户设备资源。常见的方式包括在恶意网站链接、恶意电子邮件及软件中注人代码实施攻击。随着数字加密货币的进一步推广,未来攻击者采用的攻击方式会越来越多样化,类似的安全事件会不断发生。</p>
<h4 id="Web-注入攻击">Web 注入攻击</h4>
<p>在一些区块链交易系统中,如知名的货币交易所 Coinbase,钱包客户端是以 Web 网页的方式进行管理的,这样使得传统的针对 Web 客户端的攻击技术就可以被利用来对区块链交易系统进行攻击。2017 年8月,Trickbot 银行木马对几家数字加密货币交易所实施 Web注人攻击,攻击者通过木马病毒在数字加密货币交易所网站上挂起虚假登录页面功能,使得用户在购买数字加密货币时,攻击者将用户钱包接收地址定向到攻击者自己的地址。</p>
<p>目前,Web 注人攻击的方式有多种,比较常见的 Web 注人攻击主要有 SQL 注入及跨站脚本(Cross-Site Scripting,XSS)两种方式。</p>
<h5 id="SQL注入攻击">SQL注入攻击</h5>
<p>SQL 注人攻击指攻击者通过精心构造 SQL 查询指令来向系统获取敏感数据,或者是网站的用户管理权限。例如,系统用户管理的 SQL 数据库运行的命令如下:<br>
<code>SELECT * FROM users WHERE 'username'='$user AND 'password'='Spasswd';</code></p>
<p>$user和 $passwd 分别指用户的用户名和密码。假设用户 Alice 登录系统访问时密码为 mingli@123,执行的 SQL数据库命令如下:<br>
<code>SELECT * FROM users WHERE 'username'='$Alice AND 'password'='mingli@123';</code></p>
<p>但是,攻击者可以使用此种 SQL 命令的漏洞来直接获得登录权限。攻击者可以在密码输人框中输人<code>'hi'OR 1--'</code>,执行的 SQL 数据库命令如下:<br>
<code>SELECT * FROM users WHERE 'username'=$Alice AND 'password'='hi' OR 1=1 --';</code></p>
<p>攻击者可以获得所有用户名为 Alice 的账户信息,由于命令行通过 OR 1=1 取消了对密码的检查。首先,1=1 总是成立,此外<code>“--”</code>在 SQL 是注释标识,可以被用来取消查询中原始的其他引号和其他任何的检查,即使有额外的凭证需要被检查,也会被系统忽略。因此,攻击者也可以直接登录系统进行访问。</p>
<h5 id="XSS-攻击">XSS 攻击</h5>
<p>XSS 攻击指通过在网页中嵌人恶意脚本程序,攻击者可以在用户浏览被注入程序的网页时,强行将恶意程序运行在用户的浏览器上。攻击者可以设定恶意脚本执行,包括盗取用户客户端 Cookie 以获得控制用户执行权限、获取用户名和密码(或管理员权限)等会带来严重危害的命令,致使用户客户端瘫痪。</p>
<p>通常情况下,具有安全意识的用户不会轻易点击进入未知网站,但是攻击者通过转载知名网页内容或者设计钓鱼网站,用户一旦点击进人就会遭受巨大损失。</p>
<h2 id="第7章-智能合约层安全">第7章 智能合约层安全</h2>
<h3 id="以太坊与智能合约">以太坊与智能合约</h3>
<h4 id="以太坊">以太坊</h4>
<p>以太坊是区块链 2.0 的典型代表,根据其官网中所定义的，“以太坊是一种支持智能合约的去中心化平台”,所以相较于比特币，以太坊除了支持数字货币交换功能以外,更重要的特性在于其所具备的可编程智能合约。正因如此,它可以被应用到更为广泛的非金融领域。简单来理解，以太坊是一台开放式的全球计算机,所有人都可以参与进来进行读取和写人操作,它可以支持用户创建可扩展的、易于开发的和协同的去中心化应用,是一种支持图灵完备(TuringComplete)编程语言的公有链平台。基于以太坊所设计的灵活合约编程语言开发者可以在以太坊中快速地创建去中心化应用，自定义地设定交易的规则状态转换函数以及交易方式等逻辑。比特币和以太坊两大公有链对比如表 7.1所示,主要的区别体现在共识效率(平均块生成时间)、交易规则以及是否支持<br>
图灵完备智能合约方面。</p>
<p><img src="/img/blockchain_sec/6_7.png" alt=""></p>
<p>在共识机制方面,以太坊最初采用的也是同比特币一样的基于工作量证明,为了提升平台的整体效率、减少资源的浪费,正在引人基于权益证明的共识机制。以太坊计算难度设置使其块产生时间非常快,也更符合现实去中心化应用对实时性的要求。此外,在交易设计中,比特币仅支持简单的数字货币转移,而以太坊可以设定基于复杂条件的价值转移,也即用户可以定义复杂的逻辑来实现相应的业务目标。最后,比特币只能支持有限规则的脚本语言,而以太坊支持任何逻辑规则的图灵完备编程语言。总体而言,以太坊一定程度上解决了比特币在可扩展性方面的不足。</p>
<p>下面介绍以太坊 3 种特殊的数据结构。</p>
<h5 id="账户">账户</h5>
<p>在以太坊中,用户可以创建一个或多个账户,每个账户都对应一个由 20 字节构成的唯一地址,主要由 4 部分构成。</p>
<p>(1)随机数($Nonce$):用于确定每笔交易只能被处理一次的计数器。<br>
(2)账户余额($Balance$):账户当前的以太币余额,其单位为 $Wei,1ETH=1×10^{18}Wei$<br>
(3) 合约代码($Bytecode$):账户所对应的智能合约代码,在合约创建时产生。<br>
(4) 存储($Stored Data$):账户的存储,每个账户都包含一个“键-值”对(Key,Value)形式的持久化存储,Key 和 Value 的长度都为 256 位。</p>
<p>特别地,以太坊中主要有两种账户类型:合约账户(Contract Account,CA)和外部账户(Externally Owned Account,EOA),其中合约账户 CA 是由智能合约中的代码逻辑来控制,在合约账户收到一笔有效交易的输人时,合约内部的代码会激活并支持对内部存储进行读写、消息发送或合约的创建。外部账户 EOA 也称用户账户,由用户自己的私钥来控制,支持用户通过创建和签名的方式来完成一笔交易,与比特币交易原理类似。在以太坊中,这两类账户共同维护了一些状态对象(State Object)的实体,这些实体中包含了变量所对应的状态信息。合约账户主要存储和管理用户余额以及合约中的内容,外部账户主要负责管理用户账户的余额,这些存储的状态对象在以太坊中会基于共识协议来保证。</p>
<p>-致性,各区块链节点拥有对全局状态对象的一致性视图(一定持久块之前的视图)。图7.1为两个状态对象之间通过交易的形式发生转换，通过一笔交易形式，地址 14c5f8b。中的10ETH 转人到地址 bb75a980 中,同时通过合约代码中的逻辑,将数据 data[1]CHARLIE 写人新的状态对象中,这是状态对象实体转变的简化过程,本质上是一种状态机迁移,通过用户交易触发合约状态发生改变。</p>
<p><img src="/img/blockchain_sec/6_8.png" alt=""></p>
<h5 id="交易-2">交易</h5>
<p>以太坊中的交易是指由外部账户发送的消息签名数据,其中包含了发送者签名、接收者地址、账户余额、发送币的数量、发送数据以及最大消耗的 Gas 限制(StartGas)、合约每步执行支付给矿工的费用(GasPrice)。以太坊中的交易和比特币的交易形式有些区别除了用户账户(与比特币一样,用于实现普通的转账交易),以太坊还包括合约账户,该类账户是在智能合约被第一次发布在区块链时所创建的,其创建过程是通过合约创建交易形式完成的。特别地,合约账户创建交易与其他数字货币交易形式不同,只有发送者地址,接收者地址则显示为本合约被创建的地址,如图 7.2 所示。</p>
<p><img src="/img/blockchain_sec/6_9.png" alt=""></p>
<h5 id="燃料">燃料</h5>
<p>为了防止智能合约中的逻辑过于复杂,如出现无限循环,进而导致以太坊节点瘫痪的问题,以太坊在设计过程中引人了燃料(Gas)的概念,智能合约代码转化为底层操作指令后,每个操作指令所触发的节点计算力消耗表现为不同大小的燃料消耗,这些消耗会转化为以太币,用来支付给矿工的计算费用。简而言之,燃料是用来维持以太坊生态系统正常运行的动力来源,合约中函数执行的计算会以燃料来衡量,用来支付给执行矿工的奖励。无论是普通转账交易,还是智能合约的创建和执行过程,都需要消耗燃料。在以太坊虚抄机中,函数会转化为操作指令,每个指令会消耗特定的燃料,用户在执行该函数前都需要输人一定的燃料作为执行的必要条件,每行代码都需要一定量的燃料来完成计算,不能小于预定的值,否则无法成功。需要注意的是,为了防止一个区块的数据过大而出现同步等计算问题,以太坊对每个区块所能消耗的最大燃料数进行了限制。在一个区块中交易执行过程中,总的燃料消耗超过了最大限制,则该笔交易会执行失败。</p>
<p>在交易中,用户需要设定两个与燃料相关的参数:燃料价格(Gas Price)和燃料限制(Gas Limit)。燃料价格是用户指定的每单元燃料的价格,一般以 GWei(1ETH=1X10°GWei)为单位。燃料限制是用户指定该笔交易支付的总燃料数量。按照多退少不补的原则,在交易执行过程中,如果燃料耗尽,则所有改变过的状态回滚到原来状态,已经支付给矿工的费用不会返回;如果交易执行完成,燃料还有剩余则会返还到对应的账户中。</p>
<h3 id="智能合约-2">智能合约</h3>
<p>智能合约是在 20 世纪 90 年代由 Nick Szabo 教授首次提出的其定义的智能合约为“一套以数字形式指定的承诺,包括各参与方履行其他承诺的协议”。与传统的纸质合约相比,智能合约是一套执行某种特殊条件的计算机协议,用户可以自定义与协议相关的规则和条件,并能够在可信的执行环境中自动执行这些协议。实际上,智能合约本身不一定需要依赖于区块链环境来运行,只要满足条件的可信环境就能够运行智能合约。由于一度缺乏这样的可信执行环境,智能合约在实际生活中难以实现,随着区块链技术的诞生和发展,其技术特性为智能合约的部署实施创造有利的条件。</p>
<p>智能合约在区块链中实际上是一段可运行的计算机程序,当满足一定条件时(有效数据输人),记录在智能合约中的事务处理和保存机制可被自动执行。智能合约收到事务信息后,会改变合约中的数据状态,从而触发智能合约并且根据预设信息选择合约动作自动执行。目前,多种区块链平台都提供了智能合约的执行和编译环境,例如以太坊、超级账本。智能合约常用于运作自动服务机构,用来提供透明公开的信息服务。在以太坊中,智能合约是包含计算机程序代码与状态数据的集合,在无须依赖第三方的情况下执行的可信数据传播、执行以及验证,其特性主要体现在 4 方面。</p>
<p>(1)计算机程序(Computer Protocol):智能合约是计算机程序代码。(2)自行验证(Self-Verification): 智能合约通过对输人数据进行解析，来自行验证<br>
(3)自动化执行(Self-Execution): 支持在可信环境中依据响应规则,自动化执行某数据是否满足此前所预置的响应条件。些代码和协议,其他参与方无法干预执行的过程和条件。(4)防篡改(Tamper-Resistant): 已经部署后的智能合约代码和状态数据是无法被<br>
如图 7.3 所示,一个智能合约模型包括一段运行在区块链上的代码,这段代码可以维护自身的状态,控制其上所具备的数字资产,同时与外界的输人请求进行交互,执行相应的指令动作。可以看出,在该模型下,智能合约存储了持久化合约的状态以及其中所存储数据的状态,这种链上状态的自我维护是区块链构建可信式分布式账本的基础。</p>
<p><img src="/img/blockchain_sec/6_10.png" alt=""></p>
<p>在以太坊中,主要有 4 种编程语言可以用来开发智能合约:Solidity、LLL、Serpent 和Mutan。其中,Solidity 是运用最为广泛的一种,语法与 JavaScript 非常类似。利用Solidity 开发的智能合约代码首先在以太坊虚拟机(EVM)被编译成字节码,编译完成之后将其部署在以太坊区块链,这样可以通过与特定合约的创建地址交互来完成交易过程。值得注意的是,智能合约只有在执行交易调用时才会运行,属于被动式触发,通常由外部拥有有效账户地址的用户发起。一般情况下,智能合约在以太坊中处于休眠状态,直到有用户利用有效输人来触发合约执行。</p>
<p>智能合约对应以太坊的合约账户,即由合约地址、合约余额、状态信息和合约代码 4部分组成。以图 7.4 中智能合约为例,这是一个简单的计数器,里面包含一个变量 count它是该合约的状态变量,当特定用户调用函数 add()对变量进行加 1操作时，count 在以太坊网络中的全局状态将会加 1,即在交易触发条件下,智能合约发生状态迁移的简易描述过程。在 7.1.3节中,将对 Solidity 具体语言规范及编译过程进行解析。</p>
<p><img src="/img/blockchain_sec/6_11.png" alt=""></p>
<h3 id="智能合约基本语法及编译">智能合约基本语法及编译</h3>
<h4 id="基本语法">基本语法</h4>
<p>Solidity 是一种面向对象编程的静态类型开发语言,语法与 JavaScript 接近，它专门用于开发去中心化应用。Solidity 支持继承、库和复杂的用户自定义数据类型等功能。通过一个简单的示例来学习智能合约的语法。读者也可以在基于浏览器的编译环境RemixIDE 进行学习,Remix 允许用户在上面开发部署编译和测试智能合约，程序如下:</p>
<p><img src="/img/blockchain_sec/6_12.png" alt=""></p>
<p>上述程序的 SimpleStorage智能合约,主要逻辑分为两大部分:①版本杂注，声明合约编译器的版本,在未允许版本的编译环境下该合约无法编译,用于告知编译器如何对智能合约进行编译。截至2020 年 10 月,Solidity 编译器版本已经发布到 0.7.4。在SimpleStorage 合约中,编译器版本选择 0.4.0 以上、0.7.0 以下都支持。②合约部分,与Java 中所定义的 Class 对象类，是包含一系列的代码(函数)和数据(状态)的合约对象。几点说明如下。</p>
<p>(1)第2行contract 后面定义的是该合约的名称。一般情况下,一个.sol 合约文件通常由一个或者多个 contract 构成。<br>
(2)第3行定义了合约变量,该变量为 unit 整数类型。在 Solidity 中,定义了多种数常由一个或者多个 contract 构成。据基本类型,包括地址、整数、布尔、枚举等,不同的数据类型定义消耗的以太坊 Gas 不同。为了降低交易的 Gas 消耗,通常会在满足条件情况下选择 Gas 消耗最少的类型进行<br>
定义,常用的整数类型还包括 uint8、uint32、uint256。<br>
(3)第4 行定义了event 事件,它是 Solidity 中特有的一种函数类型。event 事件是为了方便开发者使用 EVM 的日志基础设施，使得用户可以在 DApp 用户界面中监听该事件是否被触发。在该合约执行调用第 11 行的 print 函数时,在区块链中创建一个日志人口,打印 Hello World 参数。event 事件主要标记合约中重要的操作日志，提醒用户重要的函数操作将会被执行。例如 Transfer(),这种与用户账户余额相关的函数操作一般会设定 event 事件,来实时地通知用户余额发生变化。<br>
(4)第 5行 set(uint x)声明一个返回类型为空的公开函数,说明该函数除了可以被本合约所调用,还可以被外部其他合约所调用。<br>
(5)第 8行 get()声明一个有返回值类型的函数,函数声明中如果包含关键字returns,则说明该函数会有返回值。根据不同的返回类型定义有不同的返回值，如returns(uint)返回的是一个整数类型的值。</p>
<p>Solidity 智能合约主要包含状态变量、函数、函数修饰器、事件、结构类型和枚举类型六大类数据结构的声明,同时支持合约与合约之间的继承。其具体的声明及含义如表 7.2所示。</p>
<p><img src="/img/blockchain_sec/6_13.png" alt=""></p>
<p>以太坊发布的 Solidity Documentation 官方教程中对 Solidity 中结构、类型变量和特殊操作等做了明确的介绍,建议可通过此教程深人学习 Solidity 编程语言。</p>
<h4 id="以太坊虚拟机">以太坊虚拟机</h4>
<p>目前,计算机虚拟机主要包括两种形式:基于栈(Stack-based)的虚拟机和基于寄存器(Register-based)的虚拟机。基于栈的虚拟机典型的包括JVM、CPython 等，它主要的特点是在进行运算操作时,直接与操作数栈(Operand Stack)进行交互，即数据存取顺序为先进先出,无法直接对内存中的数据进行操作,因此速度相对较慢,但优点在于实现较为简单、易于移植。基于寄存器的虚拟机是利用多个虚拟寄存器来进行操作数的运算，速度相对较快。以太坊虚拟机(EVM)是基于栈的虚拟机。基于 Solidity 编写的智能合约通过编译之后成为二进制指令文件,通过 EVM 执行来完成合约状态信息的改变。EVM是对外隔离的沙盒环境，即在运行期间无法访问网络或文件,即使不同的合约在 EVM 中运行时也仅有有限的访问权限。一般虚拟机主要完成3种功能。</p>
<p>(1)读取指令:获取内存中的指令信息。<br>
(2)译码:确定所要执行的指令类型<br>
(3) 指令执行:执行译码后的指令。</p>
<p>如图 7.5 所示，以太坊虚拟机中栈采用32B(256b)的字长,并以字(Word)为单位进行操作,栈最大支持1024个字。</p>
<p><img src="/img/blockchain_sec/6_14.png" alt=""></p>
<h4 id="编译环境">编译环境</h4>
<p>为了运行 Solidity 智能合约,需要将其编译成EVM 所能理解的字节码,然后以交易的形式发送给以太坊来进行部署。目前主要有两种方式支持对 Solidity 合约进行编译。</p>
<p>(1)Solc:支持命令行式的 Solidity 能合约编译工具。<br>
(2)Remix:面向浏览器IDE 方式的Solidity 智能合约编译部署以及调试工具。</p>
<p>通过上述工具将智能合约转换成字节码,字节码本身依据设定的机制对应到不同的操作码,基于操作码对应在 EVM 中执行的操作完成智能合约的部署和执行。如图 7.6所示,SimpleStorage 智能合约通过 Remix 编译后的字节码形式,主要包含 4 部分linkReferences、object、opcodes、sourceMap。其中,linkReferences 指链接引用;object 指<br>
字节码对象;opcodes指合约操作码列表;sourceMap 是源码的映射,主要用于调试。</p>
<p><img src="/img/blockchain_sec/6_15.png" alt=""></p>
<p>智能合约编译后的字节码对象 object 分为 3 部分:合约部署代码、合约本身代码和Auxdata 字段。</p>
<p>(1)合约部署代码(Deploy Code): 以太坊在建智能合约过程中,首先需要有创建Auxdata 字段。合约的指令,这就是合约的部署代码。虚拟机会首先为合约生成账户地址,然后再运行合约代码。合约运行之后会将运行代码和 Auxdata 部分存储于区块链中,通过将二者的存储地址与合约账户地址进行关联,具体过程则将合约账户中的 code hash 字段用该地址赋值,最后完成合约的部署。<br>
(2) 合约本身代码(Contract Code):智能合约中的实体功能部分为运行代码,即合<br>
约声明内的变量及函数逻辑。<br>
(3)Auxdata 字段:智能合约中的最后43 字节为 Auxdata,它跟在运行代码后面被存储起来,作为代码的标识(基于密码学生成指纹数据)用于合约验证。</p>
<p>在运行智能合约代码之前,需要通过 3 个步骤对所部署智能合约进行事先检查与<br>
处理。<br>
(1)payable 检查。该步骤主要是确定合约的函数是否可以执行 ETH 的发送操作payable是函数的一个声明,函数在被标记为 payable 情况下,用户不但可以执行相应的函数功能,还可以向该智能合约发送 ETH,而如果函数在没有被 payable 标记的情况下执行 ETH 发送操作会导致失败。<br>
(2) 执行构造函数。初始化智能合约中构造函数所对应的合约状态。(3)智能合约代码内存复制。本步骤将合约转换后的代码和一些属性数据从交易复制到内存中,并且返回。</p>
<p>通过以上步骤将智能合约部署完之后,合约代码可以开始运行和调用。在智能合约中,按照统一标准的 EVM操作码进行执行,但是由于虚拟机中操作码被限定在一个字以内,因此EVM指令集中最多支持 256 条指令,如表 7.3 所示,在目前已经定义的 EVM操作指令中,主要包括基本操作的算术、按位运算、跳转等指令,每条指令被设置消耗的 Gas不同,主要限定用户在一个交易中所能设计的最大逻辑,保证以太坊节点的稳定运行。</p>
<p><img src="/img/blockchain_sec/6_16.png" alt=""></p>
<h3 id="智能合约安全威胁">智能合约安全威胁</h3>
<h4 id="交易顺序依赖漏洞">交易顺序依赖漏洞</h4>
<p>交易顺序依赖漏洞(Transaction-Ordering Dependence Vulnerability)是指一种依赖于交易执行顺序而造成执行结果差异导致的安全漏洞。具体地说,针对同一个智能合约，假设在同一段时间内产生了两笔交易 T，和 T,这两笔交易都基于相同的变量执行了某个操作。对于矿工,当收到两笔交易时,他可以选择先执行 T再执行 T,也可以先执行T:再执行 T,这两笔交易被写人区块链的顺序是由最新块产生的矿工决定的,用户本身无法控制。然而,不确定的执行顺序会导致执行结果存在截然相反的结果。</p>
<p>交易发送出去后会先存人交易池中,区块链节点在共识计算时会从交易池中按照规则选取一批交易放人新生成的区块中，此时该新块还没有被确认为最终块,不同的节点选取的交易和交易放人的顺序都是不固定的,因此合约所执行的函数顺序也是不可预测的-般矿工会选择交易费高的交易放人新块中,这样攻击者可以通过提高交易费使得其交易在其他交易之前被写人,进而影响合约的执行最终结果。</p>
<p>MarketPlace 合约是一个关于股票市场的去中心化应用,合约中声明了两个变量price和 stock,以及两个功能函数 updatePrice 和 buy,其中 updatePrice 函数用来更新price值,只能合约所有者才能修改。buy 函数是用户从合约中购买股票，可以看出用户实股票的数最是与量 price 相美的,在雨数 updatePrice 中可以看到只有合约的所有者才能修改 price变量,buy 丽数是所有用户可公开调用的。合约的其他功能进行了略,包括购买股票之后需要进行转账操作。MarketPlace 合约的具体代码如下：</p>
<p><img src="/img/blockchain_sec/6_17.png" alt=""></p>
<p>从合约中可以看出,当合约所有者在用户操作 buy 函数之前或之后执行 updatePrice函数,交易的执行结果是不一样的,这将会导致用户所购买到的股票数量与预期值相差巨大。如图7.8所示,假设当前 stok 单价是 3ETH,当用户通过 buy 函数购买股票并发送-笔交易,假设用户余额中总额有 18ETH,他可以购买 6个 stock。此时,合约所有者调用updatePrice 函数修改 price 值,假设修改为9。与此同时,合约所有者用稍高一些的交易费使得修改 price 的这笔交易被优先确认,这样导致用户操作 buy 函数购买股票的价格是新的价格,最终只能购买到2个 stock。实际上,合约所有者可以任意地修改 price的值,将用户账户的余额全部清零。一般在同一个区块链存在针对相同合约的两笔交易,交<br>
易顺序依赖漏洞很容易出现。</p>
<p><img src="/img/blockchain_sec/6_18.png" alt=""></p>
<h4 id="时间戳依赖漏洞">时间戳依赖漏洞</h4>
<p>时间藏依赖漏洞(Timestamp Dependence Vulnerability)是指在合约代码中，中间状态变量值修改或某操作执行的触发条件是依赖当前区块的时间戳而引起的漏洞。假设在用户转账过程中,依赖于当前时间与初始时间的差值作为是否转账的判断条件,不同区块链节点之间的本地时间允许存在一定范围内的误差,当节点收到一个最新挖出的区块时除了验证区块内交易等内容的有效性,还会验证区块的时间戳,如果该时间藏与自己本地的时间藏相差不大,则该区块被确认有效。然而,不同矿工之间无法做到时间藏完全同步,实际上以太坊允许不同节点的本地时间差可以有 900s(15min)的波动范围,这已经是一个比较大的值,如果合约创建者选择时间戳作为操作的触发条件,往往会造成较大的误差。在 Random 合约中,变量 salt 是当前区块的时间戳。在 random 函数中,为了生成随机数的种子 seed 值,需要利用 slat 来作为计算值。显然不同矿工产生的 salt 值不同,导致该函数的执行结果依赖于最终产生区块的节点时间戳。如果恶意的矿工为了获得有利于他的条件,可以在 900s 的范围内随机地定义本地时间戳,从而影响合约的执行结果Random 合约的具体代码如下:</p>
<p><img src="/img/blockchain_sec/6_19.png" alt=""></p>
<h4 id="异常处理漏洞">异常处理漏洞</h4>
<p>异常处理是计算机编程语言或计算机硬件中的一种安全保障机制,专门用来处理超出代码正常流程范围的异常状况。通过对代码中的异常情况进行处理,可以对用户的非法参数输人进行有效控制。同样地,智能合约中异常处理的方式不正确,也会影响到合约的安全性。异常处理漏洞(Mishandled Exceptions Vulnerability)是指在合约中没有对异常情况进行有效处理而引发的漏洞。例如,在 Solidity 中用户可以通过 call 方法来实现对其他合约的函数进行调用,当调用异常时,可以通过 throw 命令来抛出异常信息,终止合约的执行。然而,已部署的智能合约在编写过程中并没有对函数调用进行异常处理,也没有对返回结果进行验证,从而导致合约后续的错误执行。比较典型的触发合约异常的条件如下。</p>
<p>(1)out-ofgas 异常:由于合约执行需要消耗的实际 Gas 是非确定性的,交易执行前输人的 Gas 只是预估值,如果在合约执行过程中 Gas 耗光,则会导致合约执行异常。<br>
(2)throw异常;合约执行到定义的hrow 则会抛出异常,被调用的合约会立刻终执行并且回退到此前的状态,返回失败。<br>
(3)栈溢出出异常:EVM最大支持 1024 深度的执行回调。随着每次的消息调用，<br>
栈深度会增加1。当调用栈深度已经达到 1023,继续执行某函数调用时，会导致合约执行失败。</p>
<p>out-of-gas 异常是智能合约最常见的异常触发条件，这是因为合约所消耗的 Gas 难以准确地估计,一且在交易中设定的 Gas 被消耗殆尽,则会出现 out-of-gas 异常。栈滥出异常是可以被主动触发的异常,攻击者(区块链节点)可以主动触发该异常，从而导致调用栈的深度达到 1023,当再次执行调用时会导致合约抛出异常。此外，触发异常的方式还包括除法中分母为0或者数组超出界限等。KingOfTheEtherThrone 合约中就存在异常处理不正确而导致的安全漏洞问题,具体代码如下:</p>
<p><img src="/img/blockchain_sec/6_20.png" alt=""></p>
<p>KingOfTheEtherThrone 是支持用户竞争成为以太币国王(Monarch)的智能合约,用户通过发送一定数量的数字货币到当前国王的地址,则可以成为新的国王。在函数claimThrone 中,第 15 行 send 函数是用户将数字货币发送到前一个国王地址如果转成功,则新用户(msg.sender)就可以成为下一任国王。由于合约并没有对 send 函数的返回结果进行验证,所以转账操作即使失败,也会执行第 18 行的国王角色的交替,导致现任国王没有收到补偿,同时还失去了国王的位置。根据上述合约异常的方式，造成 send函数返回失败的方式可以有两种: out-of-gas 异常和栈溢出异常。</p>
<p>(1) out-of-gas 异常:国王的地址并不是普通的账户地址,而是合约地址,当发送<br>
笔交易给该合约时,由于会执行一些函数操作,相比于普通的账户地址所消耗的 Gas 会重多,但是该合约并不清楚在调用 claimThrone 函数时需要多少 Gas,就可能存在合约Gas 耗光的情况,导致合约的账户状态没有发生改变,而现任国王将丢掉自己的王座。</p>
<p>(2) 栈溢出异常:另一种攻击方式是构造超出调用栈大小限制的执行环境,send 函数是一种库函数调用,利用的是以太坊中已经定义的标准函数,该函数依赖于其他提前部署合约中的执行结果。因此,攻击者在发起攻击前,首先自身调用 1023 次,然后再发送交易给 KingOfTheEtherThrone 合约调用 claimThrone 函数，由于调用栈溢出异常导致合约执行异常,而函数中没有进行返回结果检查,会继续执行第 18 行的函数,这样现任国王既会失去王座,还得不到补偿。通常情况下,如果调用用户自己定义的合约函数,这种情况下出现异常的概率会更大,一些恶意的用户甚至故意定义一些存在漏洞的合约函数让其他用户进行调用。</p>
<p>总而言之,在开发以太坊去中心化应用中,没有权威的第三方对发布合约的内容进行审核把关,为了保证合约不出现异常情况,需要在函数调用时,做好异常处理以及函数调用返回值判断。</p>
<h4 id="竞态条件漏洞">竞态条件漏洞</h4>
<p>竞态条件漏洞(Race Condition Vulnerability)是指在设备或系统中出现不恰当的执行时序,导致无法获得正确的执行结果。一般地,当有多个进程(或线程)同时获取或修改同一个数据时,如果对该数据的访问顺序敏感,就称为存在竞态条件。</p>
<p>在 Solidity 合约中,竞态条件漏洞发生在不同合约(或不同函数)之间针对同样的状态变量而进行的攻击,以太坊目前并不支持真正意义的并行处理,然而在逻辑上不同合约或函数之间却依然存在对共享状态变量的竞争,也就必然存在竞态条件的风险。智能合约允许调用外部合约来执行本地的功能函数,但假如该外部合约为恶意攻击者创建的合约,那么攻击者可以利用合约漏洞来竞争获取该合约的控制权,从而接管当前合约的执行流程,影响合约的正常执行。目前存在两种比较典型的竞态条件漏洞:可重人攻击漏洞(Reentrancy Vulnerability)和跨函数的竞态条件漏洞(Cross Function Race Condition<br>
Vulnerability)。</p>
<h5 id="可重入攻击漏洞">可重入攻击漏洞</h5>
<p>可重入性是指针对一个函数在同一时间多次发起调用。在以太坊中,攻击者可以利用函数的可重人性来对智能合约发起可重入攻击。在智能合约中存在一种特殊的函数它既没有函数名、输人参数，也没有输出参数,在合约调用过程中,没有函数类型与指定的函数类型相匹配(或没有提供调用数据),它就会被执行,这个函数就是回退 falback 函数。此外,当合约地址可以接收以太币时,该函数也会被执行,此时 fallback 需要被标记为payable(代表函数可以接收外部发到合约账户上的 ETH),否则无法正常接收 ETH般在合约内部调用 fallback 函数所需要的 Gas 非常低,如果从外部合约调用 fallback函数则需要消耗较高的 Gas,这是因为需要对调用合约进行有效性检测。fallback 函数的示例代码如下:</p>
<p><img src="/img/blockchain_sec/6_21.png" alt=""></p>
<p>可重人攻击漏洞是指攻击者通过发送一笔交易,操作合约重复执行导致合约账户余额耗尽的攻击方式。在 Solidity 合约中,攻击者可以利用 allback 和 call 函数来实现可重人攻击。简单来说,攻击者自己设计一个智能合约,该合约中定义一个 payable 的fallback 函数,通过在该函数内部递归调用正常合约的转账函数,让其不断重复执行,这<br>
样就会使得转账执行多次。</p>
<p>The DAO 中总账户的余额就是通过可重人攻击漏洞被不断转走的。The DAO 的总众筹金额达到 1.5 亿美元,通过以太坊平台将募集的资金锁定在智能合约中，每个参与者根据众筹的出资额获得相应的 DAO 代币,代币可以用来对项目进行审查和投票表决如果项目获得约定的票数支持,则相应的款项会转到对应的地址，同时每个用户按照比例来获得一定收益。由于遭受可重入漏洞攻击,导致超过 300 万个 ETH 被盗取。在了解The DAO攻击之前,需要明白智能合约中的转账操作方式。</p>
<p>在Solidity 合约中,有3种函数可以实现合约之间的相互转账:addr.transfer(uint256 amount),addr.send(uint256 amount) returns( bool)、addr.call.value(),都是代表向地址为 addr 的用户账户转账,单位为 Wei,但是在执行过程中这 3 种函数稍有区别。</p>
<p>(1)addr.transfer(): 执行时有 Gas 限制,最大为 2300,如果转账失败则抛出异常<br>
信息。<br>
(2)addr,send(uint256 amount) returns(bool): 执行时有 Gas 限制,最大为 2300,如果转账失败则返回 false。<br>
(3) addr,call,value();执行时没有 Gas 限制,如果转账失败则返回 false。</p>
<p>DAO合约 withdrawRewardFor 函数的具体代码如下:</p>
<p><img src="/img/blockchain_sec/6_23.png" alt=""></p>
<p>The DA0合约受攻击的代码在 DAO 合约中 withdrawRewardFor 函数的第6行遗行执行 payOut 函数，目的是向地址_acount 转人数量为reward 的代币。payOut 函数是在 ManagedAccount.sol合约中定义的函数，主要功能为根据一定规则来判断是否达到转账的条件。</p>
<p>DAO合约 payOut 函数的具体代码如下:</p>
<p>第4行函数是向接收者_recipient 地址转账_amount 个代币,使用的是addr.callvalue 函数，由于没有 Gas 限制,可以被攻击者循环利用来发起攻击。</p>
<p>如图7.9所示，攻击者发起 The DAO攻击的主要流程:首先,攻击者创建一个攻击者合约,在其中复写fallback 函数，用于回调The DAO合约的withdrawRewardFor函数。攻击者在合约中初始化一个合法的withdrawal 时,调用 The DAO合约的withdrawRewardFor 函数,在 withdrawRewardFor函数中会执行转账操作,根据 fallback函数的特性,在合约收到转账时会自动执行 fallback 函数中的逻辑，而攻击者在复写的fallback 函数中又去重新调用 withdrawRewardFor 函数，导致 The DAO合约继续给攻击者合约转账,该过程不断地循环(虚线内的逻辑),将 The DAO 合约的 DAO币不断转出。</p>
<p><img src="/img/blockchain_sec/6_24.png" alt=""></p>
<p>简化版的攻击者合约代码如下,通过复写的 fallback 函数(第 9 行)重新调用本合的 withdrawRewardFor 函数，进而实现对 The DAO合约的重人调用。</p>
<p><img src="/img/blockchain_sec/6_25.png" alt=""></p>
<p>在第9行的fallback 函数中,攻击者通过回调 withdrawRewardFor 函数来实现递归调用攻击。为了避免无限调用 fallback 出现 Gas 耗光的异常出现，攻击者可以自定义递归的次数 account,攻击者也可以向合约地址存入一定金额的代币。然后,攻击者可以调用withdrawRewardFor函数向 The DAO发起交易在withdrawRewardFor 函数中可以看到函数调用的是 The DAO合约的 withdrawRewardFor 取款函数The DAO合约中withdrawRewardFor函数会将一定数额的代币转给攻击者,当执行完 payOut 函数后该合约会自动触发攻击者合约的 fallback 函数,这样又会递归调用 The DAO合约的withdrawRewardFor 函数进行转账,重复循环99 999 次,从而不断地将The DAO合约账户中的代币转走。</p>
<h5 id="跨函数的竞态条件漏洞">跨函数的竞态条件漏洞</h5>
<p>可重入攻击是针对同一个函数的不断调用来实现的竞态条件攻击,另外还存在一种针对不同函数的组合来发起的攻击,称为跨函数的竞态条件攻击。具体来说,在调用合约中某一函数的过程中,在外部同时调用另一个函数，假设这两个函数依赖于共同的状态变量,这样攻击者可以借助在该状态变量的中间态来完成攻击。TokenTransfer 合约建立了一个通证管理系统,用户可以在合约中用以太币购买通证,具体代码如下:</p>
<p><img src="/img/blockchain_sec/6_26.png" alt=""><br>
<img src="/img/blockchain_sec/6_27.png" alt=""></p>
<p>代码中主要罗列了两个函数:transfer 和 withdrawBalance。transfer 是将数量为amount 的通证转移到 to 地址上，withdrawBalance 用来将以太币存人交易发送者账户中。在该合约中,攻击者可以首先构造一个攻击合约,并复写 fallback 函数,fallback 函数中调用 TokenTransfer 合约中的 transfer 方法。在这种条件下，当攻击者调用withdrawBalance 函数来取款时，假设 msg.sender 为攻击者合约,当合约执行完第 12 行时,会自动触发执行攻击者合约中的 fallback 函数,而此时还未执行第 13 行,因此攻击者的存款状态并未修改。攻击者不仅可以将钱取走,还可以增加 to 地址的账户余额。这种跨函数的竞态条件常常发生在多个函数之间,或者多个合约之前。</p>
<h4 id="整数操作漏洞">整数操作漏洞</h4>
<p>整数操作漏洞是指在合约中由于整数变量都有上下界的限制,如果在运算过程中出现越界,即超出整数类型的有限范围时,会导致执行程序异常而遭受攻击。智能合约中有很多关于整数类型运算类的操作,由于 Solidity 智能合约中没有提供有效的整数溢出检测机制,而导致智能合约执行运算过程中容易出现安全问题,主要包括 3 类整数操作会引人整数溢出漏洞问题。</p>
<h5 id="算术运算错误">算术运算错误</h5>
<p>算术运算错误主要是由于算术运算结果比定义的整数类型大或者小的情况,称为整数上溢和下溢。依据运算的类型,整数溢出又可分为乘法溢出、加法溢出和减法溢出。以太坊中定义了多种无符号整数类型,包括 uint8、uint16、uint32、uint256,这些类型都是有范围限制的,超过范围则会报出异常。例如,假定变量a 被定义为 uint8,则变量a 能存储的范围是0~2s-1,即[0,255]。如果将 256 赋值给变量 ,则内存中存储的数据进位加1之后导致结果变为 0,同理,如果将-1 赋值给变量 a,结果会变为 255。</p>
<p>一般算术运算错误是由于没有准确预估变量所能达到的值，随着时间的推移,在计算过程中会超过变量的范围限制。例如,在合约中定义了一个类型为 uint32 的变量用来存储计数结果,由于不断累加,该变量值增加到超过 232-1 时,此时该值会被设置为 0,与预计计算结果不一致。同样地,如果一个整数类型变量被修改后小于 0,将会导致它下溢并被设置为最大值 225。算术运算错误容易出现在某合约中的变量是公开可修改的,攻击者可以通过更新其具体值超过定义类型的范围来导致合约执行的错误,对于较小值的整数类型更容易出现上溢问题,如 uint8、uint16。此外,算术运算错误还会发生在除法或者模运算中分母为 0的情况,同样会导致结果为 0。因此,为了防止算术运算错误,需要额外注意对整数变量的更新操作,可以定义符合应用场景的最大整数类型,同时对变量的能改需要权限级别较高的用户进行操作,对输人数据做好有效性检查。整数上溢漏洞具佬代码如下,西数add实现的功能是将两个 uint32 类型的变量相加，由于返回结果定样为uint32,这样极易出现超出uint32 的情况，导致执行结果与预期不符引发后续错误为了防止由于算术运算而导致的溢出漏洞,可以在计算前对输人数据进行有效验证,还司以使用 Solidity 中的标准库函数来实现安全运算。例如，SafeMath 合约。</p>
<p><img src="/img/blockchain_sec/6_28.png" alt=""></p>
<h5 id="整数截断错误">整数截断错误</h5>
<p>整数截断错误是出现在将一个整数类型转换为一个范围较小的整数类型时,导致精度丢失的错误。整数截断错误的示例代码如下,假设用户的 msg.value 值大于 255。相比其他编程语言类似于类型的强制转换,如果用户的输人大于被强制转换的类型值,那么预期的输出结果也会不一致,尤其设计用户的账户更新相关的操作，这种错误所造成的危害会更大。<br>
<img src="/img/blockchain_sec/6_29.png" alt=""></p>
<h5 id="类型转换错误">类型转换错误</h5>
<p>在将有符号整数类型(int)转换为相同长度的无符号整数类型(uint)过程中,可能出现将一个负数类型的值转换为一个正数值的情况,这就是类型转换错误。类型转换错误示例代码如下,合约中函数的输人类型为 int 型，函数依赖该输入的大小作为条件来执行是否转账操作。由于攻击者可公开调用该函数,那么可以在第 2 行输人一个负值来满足if判断条件,实现错误的逻辑处理,这是由于负数值被转换成了无符号类型的整数值。</p>
<p><img src="/img/blockchain_sec/6_30.png" alt=""></p>
<h4 id="基于块燃料限制攻击漏洞">基于块燃料限制攻击漏洞</h4>
<p>通常而言,矿工会选择交易费较高的交易数据打包至新块中。通过计算输入数据大小、执行指令等操作来计算交易所需的燃料,如果实际消耗的燃料数量小于燃料限制,则交易被正常处理。如果实际消耗的总燃料超过了燃料限制,该交易所有的操作都被还原为原来的状态,但是这些交易还是会产生,并且交易费会支付给矿工,未被使用的燃料则退还给用户。这种情况下,攻击者可以利用燃料限制的性质实现 DoS 攻击。具体地说攻击者可以发起一笔交易修改函数中的变量值,例如 for 循环的层数,使得交易消耗的燃料超过燃料限制，这样该函数执行会一直处理 out-o-gas 状态而无法被正确执行。基于块燃料限制攻击漏洞的示例代码如下:<br>
<img src="/img/blockchain_sec/6_31.png" alt=""></p>
<p>上述代码定义了与通证 Token 管理的函数和变量,其中 investors 指投资者数量,是一个可变长数组，通过 invest 函数可以修改 investors 的长度。攻击者可以发起 DoS 攻击,不断调用 invest 函数增加 investors 长度(消耗一定数据的 ETH)。如果合约中第12行 for 循环次数增加到一定层数，使得 distribute 函数消耗的燃料总是超过交易的燃料限制,那么 distribute 函数会一直处于 out-of-gas 异常状态而一直无法执行成功,导致合约正常功能实现受到影响。</p>
<h4 id="call-注入攻击漏洞">call 注入攻击漏洞</h4>
<p>call 注人攻击主要发生在 Solidity 合约之间的相互调用过程中。为了提升开发的效率,Solidity 支持合约之间基于 call 函数簇来实现相互调用,主要包括 3 种方法。</p>
<p><code>(1)&lt;address&gt;,call(..·) returns(bool)。</code><br>
<code>(2)&lt;address&gt;.delegatecall(...) returns(bool)。</code><br>
<code>(3)&lt;address&gt;.callcode(..·) returns(bool)。</code></p>
<p>以上传人的数据支持任何长度及类型的参数。在合约调用过程中,内置变量 msg 会随着调用的发起而发生状态变更。第一种 call 是最常用的函数调用方法,当执行该函数时,内置变量 msg 会修改为调用者,执行环境也切换到调用者的执行环境。call 方法常用的调用方式有如下两种。</p>
<p><code>(1)&lt;address&gt;.call(function_selector,argl,arg2,..)。</code><br>
<code>(2)&lt;address&gt;.call(bytes)。</code></p>
<p>address是合约账户地址,call 调用及用来执行该合约地址下的某函数。第一种是通过签数的方式,将方法及参数作为输人进行传入,第二种是直接基于字节数组作为输入的方式,在该字书数组中,同样地可以构造与第一种类似的方式执行输人数据。一般跨会铃调用执行方都会使用 msg.sender 全局变量来获取调用方的以太坊地址，以支持条件遭辑判断。在这种情况下,攻击者可以利用 all 函数实现注人攻击。例如,在智能合约中会经常判断调用者的身份信息是否是创建者身份，然而攻击者可以利用其他可公开调用的函数来绕过该条件判断。call 注人攻击漏洞示例代码如下:</p>
<p><img src="/img/blockchain_sec/6_32.png" alt=""></p>
<p>在上述 CallInstance 合约中,callData()是公开可调用函数,读人用户输人的数据data,operation()中设定是合约创建者才能执行的函数,但是攻击者可以通过其他函数来绕过该限制，以达到越权操作的目的。具体地说,攻击者可以在 callData 函数中构造一份data数据,该数据中通过设置将 operation 函数设定为选择器，这样在通过 call调用过程中会执行 operation 函数,msg.sender 也会切换为合约创建者身份，此攻击者就可以绕过第 7行的身份限制,以创建者身份来执行后续的操作。总而言之,call 函数为合约的相互调用提供了便利,但是也带来很大的安全问题,攻击者可以利用 call 函数来绕过很多限制条件。</p>
<h3 id="Solidity-安全编程">Solidity 安全编程</h3>
<p>通过7.2节的学习,了解了智能合约本身存在很多的安全陷阱，稍不注意就会导致合约执行结果与预期相差很大。以太坊智能合约的开发与其他编程语言不同,在出现漏洞时很难通过打补丁的方式来进行补救，因此会给用户造成巨大的经济损失。为了防止已知和未知的安全漏洞,不仅需要了解 Solidity 合约在 EVM 中的运行原理,同时要了解和学习新的开发思维以应对潜在的风险。本节主要从编程的简洁性、可读性、解耦性等方面出发,简要概述 Solidity 合约中的开发设计原则。</p>
<p>(1)为了保证智能合约代码的简洁性,不宜将大量的业务逻辑都放在智能合约中执行，可以将上层与应用相关的代码放在区块链外面,如通过 web3j 对接方式,将部分应用逻辑用 Java 语言来开发，将真正需要建立在去中心化逻辑上的代码放在智能合约中执行。另外,参照软件开发的设计原则,每个函数实现的功能是单一的,不同函数与函数之间保证一定的解耦性,这样使得每个函数可以基于模块化的形式被其他函数或合约调用。</p>
<p>(2)充分理解智能合约的运行机制,避免出现已知的错误。7.2 节中介绍的安全漏洞是 Solidity 中几种典型的攻击方式，还存在其他的安全漏洞在 Solidity 官网中会即时公布。Solidity 是一种与 JavaScript 类似的高级编程语言,其中的功能以及安全性方面都还在演进过程中,因此需要跟进对以太坊社区关于 Solidity 的最新安全进展,在发现新的安全漏洞时可以及时地检查自己部署的合约,尽可能快速地修复漏洞,规避风险。此外,保证合约执行过程具备一定的容错性,一旦发现错误,具备规避方案或者停止运行的功能，针对账户管理的风险尤其要注意。应尽量规避对外部合约的调用,在针对一些未经过严格审查和测试就发布的合约更需要重点关注。</p>
<p>(3)要从传统软件工程设计的角度来设计和开发智能合约。一个较为完善的智能合约需要按照“高内聚、低耦合”的原则,实现功能的模块化,充分利用已有的规范代码,减少有风险的开发编程。从智能合约的架构考虑,功能模块化和代码重用审查是验证合约规范性的主要方式。</p>
<p>下面针对 7.2 节中提到的 7类关键合约漏洞的规避措施进行描述。</p>
<p>(1) 针对交易顺序依赖漏洞,可以通过构造测试用例的方式对合约的所有函数进行测试,通过给定相同的输人数据,但是在交易确认顺序上通过设置不同的交易费来实现不同顺序的交易验证。通过这样的方式来查看合约的最终状态数据是否保持一致,如果不一致则说明合约存在交易顺序依赖漏洞的风险。如果出现此状况,则可以在函数中设定用户输人的条件判断,验证所执行的合约状态数据是否与预期的结果一致,在保持一致的<br>
条件下才向后执行。</p>
<p>(2)针对时间戳依赖漏洞,在智能合约中减少以时间戳(包括其他非确定性值)作为判断依据或者依赖值,通常情况下可以采用块高度(Block Height)作为替代值进行判断。通过块生成时间,依据场景需要可以估算利用多少块作为时间间隔合适,即时间间隔~块<br>
数量X块产生时间。</p>
<p>(3)针对异常处理漏洞问题,Solidity 支持异常捕获功能,在满足代码安全执行的同时,还需要考虑安全性。对代码中可能存在的异常行为,包括魔鬼输人、非法计算等,考虑是否由本段程序自行处理,还是需要让外层程序知晓并进行处理。如果为本段程序处理则添加 try-catch,否则通过 throw 的方式将该异常抛出。</p>
<p>(4)针对竞态条件漏洞,为了避免出现可重人攻击,可以通过 Solidity 推荐使用的“检查一生效一交互(Checks-Effects-Interactions)”模式,即在与外部合约或者函数进行交互之前,首先进行有效性检查,包括确认函数调用者的身份、所用参数是否符合规定取值范围、是否发送了足够的以太币或者用户是否具有执行的权限等。此外,为了处理会影响合约或函数之间的共享状态变量,需要将状态变量的更新放在交互之前执行,再执行合约或者函数之间的交互。竞态条件漏洞“检查一生效一交互”的具体代码如下,sendBalance 合约中，可以在 withdrawBalance 与其他函数“交互”之前,先做“检查一生效”,即将userBalances 状态变更放在if 检查之前，这样攻击者无法通过重人回调的方式对合约账户进行攻击。</p>
<p><img src="/img/blockchain_sec/6_33.png" alt=""><br>
(5)针对整数操作漏洞,可以参照两种方式来规避。首先,可以通过静态的整数溢出检查来对整数溢出问题进行安全性检查,判断输出是否在合理的范围内再进行赋值。虽然这样会提高合约消耗的燃料,但相比潜在的安全漏洞而言微不足道。此外,用户还可以利用标准库合约函数对整数进行安全性检查。智能合约中有一些专门进行算术运算的库合约 SafeMath,包括 add,sub、mul 以及 div。SafeMath 合约使用了内建的 require 或assert 函数来检查基本的算术运算是否会发生溢出。一旦发生溢出，require 和 assert 会自动触发事务回滚机制。</p>
<p>(6)针对基于块燃料限制攻击漏洞,为了保证交易中的燃料使用不超过限制,尽量避免包含循环操作的函数让外部用户进行调用,严格限制循环遍历总次数的修改权限。此外,开发者应该掌握减少燃料消耗和字节码大小的方法。例如,可以通过调用现有的库函数使得某些函数逻辑不存在本合约中,减少合约的字节码占用。另外,针对函数变量可以不设置初始值、使用言简意赅的字符串作为标识、减少对外部合约函数的调用等措施都可以用来降低燃料的消耗。</p>
<p>(7)针对 call 注人攻击漏洞,由于 calldelegatecall、callcode 3 种跨合约(函数)的调用灵活性非常大,并且在调用过程中会伴随 msg 值的变化,这给攻击者带来了极大的操作空间,因此在合约设计中,需要谨慎地使用这 3 种底层函数。要对调用参数做严格的校验,避免参数被注人包含恶意代码的数据。此外,由于 call 和 callcode 调用会改变 msg 的值,导致合约中的权限判定被绕过,导致代币被窃取,因此不能轻易地使用本合约的地址作为可信地址。同时,delegatecall和 callcode 这两种调用方法会将目标代码切换到本地环境执行,因此要对调用的函数进行细粒度的限制,防止对任意函数的调用。</p>
<h2 id="第8章-共识层安全">第8章 共识层安全</h2>
<h3 id="共识层安全概述">共识层安全概述</h3>
<p>系统的共识层安全主要概括为两方面:活性(Liveness)和一致性(Consistency)。4.6 节对这两大特性做过详细说明。具体地说，活性是指系统的共识协议的参与节点最终都会处理任一有效的消息。一致性主要用于描述系统的共识节点是否在某一有效交易上达成共识。</p>
<p>在区块链系统中,共识安全还要求系统具有抗审查性和抗 DOS 攻击的<br>
特性。</p>
<p>(1)抗审查性(Transaction Censorship Resistance):抗审查性要求系统具有抵抗恶意节点掌控交易的能力,主要是针对基于工作量证明的共识协议要求具备的性质,在这类协议中,矿工通常聚集计算力(矿池)来合作挖矿,每挖到一个块,矿池管理者就依据矿工的计算力贡献度来划分块奖励。然而,矿池机制破坏了分布式区块链的去中心化特性,恶意的矿池管理者可以掌握被处理进区块的交易,忽视矿工的计算力贡献度而不公平地划分块奖励。因此,存在矿池机制的基于工作量证明的共识协议需要保留分布式特性，即矿池的矿工挖到有效区块的概率与其计算力贡献度成正比,抵制矿池管理者掌控交易，例如SmartPool分布式矿池。</p>
<p>(2)抗 DoS 攻击(DoS Attack Resistance):抗 DoS 攻击要求系统中的共识节点具有抵抗 DoS 攻击的能力。基于工作量证明的共识协议具有抗 DoS 攻击的能力,而基于权益证明和基于拜占庭的共识协议并不具备。遭遇 DoS 攻击意味着所有诚实的共识节点都会宕机,没有处理交易的能力。现有的基于权益证明和基于拜占庭的共识协议会通过安全地更换系统的共识节点来抵抗 DoS 攻击,如 Ouroboros Praos、Algorand 和 ByzCoin。</p>
<p>实际上,经典的共识协议在分布式系统中已经被广泛研究,它们与区块链共识协议的区别在于它们只考虑封闭系统的共识问题。在安全的角度上,这些共识协议中的恶意节点可分成两类,即故障节点和拜占庭节点。具体来说,故障节点指那些因为进程失败或机器宕机而引发错误的节点，而拜占庭节点可以恶意地执行错误的指令或阻碍消息的发送在经典的共识协议中,Paxos 协议只能抵抗故障节点的错误,而 PBFT 可以抵抗拜占庭节点的错误。</p>
<h3 id="共识协议安全假设">共识协议安全假设</h3>
<p>共识机制提供了一种可以去除第三方可信机构的数据共享机制,给构建在区块链上的应用层提供去中心化的公共账本支持。共识层是区块链架构的核心,主要负责确保区块链网络中的各个节点可以共享一份有效的区块链视图。根据共识协议算法的不同,可以将共识机制划分为两大类:基于 Pow/PoS 协议的共识机制和基于 BFT 等分布式共识协议的共识机制。目前,衡量共识协议的安全指标主要包括链质量、激励相容度、作恶收益、审查敏感性。</p>
<p>(1)链质量(Chain Quality): 描述在主链挖矿的诚实区块链矿工数量。例如，比特币中51%安全代表工作在主链上诚实矿工的数量占总参与节点矿工的数量为 51%。(2)激励相容度(Incentive Compatibility):量区块链中诚实矿工获得区块奖励的最小百分比,主要是为了衡量对自私挖矿攻击的抵抗能力。<br>
(3)作恶收益(Subversion Gain):表示恶意的矿工在每个区块生成间隔的平均值内能够获得的区块奖励加上双重支付奖励的最大值,用来衡量区块链抵抗双重支付攻击的能力。<br>
(4)审查敏感性(Censorship Susceptibility):表示诚实的节点因为拒绝审查者请求而导致奖励损失的最大百分比。例如,在主链中产生了 5 个诚实区块,但是其中 3 个区块成为孤块,则审查敏感性为 3/5。该指标用于衡量矿工产生的区块成为孤立块的百分比。</p>
<h4 id="PoW-PoS-协议的安全性">PoW/PoS 协议的安全性</h4>
<p>现代密码体制下提出的密码学方案的安全性评估一般依赖于是否能将方案归约到某个公开的数学困难问题上,如 RSA 算法可以归约到大整数分解问题以及 EIGamal 算法可以归约到椭圆曲线上的离散对数问题。共识层的共识机制无法归约到某一数学困难性问题,如基于 PoW/PoS 协议共识机制安全是依赖所有诚实节点占有区块链中 51%算力或者权益。为了进一步阐明 Pow 协议和 PoS 协议的安全假设,下面分别对基于 Pow 协议共识机制和基于 PoS 协议共识机制进行详细讨论。</p>
<p>(1)基于 Pow 共识机制:在基于 PoW 共识机制的区块链中,节点想要获得出块权力必须提供一份“工作量证明”,即解决某个特定的数学问题。Pow 的安全假设是所有诚实节点占有区块链中 51%算力。如图 8.1 可以很好地说明区块链中汇集的算力资源越多,恶意的攻击者控制区块链的难度就越高。算力安全假设提供了 Pow 协议所需的安全性,但需要消耗大量的算力资源。</p>
<p><img src="/img/blockchain_sec/6_34.png" alt=""></p>
<p>(2)基于 PoS 共识机制:解决基于 PoW 共识机制中计算资源浪费的问题，最早使用基于 PoS 共识机制的数字货币是 PPcoin,以节点持有的数字货币的数量以及持有的时长来计算出币龄。节点持有货币的时间越长权益就越大,获得出块权的可能性就越大。与PoW 共识机制类似,基于 PoS 共识机制的安全假设是所有诚实节点占有区块链中 51%权益,同样以最长链为准。</p>
<p>基于 PoW/PoS 共识机制的安全假设实质上都是假设诚实节点共同维护区块链的能力远大于攻击者破坏区块链的能力。共识机制存在的问题主要体现在如下 3 方面。</p>
<p>(1)一致性不稳定:基于 PoW/PoS 共识机制在共识的过程中可能出现短暂的分叉需要等待后续更多区块生成后才能判定前面生成的区块是否获得了大多数链上节点的认可。因此,基于 PoW/PoS 共识机制下的共识机制只具备弱一致性。<br>
(2) 可扩展性差:扩展性主要用来衡量区块链中的处理交易的性能。早期的 PoWPoS 共识机制的区块链存在交易吞吐量低的问题，例如，比特币平均约每 10 分钟产生个区块,而且包含的交易有限,与传统情况下的银行交易系统的交易吞吐量和交易确认时间相比都有很大的差距。<br>
(3)重构困难: 共识机制使区块链系统具有去中心化的性质,这一性质保证了区块链可以在不需要可信第三方的维护下正常工作。但是在没有第三方维护的情况下，一旦发生安全假设被打破的情况就无法自动恢复到安全假设被打破前的状态。基于 PoS 共识机制的以太坊就曾发生过共识机制的安全假设被打破需要恢复到安全状态的情况。以太坊为了恢复安全状态,采取了所有节点共同投票进行硬分叉的措施，以恢复被盗取的以太币。硬分叉严重破坏了区块链的不可篡改性,因此当时出现了不少争议。所以,PoWPoS共识机制下的区块链存在重构问题。</p>
<h4 id="BFT协议的安全性">BFT协议的安全性</h4>
<p>拜占庭容错(Byzantine Fault Tolerance,BFT)是一种解决拜占庭问题的理论方法由于区块链的共识问题和拜占庭将军问题相似,所以基于 BFT 理论可以延伸出适用于区块链共识层的多种共识机制。现将区块链共识问题类比于拜占庭将军问题,每个参与节点充当将军的角色,参与节点之间传递消息的过程相当于将军的信使交换消息的过程在这一过程中,产生并传递错误信息给其他节点的故障节点称为拜占庭节点，传递正常消息的节点称为非拜占庭节点。假设分布式系统中有 n个节点,整个系统中的拜占庭节点不超过 m 个(n&gt;3m十1)。除了上面的安全假设,在分析拜占庭问题时,还会考虑如下4种假设。</p>
<p>(1) 拜占庭节点的操作不受控制并且可以实施合谋。<br>
(2) 拜占庭节点之间的错误行为是不具备相关性的。<br>
(3) 拜占庭节点之间的通信不是同步的,可能存在消息丢失、延迟等问题。(4) 拜占庭节点之间的消息传播不是通过秘密通道进行的,即传播中的消息是可以被攻击者窃听盗取的,但是传播的消息是不可以被篡改或者伪造的。</p>
<p>在 BFT 共识机制下,需要考虑两个安全指标,即安全性和活性。</p>
<p>(1)安全性:分布式系统下已经完成的请求不可被更改,并且可以查询和追溯已经完成的请求。对应到区块链系统中则是,已生成的区块不可被篡改以及区块中包含的交<br>
易可以被 BFT 协议下的区块链任意节点查询。<br>
(2) 活性:在分布式系统下,其他故障因素不会影响非拜占庭节点的服务请求被正常接收和执行。也就是说,在区块链系统中,系统需要稳定持续地生成新区块,节点的交易服务要被正常处理。</p>
<h3 id="可扩展共识协议">可扩展共识协议</h3>
<p>目前，区块链系统受扩展性的限制,即系统处理交易的吞吐量不随着共识节点数量的增多(计算力或股权益的增多)而增大,可扩展共识协议致力于解决这一困境。现有的可扩展共识协议包括基于混合方式(Hybrid-based)、基于变种链结构(Variant Chain-based)以及基于分片(Sharding-based)的共识协议。这类协议继承原有协议的安全假设(见 8.2节),但需要引人更强的安全假设来换取性能上的提升。</p>
<h4 id="基于混合方式的可扩展共识协议的安全性">基于混合方式的可扩展共识协议的安全性</h4>
<p>基于混合方式的可扩展共识协议是在保留原区块链协议安全性的基础上引人更快的交易处理构建组件来提高共识协议的可扩展性。新加人的构建组件往往通过牺牲分布式特性或安全性来换取更快的交易处理速度,因此,此时的共识协议的安全假设相比于原有的更强。例如,基于比特币的可信模型 Bitcoin-NG,将选取块生成者和处理交易的过程分离,选取块生成者的方式沿用比特币中的选取方式,但选中的块生成者在下一个块生成者出现之前有权利持续向主链添加交易,从而提高了交易处理速度。但是,Bitcoin-NG只保证概率性的活性。活性是共识协议的重要安全特性之一,它指系统的共识节点最终都会处理每笔有效的交易,而概率性的活性体现在 Bitcoin-NG 概率性地处理有效的交易,这一定程度上会降低系统的安全性,例如,财务系统有一笔清算交易需要完成最终确认以降低系统用户的账户风险,如果该财务系统采用了 Bitcoin-NG 协议,而该笔交易直没有被确认,从而威胁到系统用户的账户安全。闪电网也是在比特币的基础上允许验证者线下验证交易的正确性,只将多笔线下交易的结果发布到链上,加快两方之间交易的处理速度。但为了确保线下交易结果是正确的,闪电网引人非标准的数字签名方案,因此增加了密码方案的安全假设来保证系统的安全性。</p>
<h4 id="基于变种链结构的可扩展共识协议的安全性">基于变种链结构的可扩展共识协议的安全性</h4>
<p>基于变种链结构的可扩展共识协议继承了比特币的安全假设,即存在大多数的共识节点承认主链上的区块。它们通过重定义区块链协议来提高可扩展性，通常是重定义原区块链协议的共识链的结构。例如,Ghost 协议和 Spectre 协议。Ghost 协议在不影响原区块链的前提下承认有效的分叉区块,因此不同于比特币的单链结构,Ghost 协议以树状结构组织区块。在主链选择方面,它选择树状结构中权值最大的路径作为主链,其中路径的权值定义为该路径上区块的深度。但相比于比特币中每个矿工挖到新块的概率与其算力成正比不同,Ghost 协议中网络延迟小的矿工更有优势挖到新块，因此,矿工挖到新块的概率并不严格地与矿工的算力成正比。同样地,Spectre 协议允许挖矿过程中有多个区块产生,从而使原有单链在某一时间节点上的一个区块变成 DAG 区块，从而提高区块链的可扩展性。</p>
<h4 id="基于分片方式的可扩展共识协议的安全性">基于分片方式的可扩展共识协议的安全性</h4>
<p>分片技术是用于提高区块链可扩展性的关键技术之一,该技术使得区块链的性能随着节点的增多而线性增强。分片技术将区块链的共识节点划分为多个不交叉的分区,这些分区节点并行地处理区块链的交易,提高了交易处理速率,从而提高可扩展性。在提高性能的同时,共识协议还需要保证区块链的分布式特效和安全性,为了平衡好这 3 点,协议在设计上会引人如下 3 个安全假设。</p>
<p>(1)系统大多数共识节点是诚实的,一个分区至少 33%共识节点是诚实的。具体地说,协议采用不可预测且公开可验证的随机性协议,如 RandHerd 协议,来分配分区的共识节点。同时,采用密码抽签协议周期性地替换分区内的共识节点,使得分区中诚实和恶意的共识节点形成合理的比例,如 OmniLedger 协议。<br>
(2)共识节点之间存在认证的通信通道。目前的协议虽然利用传统的 BFT 协议来实现分区内交易的共识,但对共识节点的通信假设相比于原来更强。<br>
(3)系统的用户具有激励性。有些协议(如 OmniLedger 和 RSCoin 协议)在处理跨分区交易时是用户驱动的,它们要求用户有激励性去封锁和解锁相应的交易,以确保跨分区交易被正确地执行。假如用户故意封锁交易,不进行解锁操作,这类协议相当于遭遇DoS 攻击。</p>
<h3 id="共识层安全威胁">共识层安全威胁</h3>
<p>针对区块链共识机制的攻击手段有多种形式,攻击者主要针对共识机制中存在的安全假设不可靠和一致性不稳定问题来实施攻击。其中,基于安全假设不可靠的攻击包括51%攻击、贿赂攻击、币龄累计攻击等。基于一致性不稳定的攻击包括女巫攻击、芬尼攻击以及 Vector76 攻击等。近年来,攻击者对共识层实施的攻击已经引起了严重的经济损失。2016 年,51% Crew组织对基于以太坊的数字货币 Krypton 发起了 51%攻击并最后损失了21 465个KR代币。</p>
<p>为了进一步了解攻击者是如何实施针对共识层的攻击的,下面将对目前常见的 5 种攻击手段进行介绍。</p>
<h4 id="贿赂攻击">贿赂攻击</h4>
<p>贿赂攻击(Bribery Attack)指的是参与区块链共识的节点会被恶意攻击者使用数字货币或者法币所贿赂,使得这些节点工作在特定的区块或者分叉上,从而产生对恶意攻击者有利的分叉链。通过这种攻击方式,攻击者不需要掌握 51%算力也可以实现双重支付。贿赂攻击是将博弈论模型应用在区块链中的一种攻击方式。定义以下名词可以帮助理解贿赂攻击的原理。</p>
<p>(1) 非协作选择模型:该模型下所有参与节点都不存在与任意其他参与节点合作的动机,虽然参与节点可能形成群组,但是却无法形成拥有大多数节点的群组。<br>
(2) 协作选择模型:指系统的参与节点都为一个共同的动机进行合作。<br>
贿赂攻击者模型是一个非协作选择模型,即相当于在现实商业社会中的恶意收购者。恶意收购者是指在不经过被收购者同意而希望直接取得被收购者所拥有的资源的控制权。在贿赂模型下,攻击者拥有的资源如下。<br>
(1) 预算:攻击者拥有的贿赂其他参与者执行特定行动的资金总额。<br>
(2) 成本:攻击者实际支付给其他参与者的资金总额。将攻击者模型实例化到区块链中就是存在一个贿赂者利用自己拥有的足够多的资源对其他参与者进行贿赂,使得他们在区块链共识的过程中能够采取对贿赂者有利的行为。<br>
贿赂攻击对基于 Pow 共识机制、基于 POS 共识机制和基于 BFT 共识机制的安全性都会造成威胁。<br>
(1)基于 PoW 共识机制:基于 PoW 共识机制的区块链允许区块链节点自由地加或者退出区块链,并且都有机会参与共识。因此,攻击者可以通过贿赂攻击对区块链中参与共识的节点进行贿赂,从而产生对攻击者有利的区块链分叉。<br>
(2)基于 PoS共识机制:基于 PoS 共识机制的区块链共识节点需要拥有一定份额的股份权益,所以攻击者可以针对用于股份收益的节点进行贿赂。<br>
(3)基于 BFT 共识机制:基于 BFT 共识机制的区块链拥有 3f+1个共识节点,其中可以容纳f个节点出错。因此,攻击者只需要贿赂 3f+1个节点中的f+1个节点就能使区块链停止正常出块。为了获得有利于攻击者的区块,攻击者需要贿赂至少 2f+1个节点。</p>
<h4 id="币龄累计攻击">币龄累计攻击</h4>
<p>币龄累计攻击(Coin Age Accumulation Attack)指在 PoS 共识机制下攻击者根据币龄计算节点权益的机制来计算币龄总消耗,进而确定有效的区块链。币龄累计攻击主要实施于使用 PoS共识机制的区块链,而不能实施基于 Pow 共识机制的区块链。在 PoS共识机制下,矿工挖矿成功的可能性与矿工账户上持有的数字货币的数量以及持有货币的时间长度相关。在购买一定数量的数字货币并持有足够长的时间后,攻击者就可以利用自己的币龄优势控制区块链出块,从而控制整个网络。以最早采用 POS 共识机制的数字货币 Peercoin 为例,矿工获得出块权的难度与矿工持有的数字货币总额以及持有货币<br>
的时间长度有关。也就是说，矿工计算的哈希值需要满足以下公式<br>
$H(H(B_prev),A,t)≤balance(A)·m·Age(coins)$</p>
<p>式中,A 是账户地址;Bm.是上一个区块; 是时间;balance(A)是账户余额;Age(coins)是持有货币的时间长度。在 Peercoin 的最初版本中,拥有所有硬币 5%的攻击者可以将他拥有的数字货币通过交易分成多个 UTXO,直到拥有的 UTXO 的年龄比平均年龄高10倍。之后,攻击者可以利用这些币龄较高的 UTXO 来实现出块或者其他恶意操作，假如存在多个用户试图发起此攻击,则会导致网络质量严重恶化。为了防范攻击者通过长期持有数字货币获得较高币龄,区块链系统可以对矿工的持币总量和持币时间设置最大值约束,并且在达到预设的预警值时进行奖励清算来清空持币时间。</p>
<h4 id="长距离攻击">长距离攻击</h4>
<p>长距离攻击(Long Range Attack),指具有足够计算能力的攻击者通过从第一个区块开始重新构建另一个区块链。由于基于 Pow 共识机制的区块链消耗了大量的计算资源,因此难以实施。例如,攻击持续 1000 个区块的比特币至少需要 400 万美元,而且,与短距离攻击不同,这种攻击非常容易被发现。然而,PoS 共识机制与 PoW 共识机制不同PoS共识机制必须引人时间概念来替代原来的计算资源消耗机制。目前长距离攻击主要分为3类。</p>
<p>(1)向前腐化攻击(PoSterior Corruption Attack):通过控制曾经占有 50%权益的货币所有者重新构建区块链。由于这些早期持币者已经花费了他们手中的货币，不再承担持有这些货币贬值的风险,攻击者可以很容易地贿赂他们,让他们利用原来持有过的权益对区块链进行分叉。<br>
(2)权益流血攻击(Stake Bleeding Attack):在向前腐化攻击中,攻击者需要控制50%的权益。攻击者通过建立只有自己节点的区块链并在上面进行挖矿工作来获得挖矿奖励。虽然,最开始时,攻击者的链并不比公有链长,但只要它们隐藏的时间足够长,并积累使得攻击者隐藏的链拥有的权益超过 50%,那么最终攻击者工作的私有链就会成为最长链。<br>
(3)权益粉碎攻击(Stake Grinding Attack);攻击者利用自身的权益优势来获得计算出块所需哈希值的优势,从而拥有更高的出块机会。然后,再经过一段更长的时间后获得比诚实节点更长的链,实现对原有区块链的分叉。<br>
抵抗这种攻击的方式是引人检查点机制,即选择区块链中一些节点并每隔一段时间生成一个获得这些节点认证的区块,通过这样来确保这个区块所在的链原有的数据不会被撤销。</p>
<h4 id="自私挖矿攻击">自私挖矿攻击</h4>
<p>自私挖矿(Selfish-Mining)攻击,指矿工通过延迟区块的公布时间来获得出块优势实施该攻击的核心是诚实矿工在会被淘汰公共分支上浪费算力。攻击者通过有选择地公开他们开采出来的区块链来获得后续区块的出块优势,从而对公开分支实现分叉,最终使诚实矿工的工作失去价值。在自私挖矿攻击算法中,攻击者实质上维护两个区块链,包括一个私有链及一个公有链。私有链与公有链最初是一致的,一旦攻击者挖有效的区块后先加人私有链上而不进行广播。在这种情况下,攻击者就可以领先其他人一个区块的优势,然后在私有链上继续挖矿。即使公有链上的其他节点开采出区块,攻击者还是可以迅速地广播私有链的区块,那么还是有 50%的概率会被其他节点承认挖出的区块。实现攻击的情况可以分为下面两种。</p>
<p>(1)公有链长度大于私有链长度。恶意矿工需要拥有超过全网其他矿工的算力才可以通过在私有链上工作来超越公有链。由于恶意矿工拥有的算力较小,因此在这种情况<br>
下恶意矿工无法获得利益。</p>
<p>(2)私有链长度大于公有链长度一个区块。恶意矿工在私有链上进行工作会出现两种情况:①公有链中的诚实矿工在公有链中得到下一个区块,恶意矿工失去优势，此时恶意矿工主动广播私有链上的最新区块与公有链的区块进行竞争;②私有链上的恶意矿工开采出新的区块,此时私有链的长度优势得到保持。</p>
<p>目前研究者提出了两种方案来防止在区块链网络中发生的自私攻击。D发生分叉时,区块链网络把矿工随机分配到不同分支,来防止自私矿工把算力集中在较容易出块的分叉上。@网络上的矿池设置闽值限制,这将阻止自私的矿工获得比网络上运行的其他矿工更大的优势。自私挖矿攻击流程的程序代码如下:</p>
<p><img src="/img/blockchain_sec/6_35.png" alt=""></p>
<p><img src="/img/blockchain_sec/6_36.png" alt=""></p>
<h4 id="双重支付攻击">双重支付攻击</h4>
<p>双重支付攻击(Double Spending Attack)是指通过对区块链数据的改达到对同代币重复支付的目的。目前已知的实现双重支付攻击的手段有 5 种方式:51%攻击、种族攻击、预计算攻击、芬尼攻击和 Vector76 攻击。</p>
<h5 id="51-攻击">51%攻击</h5>
<p>51%攻击指攻击者利用算力优势在区块链上产生分支链。这类攻击主要发生在Pow共识机制中,拥有 51%算力的矿工可以通过自己的算力优势在新的分支链上生新区块,使得分支链成为主链从而撤销在原主链上的交易记录。如图 8.2 所示,攻击者以先在原主链(白色标识)上提交一笔交易,然后等待接收者确认后,攻击者在分支链上提交一笔接收地址不同但是花费的是同一比特币的交易,最后攻击者利用算力优势把分支链(灰色)扩展为主链,实现双重支付攻击。为了避免该攻击，一般建议用户要在收到 h个区块确认后才能认定交易有效且不可更改,k 的设定与安全强度和平台有关。</p>
<p><img src="/img/blockchain_sec/6_37.png" alt=""></p>
<h5 id="种族攻击">种族攻击</h5>
<p>如图 8.3 所示,种族攻击(Race Attack)主要针对只收到0确认就认定交易有效的用户。攻击者可以创建两个冲突的交易事务,并把第一笔交易发送给受害者,受害者接收到付款发送产品后,攻击者立刻发送相同数量的冲突交易并广播到区块链中,使得第一笔交易无效。在比特币中具体实施该攻击的过程如下;攻击者首先利用一个 UTXO 直接向接收者发送一笔支付交易,然后再利用该 UTXO 加上较高的交易费用进行广播,由于矿工一般优先选择具有较高交易费的交易进行确认,因此较高的手续费导致后者很快被其他矿工确认写人新的区块,使得接收者对应的交易被作废。<br>
<img src="/img/blockchain_sec/6_38.png" alt=""></p>
<h5 id="预计算攻击">预计算攻击</h5>
<p>预计算攻击(Precomputing Attack)的实施基于一个事实,就是在基于 PoS 共识机制的区块链中,矿工挖块时需要解密一个取决于前一个区块的哈希值。于是,攻击者可以利用拥有的算力和权益优势在产生第个区块的过程中通过随机试错的方式控制第 个区块的哈希值获得第i+1个区块的出块优势。利用这种出块优势,攻击者可以发起双重支付攻击并获取相应的区块奖励。</p>
<h5 id="芬尼攻击">芬尼攻击</h5>
<p>图8.4 为芬尼攻击(Finney Attack),这类攻击和种族攻击所针对的对象都是收到0确认就认定区块不可更改的用户。不同于种族攻击,采用芬尼攻击的攻击者是已经挖到一个区块而暂时没有广播。攻击者创建一笔交易把代币转移到自己的另一个账户,并把这笔交易记录到区块中,然后再把同一代币发给接收者。如果接收者在收到转账信息后立刻认定交易有效,那么攻击者可以广播自己挖到的区块来覆盖发送给接收者的交易。具体的攻击过程如下:①攻击者开采出一个区块 1包含一笔由地址 1向地址2转a个Token 的交易,其中,地址 1和地址 2都属于攻击者拥有的交易地址;②攻击者构造一笔由地址 1转到诚实用户的地址 3 的交易，③商家获得攻击者在②中构造的交易后发出商品;④攻击者广播区块1,利用区块的广播时间对同一个 Token 发起双重支付攻击。</p>
<p><img src="/img/blockchain_sec/6_39.png" alt=""></p>
<h5 id="Vector76攻击">Vector76攻击</h5>
<p>Vector76 攻击也称一确认攻击，是种族攻击和芬尼攻击的组合攻击形式。利用该5.Vector76攻击政击,使得交易所在的区块即使已经有过一次确认(即一个区块的延长),该交易依然可能被回淡和撤销。然而,这种攻击对攻击者而言会消耗其一次挖矿奖励的机会。如图。所示,钱包一和钱包二为攻击者所产生的两个钱包,托管电子钱包为攻击者在托管机构的存款钱包。攻击者通过控制全节点 A 和全节点 B 来发起 Vector76 攻击，其主要的程如下。</p>
<p><img src="/img/blockchain_sec/6_40.png" alt=""></p>
<p>(1)攻击者通过两个钱包客户端来创建起两个分支，即分支 1 和分支 2。在分支1中,钱包一客户端发起交易向托管电子钱包要求支取其中的数字货币(以 Token 表示)标识为交易1。攻击者将这笔交易创建后不进行广播。与此同时,在分支 2 中,攻击者利用钱包一向钱包二客户端发送同一 Token,标识为交易 2。<br>
(2)攻击者把交易 1打包进新创建的区块,并在分支1上继续挖矿,挖到区块后先不进行广播。<br>
(3)在分支1 具有一定优势后,攻击者通过全节点 A 将交易1 发送至网络,同时也通<br>
过全节点 B 发送交易 2,由于全节点 B 连接到更多节点,交易 2 会被优先确认。<br>
(4) 攻击者通过全节点 A 将包含交易 1的区块广播到网络中。<br>
(5) 托管机构假定在收到一次确认后就立刻支付 Token。<br>
(6)攻击者在收到 Tken 后直接卖换取现金,由于在网络中最终被确认的是交2,因此交易 1成为无效交易,从而实现 Vector76 攻击。</p>
<h2 id="第9章-网络层安全">第9章 网络层安全</h2>
<h3 id="网络层安全概述">网络层安全概述</h3>
<p>区块链网络层的主要功能是为共识层提供可靠、对等和安全的网络结构及通信环境。通常恶意者对网络层发起攻击的主要目的包括去匿名性和获取经济利益。针对去匿名性的手段包括收集用户线上、线下的信息分析出用户的交易流向,找出用户真实身份信息。攻击网络层达到获取经济利益的目的主要是通过阻断节点与正常区块链网络的通信连接实现的,使得正常节点收到异常信息或错误信息,进而影响交易数据的正确性。网络层的安全风险与网络的拓扑结构、网络节点(用户)行为以及通信策略等因素相关,主要分为 3 个层面的安全问题:点对点(P2P)网络、传播机制和验证机制。</p>
<p>(1) P2P 网络: 点对点网络是指两个或多个对等节点之间直接共享文件的网络架构,在区块链网络中各个节点无主次之分。由于区块链数字加密货币交易的需要,节点之间会在区块链 P2P 网络中传播自身 P 地址等信息。安全性不高的节点很容易受到攻击者的直接攻击从而带来隐私数据的泄露。目前存在多种威胁网络层安全的攻击方式,如日蚀攻击、边界网关协议(BordeGateway Protocol,BGP)劫持攻击、窃听攻击和拒绝服务攻击等,同时也引发了不少安全事故。例如,2018 年 3 月,闪电网络由于遭受拒绝服务攻击而导致大量节点下线。</p>
<p>(2)传播机制:指建立连接的节点之间进行广播通信。在区块链网络中每个新加人的节点都需要先与网络中现有的其他节点进行通信以获得在网络中广播区块链相关信息的资格。当收到来自其他节点的信息后,会按照约定的机制验证信息,最后将确认无误的信息进行广播转发。针对传播机制常发起的攻击方法包括交易延展性攻击等,2014 年 8 月,Silk Road 2 因遭到交易延展性攻击而引起了严重的经济损失最终导致价值 260 万美元的比特币被盗。</p>
<p>(3)验证机制:由于数字签名的完整性和不可抵赖性两个特点满足区块链验证机制的需求,因此选择数字签名作为区块链的验证机制。验证机制的主要作用是保证节点传播和写人区块信息的真实性。攻击者对于验证机制最主要的攻击方式是绕过验证,在比特币中就曾发生过此类攻击带来的安全事故。2010 年 8 月,攻击者在第 74 638 个比特币上创建了一笔恶意交易,导致接近 2000 亿个比特币被非法发送到两个比特币地址。后来发现是攻击者利用大整数溢出漏洞,绕过了节点的有效性验证。</p>
<p>作为区块链的底层之一,网络层的安全性十分重要,区块链网络层安全目标包括匿名性和抗 DoS 攻击。此外,对于攻击者,在网络层中发起攻击一般需要事先知道网络的拓扑结构,因此网络的拓扑结构信息通常会被保护起来使得攻击者难以获取。即使攻击者可以在不知道网络拓扑结构的前提下发起攻击,但这种情形下需要耗费更多的资源来完成攻击过程。总体而言,网络层中主要的安全目标可以围绕 3 方面:匿名性、抗 DOS 攻击、拓扑结构隐藏。</p>
<p>接下来将介绍网络层中几种常见的攻击形式,包括拒绝服务攻击、日蚀攻击、BGP 劫持攻击、女巫攻击等,此外还会对网络层攻击的防御手段进行介绍。</p>
<h3 id="网络层安全威胁">网络层安全威胁</h3>
<p>近年来,发生在网络层的安全事故数量在逐年上升。主要的安全事件如表 9.1 所示，其中 DDoS 攻击是典型的攻击形式,攻击者针对交易所、矿池和区块链应用系统等进行攻击,导致服务中止,甚至可能导致区块链网络的安全性受到损害。2014 年,攻击者采用DDoS方式对 LocalBitcoins 交易所发起了大规模攻击,导致其服务停止 40 分钟Blockchaininfo 服务平台遭受 DDoS 攻击,导致服务中断,用户无法正常访问;AntPool、CKPool和 <a target="_blank" rel="noopener" href="http://GHash.io">GHash.io</a> 等矿池也遭到了 DDoS 攻击,导致矿池服务中断。</p>
<p>网络层中主要的安全威胁来自 P2P 网络、传播机制和验证机制这 3 个区块链网络层机制中存在的安全漏洞,例如,P2P 网络中的 DDOS 攻击,传播机制中交易延展性攻击,验证机制中整数滥出漏洞。网络层中的攻击通常是应用层中发生安全问题的根源,例如恶意者通过发起 Sybil 政击和DDoS 攻击切断用户与正常区块链网络的联系，造成可能的双重支付攻击,进而获取经济利益。</p>
<h4 id="拒绝服务攻击">拒绝服务攻击</h4>
<p>拒绝服务(Denial of Service,DoS)攻击的定义是: 攻击者故意地利用网络协议实<br>
的缺陷或直接通过暴力手段耗尽被攻击对象的资源,使得攻击对象无法提供正常服务行为。采用这样的手段,不仅可以使得目标计算机或网络无法提供正常的服务以及资源访间,还可以让目标系统的服务停止响应甚至崩溃。在实际情况中,由于攻击者所面临的网络带宽限制问题,较小的网络规模或者较慢的网络速度可能导致攻击者无法发出过多的请求。于是,攻击者可能使用两个或两个以上的物理终端向网络上的一个或多个目标系统发起拒绝服务攻击,实现分布式拒绝服务(DDoS)攻击。如图 9.1 所示,攻击者通过控制网络一台傀儡设备,攻击与之相连的其他设备,使其在攻击者的控制下,利用多台傀儡设备同时向远程的其他服务器发起攻击,攻击者可以通过使网络过载、阻断用户访问系统或者在较短时间向系统提交大量请求使受害者超过负荷。根据统计,目前绝大多数的交易客户端都曾遭受过 DDoS 攻击。</p>
<p>具有代表性的 DoS 攻击的方式主要有以下 4 种。</p>
<h5 id="SYN-Flood-攻击">SYN Flood 攻击</h5>
<p>SYN Flood 攻击是拒绝服务攻击的一种。在正常的三次握手协议中,首先用户端会尝试与服务器建立 TCP连线,在这个过程当中,用户端与服务器端会交换的信息如下。</p>
<p>(1) 用户端传输 SYN 同步信息到服务器端,请求建立连线。<br>
(2)服务器响应 SYN-ACK 消息给用户端,表示应答。<br>
(3)用户端发送应答 ACK 给服务器端,建立连线。</p>
<p>如图 9.2 所示是 TCP 三次握手协议。<br>
如图9.3 所示,在 SYN Flood 攻击中,攻击者通过发送大量 SYN 请求给服务器端,由于服务器会不断响应,并相应地回复消息 SYN-ACK,但是攻击者不对接收到的信息进行回复，或者攻击者在 SYN 里采用假的 IP 地址对服务器端进行欺骗，让服务器发送 SYNACK 到攻击者伪造的虚假地址,这导致了服务器端不可能收到 ACK。当正常用户想要进行 TCP 连接时，服务器端就会由于无法响应,而拒绝服务。</p>
<p><img src="/img/blockchain_sec/6_41.png" alt=""></p>
<h5 id="UDP-Flood-攻击">UDP Flood 攻击</h5>
<p>UDP 是一种不需要使用任何程序建立连接来传输数据的无连接协议。针对该协议的攻击常见的情况是利用大量 UDP 数据小包冲击服务器。攻击者可发送大量的小 UDP包给目标主机,并且这些UDP 包的源IP 地址都是伪造的,由此可以实现 UDP Flood攻击。</p>
<h5 id="IP欺骗攻击">IP欺骗攻击</h5>
<p>IP 欺骗即攻击者用他人的IP 地址伪造成自己的IP地址,并用于欺骗目标主机。IP欺骗攻击建立在主机之间正常信任关系之上。例如,对于网络上的任意两台计算机 A 和B,假设 B可以利用远程登录工具,不需要口令验证就可以登录 A 主机。此时,主机 A和B之间的信任关系是基于IP 地址而建立，所以当攻击者冒充 B的IP 地址,就可以不需要任何口令验证,从而远程登录 A。这就是 IP 欺骗攻击的原理,其攻击的步骤如下。</p>
<p>(1)攻击者攻击被信任的主机,使其网络暂时瘫痪,以免对后续的 IP 欺骗攻击造成干扰。<br>
(2)攻击者为猜测ISN基值和增加规律需要连接目标主机的某个端口。<br>
(3)攻击者把其源地址伪装成被信任的主机,发送 SYN 消息包，向目标主机发起连接请求。<br>
(4)攻击者需要等待目标主机发送响应的 SYN-ACK 包给被信任的主机,此时攻击者可能无法看见目标主机是否已经响应,需要对响应时间进行预判。<br>
(5)攻击者把其源地址伪装成被信任的主机,向目标主机发送 ACK 消息包，此时为<br>
送的消息为预测的目标主机的 ISN+1。<br>
(6)攻击者与目标主机连接建立发送命令。</p>
<h5 id="Smurf攻击">Smurf攻击</h5>
<p>Smurf 攻击的原理是同时采用 P 欺骗以及 CMP 回复方法，目的是让目标系统被大量无意义的网络数据填满,使得目标系统拒绝其他主机的正常请求,并无法提供服务。</p>
<p>Smurf 攻击的具体过程:攻击者发送伪装的 1CMP 数据包，目的地址设为任意一网络的广播地址,源地址设为要攻击的目标主机。因此,网络上的所有收到此ICMP数报包的主机都将对目标主机发出一个回应数据包，目标主机在某一段时间内收到成千上万个数据包,使得被攻击主机崩溃,并且无法提供服务。</p>
<p>DDoS 攻击已发生在针对大型公司的 Web 服务器,例如银行、电商，甚至主要的政府和公共服务等生活场景中。不仅如此,任何设备、服务器,或者连接互联网的设备都可能是DDoS 攻击的潜在目标。近年来,随着加密货币的发展,加密交易所已成为 DDoS 攻击<br>
日益流行的目标。</p>
<p>如图 9.4 所示,2017 年 10 月 24 日,比特币黄金(Bitcoin Gold,BTG)作为新加密货币,已经正式从比特币区块链中分离出来,作为一种免费的开源软件项目。此项目之后就遭到了 DDoS 攻击,BTG 团队注意到每分钟有 1000 万次点击阻塞了其网络流量请求,最终导致其官方网站中断并拒绝服务多个小时。</p>
<p>尽管各类加密交易所已经成为 DDoS 攻击的主要目标之一,但是区块链的分布式特点为抵御 DDoS 和其他网络攻击提供了强大的保护。当任意多个节点无法通信或脱机时,区块链也能够保证继续操作和验证交易。当受干扰的节点设法恢复并恢复工作时,它们将重新同步并获取未受影响的节点提供的最新数据。因此,对于区块链网络,DDoS利其他网络攻击造成破坏的可能性要小得多。工作量证明(PoW)共识机制可确保所有网络数据均受到加密证明的保护,这使得要更改以前验证过的块变得不现实,因为更改比币区块链需要逐条记录地分解整个区块链结构。因此,针对区块链的拒绝服务攻击,至多只可能在短时间内修改最近的几个区块上的交易。此外,如果攻击者设法控制了区块链中超过 50%的网络节点用于执行 51%攻击(多数攻击),底层协议也会进行快速更新,便以响应攻击。</p>
<p>除了区块链网络本身的性质外,还可以通过一些策略来抵御 DDoS 攻击。</p>
<p>(1) 增强协议容忍性:当发生 SYN Flood 攻击时,能够让 TCP 中一些未完成的半打开连接被随机释放;增加 SYN Cache 和 SYN Cookie 功能，当发现或者怀疑有攻击存在时启用,这样的操作可以增加 DDoS 攻击的难度。<br>
(2)提高系统和网络的安全性:对网络进行流量控制,关闭不需要的服务或者端口定期对系统进行补丁更新,对端口进行扫描,可以及时发现异常流量情况,定期进行攻击测试和病毒防护。<br>
(3) 端口过滤:端口过滤包括两部分,即人口过滤和出口过滤。其中,入口过滤指的是合理排列、编写防火墙和路由器访问控制列表,可以用于合理过滤数据流量,并且要合理配置边界路由;出口过滤指的是配置用户网络的边界路由,使得源 IP 地址是非法的数据包可以被及时阻塞,以免流出外网。<br>
以上的防御策略需要根据网络的具体情况进行具体配置。</p>
<h4 id="日蚀攻击">日蚀攻击</h4>
<p>在区块链系统中,在一个节点与其他节点之间建立 TCP 连接需要消耗资源。在比特币场景中,为了减少对网络资源的消耗,节点对外连接的数量是有限的。具体地说,比特币节点可以接收 117 个对内连接、对外发起8 个连接。日蚀攻击的实施就是基于这一特点,这种攻击手段是通过占用受害者的点对点连接的间隙,使得该节点停留在一个隔离的网络中,这样的攻击让被攻击节点和实际的区块链网络中建立了一个中继,使得被攻击节点收到的消息都是来自攻击者设定的消息,而且这种攻击手段的成本非常低,只需要购买少量的云服务来构造一个僵尸网络就可以实施这种攻击。如图 9.5所示,攻击者节点成为受害节点连接 P2P 网络的唯一节点,将受害节点隔离到一个网络中阻止新的区块信息进人受害节点,攻击者可以成功以低于全网算力资源 50%的攻击能力进行 51%攻击。</p>
<p><img src="/img/blockchain_sec/6_42.png" alt=""></p>
<p>日蚀攻击是一种用于攻击分布式网络的常用攻击方式,比特币网络作为分布式节点网络的典型代表,成为日蚀攻击的主要目标。如图 9.5 所示,在日蚀攻击中,攻击者试图隔离并攻击特定用户,而不是攻击整个网络。日蚀攻击发起成功后,使潜在的恶意参与者能够隔离并随后阻止其目标获得真实网络活动和当前分类账本状态的真实情况。</p>
<p>在分布式网络中,不允许网络中的节点同时连接网络上的所有其他节点,因此,为了提高效率,分布式网络中的一个书点只连接其选择的其他节点组，这些节点组内的节点连接它们自己所在的节点组。正是因为有这样的特性,使得日蚀攻击成为可能。例加,辣市阿络申的一个节点有8个传出书点。恶意攻击者的目的是劫持该节点所有的传出接。实现此目标的难易程度因网络的构造规模和性质而异,但通常，攻击者必须控制机节点的循尸网络,并把相邻节点转化为潜在的攻击目标。下一次受害节点注销并董加入网络(重置其连接,并迫使它们找到要连接的新节点集)时,攻击者很有可能控制受害节点的所有连接。</p>
<p>截止 2018 年,已经有研究表明,比特币网络和以太坊网络均可能遭受日蚀攻击的影<br>
响。在区块链网络中,攻击者可以通过日蚀攻击的方式,逐步控制足够数量的 IP 地址,他得受害者和所有其他节点之间的有效连接断开,即对被攻击者进行垄断;在以太坊网统中,攻击者可以通过日蚀攻击的方式,垄断受害节点的所有输人和输出连接,从而将受节点与网络中其他正常节点隔离,这也导致了受害者无法查看正确的以太坊交易细节,击者可以诱骗卖家在交易其实还没有完成的情况下就将物品交出。</p>
<p>为了防止日蚀攻击,在以太坊网络中可以采用以下 4 种方式。</p>
<p>(1)进行随机节点选择,以太坊节点发现机制采用了 Kademlia 算法,它由分散式杂凑表进行实现,用于非集中式 P2P 计算机网络。Kademlia 算法用于规定网络的结构,以及规定通过节点查询进行信息交换的方式。Kademlia 的网络节点之间的通信方式为UDP。所有参与通信的节点通过一组数字进行身份标识,并且形成虚拟网。但是Kademlia 不会对新连接的节点进行随机化搜索，因此,攻击者可以创建由受害者选择的节点。将这种选择与分布在网络中的对等点随机化,将使攻击者更难猜测他们应该创建哪些节点来针对受害者。<br>
(2)对每个IP 地址或机器的节点数进行限制,这也是最容易解决的缺陷之一。<br>
(3)对节点进行信息存储,节点在遇到其他节点时会存储有关它们的信息，这样使得在节点离开并重新加人网络之后保持此信息可访问性，将确保它们可以在找到其他合法对等节点之前连接一些合法对等节点。<br>
(4)尽量增加节点连接数,尽管此数目不能为无穷大,否则会减慢网络速度,但是允许的连接节点越多,带来的优势是节点连接合法用户的可能性越大。</p>
<h4 id="BGP劫持攻击">BGP劫持攻击</h4>
<p>边界网关协议(BGP)是一种自治系统的路由协议,运行于 TCP 之上，作为互联网成的关键一环,可以用于处理不同自治系统之间路由信息的交换。BGP 是目前用来处理如同互联网大小的网络的协议,而且可以妥善处理好不相关路由域间的多路连接的协议因此BGP 被广泛应用于比特币网络中。BGP系统的主要功能是和其他的 BGP系统交换网络可达信息。网络可达信息包括列出的自治系统(AS)的信息。这些信息有效地造了AS互联的拓扑图并由此清除了路由环路,同时在 AS 级别上可实施策略决策。</p>
<p>BGP 劫持攻击是指攻击者通过恶意修改数据的传输路线来截取和篡改数据,劫持的过程好比攻击者恶意篡改一段高速公路上的路标,使汽车无法找到正确的出口。一般实现在区块链网络中运行 BGP,需要控制 BCP路由器,然后使用它给周围节点发送它有更短路径的通知,而其他节点收到通知后会把流量定向到这个 BGP 路由器中,由于这样的原理,攻击者可以通过错误地向路由宜布他们对某个 IP 地址组(称为 IP 前级)的所有权,但实际上攻击者并不拥有、控制或路由这个 IP 地址组,从而实现 BGP 劫持攻击。</p>
<p>如图 9.6 所示,AS3 的 BGP 路由器声明有到达的更短路径,导致本来应该从PC 端流向AS4 的服务请求信息被 AS3 的 BGP 路由器劫持。由于 BGP 持,区块链网络中的流量可能被非法监控和拦截。另外,BGP 劫持可以作为中间人攻击的中间步骤,用于把数据导向恶意节点，达到破坏区块链交易以及共识机制的目的。由于大多数节点都托管在少数互联网服务提供商(ISP)中,即 60%的流量都会经过这些少数的 ISP,这样的机制为BGP 劫持攻击的实现提供了可能性。</p>
<p><img src="/img/blockchain_sec/6_43.png" alt=""></p>
<p>具体而言,在 BGP 劫持攻击中,攻击者需要控制或者破坏连接一个 AS 和另一个 AS的启用 BGP路由器,这样的操作增加了 BGP 持攻击的难度。攻击者完成 BGP 劫持攻击需要以下两个步骤。</p>
<p>(1)攻击者需要为路由器提供一个更具体的路线,在其他 AS前宣布一个较小范围的 IP 地址。<br>
(2)AS的运营商或已经破坏 AS 的威胁者发布通知到更大的互联网的 BGP 路由<br>
器,为某些 IP 地址块提供更短的路由。</p>
<p>攻击者通过 BGP 劫持来实现路由误导或者拦截流量等目的。目前,在区块链网络中节点的流量一旦被控制,则有可能对整个网络造成巨大的影响,如共识机制、交易等各种信息被破坏。具体而言,攻击者可以利用 BGP 劫持,将区块链网络中的节点划分成两个或多个无法通信的独立网络,此时,区块链则会分叉为两条或多条并行链,然后即可在并行的分叉的链上进行消费或者转账,在 BGP 持攻击行为停止后,区块链会以最长的链为主链，进行重新统一,并将其他的分叉丢弃,使得被丢弃的链上的交易全部无效,这样的行为很可能导致双重支付的发生，造成双重支付攻击,如图 9.7 所示。</p>
<p>针对这些需要保护的区块链,建立其专用的网络,不再让互联网服务提供商代理网络。这个网络同样需要做到去中心化,减少被单点劫持发生的概率。同时需要设立算力监控中心,实时汇报全网算力变化,算法发生显著变化时则需要及时检查该节点和其他节点之间的通信。</p>
<p><img src="/img/blockchain_sec/6_44.png" alt=""></p>
<h4 id="女巫攻击">女巫攻击</h4>
<p>女巫攻击(Sybil Attack)是指攻击者可以通过少量节点伪装出大量的节点身份标记来欺骗在区块链网络中的其他节点,把数据备份到少量的真实节点中,从而只需要控制这些节点就能破坏系统的数据备份功能。在区块链中,每个节点可以拥有多重身份标签,击者利用这一特点来达到削弱控制系统中的数据备份的效用。换句话说,女巫攻击是在对等网络中的一种攻击,其中网络中的节点同时主动操作多个身份并破坏信誉系统中的权限(权力)。攻击的主要目的是在网络中获得多数影响，以在系统中执行非法(相对于网络中设置的规则和法律)行为。单个实体(计算机)具有创建和操作多个身份(用户账户、基于 IP 地址的账户)的能力。对于外部观察者,这些假身份似乎是直下的唯一身份。</p>
<p>针对区块链或文件传输网络的 Sybil 成功攻击将使不良行为者对网络进行不成比例地控制。如果这些伪造身份获得了网络的认可,它们可能代表各种建议进行投票或中断网络中的信息流。这些身份可能显示为不同的用户,但实际上都在某一方的控制下。-旦它们生成足够多的身份,会最终对网络产生控制性影响,而其他用户甚至都无法察觉<br>
这是女巫攻击的基础,它打开了许多潜在的攻击媒介,举例如下。</p>
<p>(1) 攻击者阻止来自其他方的交易,因为该攻击者控制着其他节点所连接的节点。<br>
(2)破坏私人交易,由于大多数节点已经被攻击者控制,因此可以告诉这些交易如何路由以及它们源自何处。<br>
(3) 主导角色仅传输他们创建的块,这会将其他块放置在单独的网络中(因此容易受到双重支付攻击)。</p>
<p>女巫节点可能围绕并尝试影响到达网络上其他节点的信息,从而逐渐影响分布式账本或数据库。常见的女巫攻击的类型主要有以下两种。</p>
<p>(1)在直接攻击中,诚实节点直接受到 Sybil 节点的影响<br>
(2)在间接攻击中,与 Sybil 节点直接通信的节点攻击诚实节点。由于该中间节点受到女巫节点的恶意影响,因此受到威胁。</p>
<p>比特币网络为了证明添加到区块链的任何区块的真实性,可以使用工作量证明(PoW)共识算法。这项工作需要大量的计算能力,这可以激励矿工做诚实的工作,而对错误的工作则没有激励作用。每个节点都将验证交易,如果块中包含错误的交易,则将其视为无效。由于矿工数量众多,在比特币网络中实际上很难实现一种称为 51%攻击的女巫攻击,对于一个组织,控制 51%的矿工是非常困难的。一般防止女巫攻击的方法主要有以下3种。</p>
<p>(1) 向不同成员赋予不同权力:这是基于声誉系统的。不同的声誉级别将分配给具有不同权限级别的成员。<br>
(2) 创建身份的成本:为防止网络中出现多个假节点,可以要加人网络的每个节点支付成本。<br>
(3) 验证身份:包含两种验证方式,即直接验证和间接验证。其中,直接验证是指对已经建立的成员验证网络的新加人者进行验证;间接验证是指既定成员将验证其他一些成员，这些成员进而可以验证其他新的网络加人者。当验证新加人者的成员由已建立的实体进行验证和确认时,相信新加人者是诚实的。</p>
<h4 id="窃听攻击">窃听攻击</h4>
<p>窃听攻击(Eavesdrop Attack)指攻击者利用区块链节点的标识与其 IP 地址进行关联来追溯用户的隐私信息,包括用户所处的居住地址等。例如,在比特币网络中,节点可以通过连接区块链中现有的服务节点来加人网络中,加人网络后节点获得一组入口节点以执行后续区块链交易。节点执行交易时,需要通过入口节点广播交易到区块链网络,攻击者可以通过监听人口节点来识别对应的用户节点。当用户节点通过这些入口节点将交易扩散到区块链网络后,攻击者通过对这些交易进行分析和对人口节点进行监听就可识别出某一交易是否是来自被识别的某一用户节点。</p>
<p>网络层是区块链网络结构中密不可分的一部分,因此,防御网络层面临的攻击也是一个重要的研究内容。目前,网络层的防御手段针对以下 3 方面:P2P 网络、传播机制和验证机制。其中,包括以下安全防御手段。</p>
<p>(1)恶意节点检测机制:在区块链公有链机制中任何节点都可以申请接入网络,其中可能存在恶意节点,虽然区块链中不能限制节点的接入,但可以引入恶意节点监测机制,对节点的行为进行检测,一旦发现节点在恶意搜集信息就申请把该节点加入黑名单。<br>
(2) 限制接人:在区块链私有链和联盟链中,为了保障节点的安全性,对于接入网络<br>
中的节点,必须先经过授权,没有得到授权的节点无法搜集链中的交易信息和区块信息。目前这种防御手段只适用于私有链和联盟链场景中,因为在公有链场景中不允许存在进行授权的节点。<br>
(3)数据加密传输:在 P2P 网络中,数据可以使用可靠的加密算法进行加密后再广播,这样就可以避免恶意节点随意截取更改网络中的数据。<br>
(4)完善数据验证机制:部署更新区块链相关代码时,要进行大量且完备的测试和安全审计工作,避免攻击者利用整数溢出、权限设置不当等漏洞绕开验证攻击。</p>
<h3 id="网络层隐私保护协议">网络层隐私保护协议</h3>
<p>在 9.2 节的介绍中可知攻击者在网络层发起攻击的主要目的之一是为了对用户去器名性,来获取用户的身份隐私。在比特币系统中隐私性受到威胁的主要原因在于用户常用的交易地址被探知,使得攻击者可以有规律地追溯用户之间的联系。例如，假如一个交易包含来自同一个用户的多个输人,攻击者可以利用这一特征来跟踪比特币的流向以及地址之间的联系,最后将地址与现实中的用户身份联系起来,在某种程度上打破了匿名性。为了解决区块链在身份隐私保护方面的问题,相应的隐私保护技术被提出,其中，经典的解决方案包括混淆协议、基于零知识证明的隐私保护方案。混淆协议是网络层中进行隐私保护的主要方案之一,目前包括 MixCoin、CoinJoin 和 CoinShuffle。MixCoin 是比特币系统最早的混合方案,通过引入第三方将满足固定金额条件的用户交易进行混合，是一种中心化的混淆方案。具体地说,假设同时存在多笔交易,每组交易的用户只有一个输人地址和输出地址,MixCoin 为了将这一组交易进行混淆,会依托一个第三方服务器来完成混淆过程,不可避免地会存在中心化带来的风险和威胁,而另外两种协议(CoinJoin 和CoinShuffle)属于去中心化的混淆方案。本节将从特性、流程等方面来介绍这两种方案。</p>
<h4 id="混淆协议-CoinJoin">混淆协议 CoinJoin</h4>
<p>在软件工程领域,有一种针对程序代码进行隐私保护的技术，称为程序混淆(Program Obfuscation)。为了避免攻击者恶意阅读程序源代码,提出使用程序混淆技术将源代码经过混淆使其不能被攻击者或者其他未获得有效授权的用户查看。通过这种方式避免攻击者对源代码进行反编译操作,这种方式帮助软件开发者保护其软件及源代码的版权。程序混淆的这一功能使其成为软件知识产权保护的重要工具之一。</p>
<p>一般混淆过程首先要找到一种方式来混淆程序 P。通过混淆器(Obfuscator)产生另一程序 O(P)=Q,其中 P和Q在相同的输入情况下虽然输出相同但是 Q不会泄露任何与 P 构造有关的信息。这一特性帮助 Q 在将密码等私密信息隐藏在序结构内部并且程序中可以在隐私保护的状态下使用这些信息。通俗地说,程序混淆就是将一个程序代码通过某种方式生成另一个不同的程序,但是两个程序在使用相同输入时也能够得到相同的输出结果。</p>
<p>多年来研究者一直致力于对程序混淆的研究,其中,美国加州大学的 Sahai 教授等人在研究中证明了对于普遍功能程序的完美混淆的不可实现性,同时提出了另一种混淆相关的概念，即不可区分混淆(Indistinguishability Obfuscation,IO)。混淆的主要特性包括以下3个。</p>
<p>(1)功能保持:原电路与混淆后电路的功能能够保持一致。<br>
(2)多项式递减:原电路的运行时间的多项式大小大于经过混淆后的电路。(3)虚拟黑盒特性:对比于给出电路黑盒人口的情况,混淆电路的有效计算结果将与其保持一致。</p>
<p>不可区分性混淆技术能够应用在智能合约中保护智能合约代码的隐私。由于不可区分混淆技术强大的功能,使其受到密码学界以及工业界的广泛研究。混淆器是使用混合协议(Mixing Protocol)来混淆交易资金去向的匿名服务提供者。在混淆过程中，用户的资金被分成较小的部分。这些部分随机与其他用户的部分随机混合,最终将会得到全新的代币,流向接收地址。这有助于打破用户和其接收或支付的代币之间的联系。各种混清服务被大量使用,以增强系统的匿名性和无关联性。</p>
<p>为了保护交易数据的隐私性，比特币核心贡献者 Gregory Maxwell 提出了面向数字加密货币的混淆技术 CoinJoin,主要的思想就是分割用户输入地址和输出地址之间的关系,将用户的交易混合隐藏在多个交易中,进行混淆之后的用户交易,外部观察者无法看到地址和地址之间的对应关系,从而保护交易流向的隐私。在 CoinJoin 中聚集了同时产生的多个交易,每个交易的用户通过共同的签名来创建一笔交易，比特币系统将这些聚集的交易当作一笔交易,在这笔交易中包括若干不同用户的输人地址以及输出地址。对于外部观察者,整个交易里的单个输人地址与输出地址之间看不出明显关联,也就无法将某个用户的输人地址和输出地址联系起来,从而通过交易图对网络中的交易数据进行分析。</p>
<p>CoinJoin 协议中需要混淆交易参与者来生成一笔共同创建的交易,为了实现输入与输出的不可链接性,每个用户都独立地完成自己交易的签名,在所有用户完成签名之后CoinJoin 交易可被区块链网络认定有效。如图 9.8 所示,通过 CinJoin 协议之后,原本两个独立的交易生成了一笔混合的交易,这笔交易的输人地址包含原来独立交易的两个输人地址,在保证总的输出金额小于或等于输入金额的前提下(多余的金额被当作交易费),外界用户无法关联到 Bob 和 Carl的交易具体对应哪个输入地址(找零地址可以随机)。</p>
<p><img src="/img/blockchain_sec/6_45.png" alt=""></p>
<p>CoinJoin 可以为交易的匿名性提供保护,但同时也存在一些问题:首先，当某笔交易中参与混淆的用户比较少时,比特币仍存在被追踪的风险,例如在图 9.8 中,外界用户有比较大的概率猜出交易之间的对应关系。主要原因在于 CoinJoin 目前在区块链中并未作为主要的交易方式,截至 2018 年,该方案在比特币交易支付中的使用率仅为 4.09%由于在某一时间内可能只有少量用户产生交易到混合池中,这导致匿名集合较小无法达到有效的交易混淆作用。因为在交易数量少的集合里，仍然可以很容易推测交易的输人地址与输出地址之间的联系,并且通信开销增加。另外,CoinJoin引人一个第三方节点进行寻找参与混淆用户的过程,这样在一定程度上破坏了区块链去中心化的特性。参与浪滑的用户之间也无法保证都是诚实可信的,可能泄露对方的隐私。</p>
<h4 id="混淆协议-CoinShuffle">混淆协议 CoinShuffle</h4>
<p>CoinShuffle 主要思路是基于 CoinJoin 混淆来隐藏输人地址和输出地址之间的关系主要的区别在于引人了纠缠机制。不同于 CoinJoin,CoinShuffle 协议中不需要引人第方来辅助完成混淆过程。因此,CoinShuffle 被认为是一种允许去中心化的 CoinJoin 交易的技术,可以在没有第三方的参与下创建交易。同时,除了知道自己的输人和输出地址外,任何一方都不知道如何取消对 CoinJoin 的混合。此外,此协议能够与比特币很好地兼容,没有混合费用。</p>
<p>具体来说,CoinShuffle 协议中需要一组用户来共同生成一笔混合交易(MixingTransaction),每个用户都可以确认在这笔混合交易中自己所需要交易金额的有效性,否则可以不进行签名。每个参与者需要产生一次性密钥对，并把公钥广播出去CoinShuffle 协议主要包括 3 部分:公告(Announcement)、混淆(Shuffling)、交易验证(Transaction Verification)。</p>
<p>首先,在公告过程中,每个参与者需要生成新的比特币地址,在混合交易中指定其为输出地址。其次,参与者将新生成的输出地址以一种遗忘的方式进行洗牌,其类似于解密混合网络的方法。具体地说,每个参与者(如预先定义的洗牌顺序中的参与者 i)使用其他参与者j&gt;i 的加密密钥来创建其输出地址的分层加密。参与者依次进行洗牌,从参与者1开始:每个参与者希望从参与者-1那里得到参与者-1的密文。在接收时,每个参与者从密文中剥离出一层加密,添加自己的密文，然后随机地打乱结果集。参与者将经过打乱的密文集发送给下一个参与者 i+1。如果每个参与者都按照协议操作,最后一个参与者执行的解密将得到输出地址的无序列表,并将这个列表广播出去。在这个过程中,前一个参与者无法得知其他参与者的输出地址。</p>
<p><img src="/img/blockchain_sec/6_46.png" alt=""></p>
<p>如图 9,9 所示,假设存在 3 个参与方 A,BC 想要发起一个混合交易的 CoinShuffle协议。A 将使用C的公钥加密 A 的目的地址,并将此消息发送给 B。B 然后使用C的公钥加密 B的目的地址,并将这两个消息发送给 C。C 现在可以解密这两个消息并知道所有3个目的地址。C可以设置交易并签名,然后将其传递给 A 和 B 进行签名。只有当交易包含正确的目的地址时,各方才会签字。</p>
<p>CoinShuffle 具有安全性,健壮性并且与现有的比特币系统完美兼容。CoinShuffle坚持比特币的意识形态,是完全去中心化的,既不需要任何第三方,也不会为用户引人任何额外的匿名费用。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://timefy.github.io">水木时</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://timefy.github.io/posts/665ba237.html">https://timefy.github.io/posts/665ba237.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://timefy.github.io" target="_blank">水木时</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">学习记录</a><a class="post-meta__tags" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a></div><div class="post_share"><div class="social-share" data-image="/img/img/6.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/776f3c45.html" title="隐私保护相关"><img class="cover" src="/img/img/7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">隐私保护相关</div></div></a></div><div class="next-post pull-right"><a href="/posts/76189c5e.html" title="信息泄露"><img class="cover" src="/img/img/5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">信息泄露</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/2fa412f3.html" title="MathJax语法入门指南"><img class="cover" src="/img/img/10.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-09</div><div class="title">MathJax语法入门指南</div></div></a></div><div><a href="/posts/776f3c45.html" title="隐私保护相关"><img class="cover" src="/img/img/7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-06</div><div class="title">隐私保护相关</div></div></a></div><div><a href="/posts/79b9413.html" title="数学符号参考"><img class="cover" src="/img/img/11.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-16</div><div class="title">数学符号参考</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/img.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">水木时</div><div class="author-info__description">以其德，悟其道</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/timefy"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">以德立身，融道于行</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E7%BB%AA%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">第1章 绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.1.</span> <span class="toc-text">区块链本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.2.</span> <span class="toc-text">区块链技术是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E9%98%B6%E6%AE%B5"><span class="toc-number">1.3.</span> <span class="toc-text">区块链技术发展阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7"><span class="toc-number">1.4.</span> <span class="toc-text">区块链基础特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%95%E5%8F%91%E7%9A%84%E6%B7%B1%E5%88%BB%E5%8F%98%E9%9D%A9"><span class="toc-number">1.5.</span> <span class="toc-text">区块链引发的深刻变革</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6"><span class="toc-number">1.6.</span> <span class="toc-text">智能合约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E6%9C%89%E9%93%BE%E3%80%81%E7%A7%81%E6%9C%89%E9%93%BE%E3%80%81%E8%81%94%E7%9B%9F%E9%93%BE%E5%AF%B9%E6%AF%94"><span class="toc-number">1.7.</span> <span class="toc-text">公有链、私有链、联盟链对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B"><span class="toc-number">1.8.</span> <span class="toc-text">区块链技术演进</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E5%8C%BA%E5%9D%97%E9%93%BE%E6%9E%84%E9%80%A0"><span class="toc-number">2.</span> <span class="toc-text">第2章 区块链构造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E7%89%B9%E5%B8%81%E7%BD%91%E7%BB%9C%E6%A6%82%E8%A7%88"><span class="toc-number">2.1.</span> <span class="toc-text">比特币网络概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E7%9A%84%E5%85%B7%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">区块的具体结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%9A%BE%E5%BA%A6-%E7%9B%AE%E6%A0%87%E5%80%BC"><span class="toc-number">2.3.</span> <span class="toc-text">区块难度&#x2F;目标值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%98%93"><span class="toc-number">2.4.</span> <span class="toc-text">交易</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91"><span class="toc-number">2.5.</span> <span class="toc-text">区块链网络拓扑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.6.</span> <span class="toc-text">区块链网络协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%95%B0%E6%8D%AE%E4%BC%A0%E6%92%AD"><span class="toc-number">2.7.</span> <span class="toc-text">区块链数据传播</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E8%8A%82%E7%82%B9"><span class="toc-number">2.8.</span> <span class="toc-text">区块链节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80"><span class="toc-number">3.</span> <span class="toc-text">第3章 区块链密码学基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BE%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%80%A7%E8%B4%A8"><span class="toc-number">3.1.</span> <span class="toc-text">群的基本定义及性质</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BE%A4%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.1.</span> <span class="toc-text">群的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BE%A4%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">3.1.2.</span> <span class="toc-text">群的性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E9%99%90%E5%9F%9F"><span class="toc-number">3.1.3.</span> <span class="toc-text">有限域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%BE%A4%E3%80%81%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E7%BE%A4%E5%92%8C%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%98%A0%E5%B0%84%E7%BE%A4"><span class="toc-number">3.2.</span> <span class="toc-text">整数群、椭圆曲线群和双线性映射群</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%BE%A4"><span class="toc-number">3.2.1.</span> <span class="toc-text">整数群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E7%BE%A4"><span class="toc-number">3.2.2.</span> <span class="toc-text">椭圆曲线群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%98%A0%E5%B0%84%E7%BE%A4"><span class="toc-number">3.2.3.</span> <span class="toc-text">双线性映射群</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9B%B0%E9%9A%BE%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.</span> <span class="toc-text">密码学困难问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.1.</span> <span class="toc-text">离散对数问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0%E9%97%AE%E9%A2%98%E5%AE%9A%E4%B9%89"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">离散对数问题定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0%E9%97%AE%E9%A2%98%E6%80%A7%E8%B4%A8"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">离散对数问题性质</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.2.</span> <span class="toc-text">大整数分解问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CDH-DDH-%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.3.</span> <span class="toc-text">CDH&#x2F;DDH 问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BDH-DBDH-%E9%97%AE%E9%A2%98"><span class="toc-number">3.4.</span> <span class="toc-text">BDH&#x2F;DBDH 问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="toc-number">3.5.</span> <span class="toc-text">哈希函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-number">3.5.1.</span> <span class="toc-text">哈希函数定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E4%B8%BB%E8%A6%81%E6%80%A7%E8%B4%A8"><span class="toc-number">3.5.2.</span> <span class="toc-text">哈希函数主要性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">3.5.3.</span> <span class="toc-text">哈希函数安全性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8"><span class="toc-number">3.5.4.</span> <span class="toc-text">哈希函数主要应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91"><span class="toc-number">3.6.</span> <span class="toc-text">默克尔树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">3.7.</span> <span class="toc-text">布隆过滤器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D"><span class="toc-number">3.8.</span> <span class="toc-text">数字签名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.8.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D"><span class="toc-number">3.8.2.</span> <span class="toc-text">椭圆曲线数字签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EIGamal%E7%AD%BE%E5%90%8D"><span class="toc-number">3.8.3.</span> <span class="toc-text">EIGamal签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%AD%BE%E5%90%8D"><span class="toc-number">3.8.4.</span> <span class="toc-text">多重签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BE%A4%E7%AD%BE%E5%90%8D"><span class="toc-number">3.8.5.</span> <span class="toc-text">群签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E7%AD%BE%E5%90%8D"><span class="toc-number">3.8.6.</span> <span class="toc-text">环签名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.</span> <span class="toc-text">第4章 区块链共识协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAP%E5%8E%9F%E7%90%86"><span class="toc-number">4.1.</span> <span class="toc-text">CAP原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Paxos-%E7%AE%97%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">Paxos 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Raft-%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">Raft 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%9C%E5%8D%A0%E5%BA%AD%E9%97%AE%E9%A2%98%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="toc-number">4.4.</span> <span class="toc-text">拜占庭问题与算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B1%E8%AF%86%E5%9F%BA%E6%9C%AC%E9%9C%80%E6%B1%82"><span class="toc-number">4.5.</span> <span class="toc-text">区块链共识基本需求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BF%80%E5%8A%B1%E5%85%BC%E5%AE%B9"><span class="toc-number">4.5.1.</span> <span class="toc-text">激励兼容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E5%85%B1%E8%AF%86"><span class="toc-number">4.5.2.</span> <span class="toc-text">最终共识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BB%E8%B7%83%E6%80%A7"><span class="toc-number">4.5.3.</span> <span class="toc-text">活跃性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E6%80%A7"><span class="toc-number">4.5.4.</span> <span class="toc-text">正确性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%B8%8E%E9%9A%90%E7%A7%81"><span class="toc-number">5.</span> <span class="toc-text">第5章 区块链安全与隐私</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81"><span class="toc-number">5.1.</span> <span class="toc-text">区块链数据安全威胁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E9%9A%90%E7%A7%81%E6%B3%84%E9%9C%B2%E5%A8%81%E8%83%81"><span class="toc-number">5.2.</span> <span class="toc-text">区块链隐私泄露威胁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E7%9B%AE%E6%A0%87"><span class="toc-number">5.3.</span> <span class="toc-text">区块链安全目标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8"><span class="toc-number">5.3.1.</span> <span class="toc-text">数据安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E8%AF%86%E5%AE%89%E5%85%A8"><span class="toc-number">5.3.2.</span> <span class="toc-text">共识安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8"><span class="toc-number">5.3.3.</span> <span class="toc-text">智能合约安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8"><span class="toc-number">5.3.4.</span> <span class="toc-text">内容安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E5%AE%89%E5%85%A8"><span class="toc-number">5.3.5.</span> <span class="toc-text">密钥安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E9%93%BE%E4%BA%A4%E6%98%93%E5%AE%89%E5%85%A8"><span class="toc-number">5.3.6.</span> <span class="toc-text">跨链交易安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4"><span class="toc-number">5.3.7.</span> <span class="toc-text">隐私保护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E5%AE%89%E5%85%A8"><span class="toc-number">5.3.8.</span> <span class="toc-text">密码算法安全</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B1%82%E7%BA%A7%E5%88%86%E7%B1%BB%E5%AE%89%E5%85%A8"><span class="toc-number">5.4.</span> <span class="toc-text">区块链层级分类安全</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82%E5%AE%89%E5%85%A8"><span class="toc-number">6.</span> <span class="toc-text">第6章 应用层安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86%E5%AE%89%E5%85%A8"><span class="toc-number">6.1.</span> <span class="toc-text">密钥管理安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E6%94%BB%E5%87%BB"><span class="toc-number">6.1.1.</span> <span class="toc-text">字典攻击</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%92%9E%E5%BA%93%E6%94%BB%E5%87%BB"><span class="toc-number">6.2.</span> <span class="toc-text">撞库攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95%E6%94%BB%E5%87%BB"><span class="toc-number">6.3.</span> <span class="toc-text">键盘记录攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%BE%A7%E4%BF%A1%E9%81%93%E6%94%BB%E5%87%BB"><span class="toc-number">6.4.</span> <span class="toc-text">缓存侧信道攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A7%E5%B8%81%E6%9C%A8%E9%A9%AC%E6%94%BB%E5%87%BB"><span class="toc-number">6.5.</span> <span class="toc-text">货币木马攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E4%B8%AA%E4%BA%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%B4%A7%E5%B8%81%E6%9C%A8%E9%A9%AC%E6%94%BB%E5%87%BB"><span class="toc-number">6.5.1.</span> <span class="toc-text">针对个人计算机的货币木马攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E7%A7%BB%E5%8A%A8%E7%BB%88%E7%AB%AF%E7%9A%84%E8%B4%A7%E5%B8%81%E6%9C%A8%E9%A9%AC%E6%94%BB%E5%87%BB"><span class="toc-number">6.5.2.</span> <span class="toc-text">针对移动终端的货币木马攻击</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8"><span class="toc-number">6.6.</span> <span class="toc-text">客户端安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#API%E5%85%B3%E9%94%AE%E5%AF%86%E9%92%A5%E7%AA%83%E5%8F%96"><span class="toc-number">6.6.1.</span> <span class="toc-text">API关键密钥窃取</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E5%A4%A7%E9%87%8F%E7%AC%AC%E4%B8%89%E6%96%B9%E9%9B%86%E6%88%90%E7%9A%84%E5%A4%A7%E5%9E%8B%E5%B9%B3%E5%8F%B0"><span class="toc-number">6.6.1.1.</span> <span class="toc-text">具有大量第三方集成的大型平台</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.6.1.2.</span> <span class="toc-text">移动应用程序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#App%E4%BC%AA%E9%80%A0%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB"><span class="toc-number">6.6.2.</span> <span class="toc-text">App伪造漏洞攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%93%E9%B1%BC%E6%94%BB%E5%87%BB"><span class="toc-number">6.6.3.</span> <span class="toc-text">钓鱼攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%81%B6%E6%84%8F%E6%8C%96%E7%9F%BF%E6%94%BB%E5%87%BB"><span class="toc-number">6.6.4.</span> <span class="toc-text">恶意挖矿攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Web-%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB"><span class="toc-number">6.6.5.</span> <span class="toc-text">Web 注入攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB"><span class="toc-number">6.6.5.1.</span> <span class="toc-text">SQL注入攻击</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#XSS-%E6%94%BB%E5%87%BB"><span class="toc-number">6.6.5.2.</span> <span class="toc-text">XSS 攻击</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%B1%82%E5%AE%89%E5%85%A8"><span class="toc-number">7.</span> <span class="toc-text">第7章 智能合约层安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%8E%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6"><span class="toc-number">7.1.</span> <span class="toc-text">以太坊与智能合约</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%9D%8A"><span class="toc-number">7.1.1.</span> <span class="toc-text">以太坊</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B4%A6%E6%88%B7"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">账户</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A4%E6%98%93-2"><span class="toc-number">7.1.1.2.</span> <span class="toc-text">交易</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%87%83%E6%96%99"><span class="toc-number">7.1.1.3.</span> <span class="toc-text">燃料</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-2"><span class="toc-number">7.2.</span> <span class="toc-text">智能合约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%8F%8A%E7%BC%96%E8%AF%91"><span class="toc-number">7.3.</span> <span class="toc-text">智能合约基本语法及编译</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">7.3.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">7.3.2.</span> <span class="toc-text">以太坊虚拟机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83"><span class="toc-number">7.3.3.</span> <span class="toc-text">编译环境</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81"><span class="toc-number">7.4.</span> <span class="toc-text">智能合约安全威胁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%98%93%E9%A1%BA%E5%BA%8F%E4%BE%9D%E8%B5%96%E6%BC%8F%E6%B4%9E"><span class="toc-number">7.4.1.</span> <span class="toc-text">交易顺序依赖漏洞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3%E4%BE%9D%E8%B5%96%E6%BC%8F%E6%B4%9E"><span class="toc-number">7.4.2.</span> <span class="toc-text">时间戳依赖漏洞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%BC%8F%E6%B4%9E"><span class="toc-number">7.4.3.</span> <span class="toc-text">异常处理漏洞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6%E6%BC%8F%E6%B4%9E"><span class="toc-number">7.4.4.</span> <span class="toc-text">竞态条件漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB%E6%BC%8F%E6%B4%9E"><span class="toc-number">7.4.4.1.</span> <span class="toc-text">可重入攻击漏洞</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%A8%E5%87%BD%E6%95%B0%E7%9A%84%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6%E6%BC%8F%E6%B4%9E"><span class="toc-number">7.4.4.2.</span> <span class="toc-text">跨函数的竞态条件漏洞</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E6%93%8D%E4%BD%9C%E6%BC%8F%E6%B4%9E"><span class="toc-number">7.4.5.</span> <span class="toc-text">整数操作漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E9%94%99%E8%AF%AF"><span class="toc-number">7.4.5.1.</span> <span class="toc-text">算术运算错误</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E6%88%AA%E6%96%AD%E9%94%99%E8%AF%AF"><span class="toc-number">7.4.5.2.</span> <span class="toc-text">整数截断错误</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%94%99%E8%AF%AF"><span class="toc-number">7.4.5.3.</span> <span class="toc-text">类型转换错误</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%9D%97%E7%87%83%E6%96%99%E9%99%90%E5%88%B6%E6%94%BB%E5%87%BB%E6%BC%8F%E6%B4%9E"><span class="toc-number">7.4.6.</span> <span class="toc-text">基于块燃料限制攻击漏洞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#call-%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E6%BC%8F%E6%B4%9E"><span class="toc-number">7.4.7.</span> <span class="toc-text">call 注入攻击漏洞</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Solidity-%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B"><span class="toc-number">7.5.</span> <span class="toc-text">Solidity 安全编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E5%85%B1%E8%AF%86%E5%B1%82%E5%AE%89%E5%85%A8"><span class="toc-number">8.</span> <span class="toc-text">第8章 共识层安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E8%AF%86%E5%B1%82%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">8.1.</span> <span class="toc-text">共识层安全概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE%E5%AE%89%E5%85%A8%E5%81%87%E8%AE%BE"><span class="toc-number">8.2.</span> <span class="toc-text">共识协议安全假设</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PoW-PoS-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">8.2.1.</span> <span class="toc-text">PoW&#x2F;PoS 协议的安全性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BFT%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">8.2.2.</span> <span class="toc-text">BFT协议的安全性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%89%A9%E5%B1%95%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE"><span class="toc-number">8.3.</span> <span class="toc-text">可扩展共识协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%B7%B7%E5%90%88%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">8.3.1.</span> <span class="toc-text">基于混合方式的可扩展共识协议的安全性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%8F%98%E7%A7%8D%E9%93%BE%E7%BB%93%E6%9E%84%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">8.3.2.</span> <span class="toc-text">基于变种链结构的可扩展共识协议的安全性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%88%86%E7%89%87%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">8.3.3.</span> <span class="toc-text">基于分片方式的可扩展共识协议的安全性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E8%AF%86%E5%B1%82%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81"><span class="toc-number">8.4.</span> <span class="toc-text">共识层安全威胁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%BF%E8%B5%82%E6%94%BB%E5%87%BB"><span class="toc-number">8.4.1.</span> <span class="toc-text">贿赂攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%81%E9%BE%84%E7%B4%AF%E8%AE%A1%E6%94%BB%E5%87%BB"><span class="toc-number">8.4.2.</span> <span class="toc-text">币龄累计攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%BF%E8%B7%9D%E7%A6%BB%E6%94%BB%E5%87%BB"><span class="toc-number">8.4.3.</span> <span class="toc-text">长距离攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E7%A7%81%E6%8C%96%E7%9F%BF%E6%94%BB%E5%87%BB"><span class="toc-number">8.4.4.</span> <span class="toc-text">自私挖矿攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%87%8D%E6%94%AF%E4%BB%98%E6%94%BB%E5%87%BB"><span class="toc-number">8.4.5.</span> <span class="toc-text">双重支付攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#51-%E6%94%BB%E5%87%BB"><span class="toc-number">8.4.5.1.</span> <span class="toc-text">51%攻击</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A7%8D%E6%97%8F%E6%94%BB%E5%87%BB"><span class="toc-number">8.4.5.2.</span> <span class="toc-text">种族攻击</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E8%AE%A1%E7%AE%97%E6%94%BB%E5%87%BB"><span class="toc-number">8.4.5.3.</span> <span class="toc-text">预计算攻击</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8A%AC%E5%B0%BC%E6%94%BB%E5%87%BB"><span class="toc-number">8.4.5.4.</span> <span class="toc-text">芬尼攻击</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Vector76%E6%94%BB%E5%87%BB"><span class="toc-number">8.4.5.5.</span> <span class="toc-text">Vector76攻击</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%AE%89%E5%85%A8"><span class="toc-number">9.</span> <span class="toc-text">第9章 网络层安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">9.1.</span> <span class="toc-text">网络层安全概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81"><span class="toc-number">9.2.</span> <span class="toc-text">网络层安全威胁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB"><span class="toc-number">9.2.1.</span> <span class="toc-text">拒绝服务攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SYN-Flood-%E6%94%BB%E5%87%BB"><span class="toc-number">9.2.1.1.</span> <span class="toc-text">SYN Flood 攻击</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UDP-Flood-%E6%94%BB%E5%87%BB"><span class="toc-number">9.2.1.2.</span> <span class="toc-text">UDP Flood 攻击</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IP%E6%AC%BA%E9%AA%97%E6%94%BB%E5%87%BB"><span class="toc-number">9.2.1.3.</span> <span class="toc-text">IP欺骗攻击</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Smurf%E6%94%BB%E5%87%BB"><span class="toc-number">9.2.1.4.</span> <span class="toc-text">Smurf攻击</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E8%9A%80%E6%94%BB%E5%87%BB"><span class="toc-number">9.2.2.</span> <span class="toc-text">日蚀攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BGP%E5%8A%AB%E6%8C%81%E6%94%BB%E5%87%BB"><span class="toc-number">9.2.3.</span> <span class="toc-text">BGP劫持攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A5%B3%E5%B7%AB%E6%94%BB%E5%87%BB"><span class="toc-number">9.2.4.</span> <span class="toc-text">女巫攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AA%83%E5%90%AC%E6%94%BB%E5%87%BB"><span class="toc-number">9.2.5.</span> <span class="toc-text">窃听攻击</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4%E5%8D%8F%E8%AE%AE"><span class="toc-number">9.3.</span> <span class="toc-text">网络层隐私保护协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E6%B7%86%E5%8D%8F%E8%AE%AE-CoinJoin"><span class="toc-number">9.3.1.</span> <span class="toc-text">混淆协议 CoinJoin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E6%B7%86%E5%8D%8F%E8%AE%AE-CoinShuffle"><span class="toc-number">9.3.2.</span> <span class="toc-text">混淆协议 CoinShuffle</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/6cfa7377.html" title="《用概率思维提高胜算》_刘润"><img src="/img/img/13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《用概率思维提高胜算》_刘润"/></a><div class="content"><a class="title" href="/posts/6cfa7377.html" title="《用概率思维提高胜算》_刘润">《用概率思维提高胜算》_刘润</a><time datetime="2023-12-23T01:57:57.000Z" title="发表于 2023-12-23 09:57:57">2023-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/79b9413.html" title="数学符号参考"><img src="/img/img/11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数学符号参考"/></a><div class="content"><a class="title" href="/posts/79b9413.html" title="数学符号参考">数学符号参考</a><time datetime="2023-12-16T11:49:27.000Z" title="发表于 2023-12-16 19:49:27">2023-12-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2fa412f3.html" title="MathJax语法入门指南"><img src="/img/img/10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MathJax语法入门指南"/></a><div class="content"><a class="title" href="/posts/2fa412f3.html" title="MathJax语法入门指南">MathJax语法入门指南</a><time datetime="2023-12-09T13:28:18.000Z" title="发表于 2023-12-09 21:28:18">2023-12-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d9c2fff.html" title="《可塑的我：自我发展心理学的35堂必修课》_陈婕君"><img src="/img/img/9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《可塑的我：自我发展心理学的35堂必修课》_陈婕君"/></a><div class="content"><a class="title" href="/posts/d9c2fff.html" title="《可塑的我：自我发展心理学的35堂必修课》_陈婕君">《可塑的我：自我发展心理学的35堂必修课》_陈婕君</a><time datetime="2023-12-09T11:20:29.000Z" title="发表于 2023-12-09 19:20:29">2023-12-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/64e2ab84.html" title="《启发》_罗振宇"><img src="/img/img/8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《启发》_罗振宇"/></a><div class="content"><a class="title" href="/posts/64e2ab84.html" title="《启发》_罗振宇">《启发》_罗振宇</a><time datetime="2023-12-08T07:20:00.000Z" title="发表于 2023-12-08 15:20:00">2023-12-08</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2023 By 水木时</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>