<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>《区块链安全》_翁健 | 水木时</title><meta name="author" content="水木时"><meta name="copyright" content="水木时"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="网络空间安全专业核心教材体系建设一一建议使用时间  第1章 绪论 区块链本质  一份分布式的公共记账本 共享、可信的公共记账本  区块链技术是什么  从狭义角度来讲，区块链技术是一种基于时间顺序的分布式账本，它将数据区块通过首尾相连的方式组合而成一种链式数据结构，以密码学为基础来保障数据的不可篡改、不可伪造等特性。 从广义角度来讲，区块链技术是基于密码学、时间戳等技术来传输和验证数据，通过链式数">
<meta property="og:type" content="article">
<meta property="og:title" content="《区块链安全》_翁健">
<meta property="og:url" content="https://timefy.github.io/posts/665ba237.html">
<meta property="og:site_name" content="水木时">
<meta property="og:description" content="网络空间安全专业核心教材体系建设一一建议使用时间  第1章 绪论 区块链本质  一份分布式的公共记账本 共享、可信的公共记账本  区块链技术是什么  从狭义角度来讲，区块链技术是一种基于时间顺序的分布式账本，它将数据区块通过首尾相连的方式组合而成一种链式数据结构，以密码学为基础来保障数据的不可篡改、不可伪造等特性。 从广义角度来讲，区块链技术是基于密码学、时间戳等技术来传输和验证数据，通过链式数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://timefy.github.io/img/img/6.jpg">
<meta property="article:published_time" content="2023-12-05T09:16:13.000Z">
<meta property="article:modified_time" content="2023-12-23T02:00:27.992Z">
<meta property="article:author" content="水木时">
<meta property="article:tag" content="学习记录">
<meta property="article:tag" content="区块链">
<meta property="article:tag" content="网络安全">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://timefy.github.io/img/img/6.jpg"><link rel="shortcut icon" href="/img/inc.jpg"><link rel="canonical" href="https://timefy.github.io/posts/665ba237.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《区块链安全》_翁健',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-23 10:00:27'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/img.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/web%E5%AE%89%E5%85%A8"><i class="fa-fw fas fa-shield-alt"></i><span> web安全</span></a></div><div class="menus_item"><a class="site-page" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE"><i class="fa-fw fas fa-cubes"></i><span> 区块链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/%E9%98%85%E8%AF%BB"><i class="fa-fw fas fa-book"></i><span> 阅读</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent"><nav id="nav"><span id="blog-info"><a href="/" title="水木时"><span class="site-name">水木时</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/web%E5%AE%89%E5%85%A8"><i class="fa-fw fas fa-shield-alt"></i><span> web安全</span></a></div><div class="menus_item"><a class="site-page" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE"><i class="fa-fw fas fa-cubes"></i><span> 区块链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/%E9%98%85%E8%AF%BB"><i class="fa-fw fas fa-book"></i><span> 阅读</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《区块链安全》_翁健</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-05T09:16:13.000Z" title="发表于 2023-12-05 17:16:13">2023-12-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-23T02:00:27.992Z" title="更新于 2023-12-23 10:00:27">2023-12-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">46.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>141分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《区块链安全》_翁健"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><!-- # 《区块链安全》-翁健主编 -->
<p><strong>网络空间安全专业核心教材体系建设一一建议使用时间</strong><br>
<img src="/img/blockchain_sec/0_1.jpg" alt="教材体系建设"></p>
<h2 id="第1章-绪论">第1章 绪论</h2>
<h3 id="区块链本质">区块链本质</h3>
<ul>
<li>一份分布式的公共记账本</li>
<li>共享、可信的公共记账本</li>
</ul>
<h3 id="区块链技术是什么">区块链技术是什么</h3>
<ul>
<li>从<strong>狭义</strong>角度来讲，区块链技术是一种基于时间顺序的分布式账本，它将数据区块通过首尾相连的方式组合而成一种链式数据结构，以密码学为基础来保障数据的不可篡改、不可伪造等特性。</li>
<li>从<strong>广义</strong>角度来讲，区块链技术是基于密码学、时间戳等技术来传输和验证数据，通过链式数据结构来存储数据利用共识机制来生成和更新数据，并通过设计可编程智能合约来实现的一种全新去中心基础架构与分布式计算范式。</li>
</ul>
<h3 id="区块链技术发展阶段">区块链技术发展阶段</h3>
<p><img src="/img/blockchain_sec/1_1.jpg" alt="区块链技术发展阶段"></p>
<h3 id="区块链基础特性">区块链基础特性</h3>
<p>基于区块链的链式数据结构、分布式网络以及底层的密码学原理，使区块链具有去中心化性（Decentralization ）、公开透明性（Transparency）、集体维护性（Collective Maintenance） 、一致性（Consistency ）、不可篡改性（Tamper-Resistance）和匿名性（Anonymity）的安全特点。</p>
<ol>
<li>
<p><strong>去中心化性（Decentralization）：</strong>  去中心化性是区块链技术的最基本特征。区块链是一个点对点(Peer-to-Peer)的分布式网络架构,又称对等式网络,是无中心服务器、依靠对等用户之间进行信息交互的互联网体系。区块链不依赖于中心化节点的管理,实现了数据的分布式记录和存储。在传统的中心化网络中,对单个节点(或备份节点)实行攻击即可破坏整个系统,但是在区块链系统中,只要大多数节点能正常运行,少数节点被攻击或者失效都不会影响整个系统的运作。</p>
<p>如图 1.4 所示为区块链所采用的分布式点对点网络模型,节点之间采取相互连接、协同工作的方式，每个节点既作为服务端提供服务,也作为客户端使用服务。在网络层面上来看,每个节点之间的角色都是平等的，不存在特殊的中心节点,全网节点都具有均等的权利和义务。</p>
</li>
<li>
<p><strong>公开透明性（Transparency）：</strong> 早期设计区块链系统是开放式的，也就意味着其上的数据对任何人都是公开透明的,任何用户都可以通过公开接口查看链上的数据信息。同样地,数据的更新操作对全网用户也是透明的，因此用户可以自行地验证数据的真实性,这是区块链系统被信任的基础。</p>
</li>
<li>
<p><strong>集体维护性（Collective Maintenance）：</strong> 区块链系统中参与共识并存储所有最长链数据的节点称为全节点，区块链数据的安全性实际上是由这些全节点来维护的,其他具备计算和存储资源的节点也都可以参与进来,这样通过全节点来共同维护区块链账本的可靠性。</p>
</li>
<li>
<p><strong>一致性（Consistency）：</strong> 区块链中新产生的区块会被节点广播到网络中,实现全网数据同步。在等待一定周期之后,所有全节点都会存储包含该区块在内的最长链信息,即全网诚实节点具有关于记录数据的一致性视图。</p>
</li>
<li>
<p><strong>不可篡改性（Tamper-Resistance）：</strong> 区块链中的每个区块交易记录是在上一个区块生成之后,在该区块被生成之前所产生的记录,按照时间顺序逐步地写人账本中,这也保证了数据写入的有序性。同时，区块链中每个区块头中都记录着前一区块的哈希值,一旦某一区块的内容被更改,那么其后所有区块的记录都需要跟着变更,这将耗费巨大算力。因此,区块链数据库中不包含对被记录数据在已产生区块的更新、删除操作,只能创建新的交易并将其加入新的区块,即系统一且经过验证并添加至区块链后,其中的数据信息就会得到永久的存、法更改。另一方面,区块链系统中的全节点都保存了一份区块链的完整账本,因此分布式账本使得少粉用户持有了被更改过信息的假账本也不会对区块链整个系统的安全性有任何影响。在大部分节点保持诚实可信的前提下,整个系统以数量最多的账本作为最终的账本。该特点保证了基于区块链数据的有效性,即无法被篡改。</p>
</li>
<li>
<p><strong>匿名性（Anonymity）：</strong> 区块链系统中用户使用的是与真实身份信息无关的一串数字作为转账地址，虽然任何用户都可以从链中查到与该地址相关的交易信息,但是很难追溯到该地址所对应的实际操作人,这也就保证了区块链的匿名性。<strong>在比特币网络中,由于交易可以被链接,因此其匿名被称为伪匿名(Pseudo-anonymity)</strong>。在其后发展的区块链技术中，如 Zcash、门罗币,利用<strong>零知识证明</strong>的技术可以实现完全匿名的数字货币。</p>
<p>需要注意的是,虽然节点与节点之间无须公开身份,但区块链基于一套共识协议和签名、哈希算法实现了节点间的互信问题。这使得区块链节点间无须公开身份,利用一个与身份无关的交易地址在保证一定匿名情况下完成数据交换或交易操作。</p>
<p>区块链技术凭借公开透明、不可篡改及可追溯等特性,解决了数据共享开放与交易过程<br>
中存在的安全问题,为实现去中心化场景下的数据流通和价值交换提供了一套解决方案。</p>
</li>
</ol>
<h3 id="区块链引发的深刻变革">区块链引发的深刻变革</h3>
<ol>
<li>
<p><strong>金融领域</strong></p>
<ul>
<li><strong>去中心化的支付系统：</strong> 区块链技术通过去中心化的特性，使得跨境支付和本地支付更加便捷和高效。交易的确认不再需要传统金融机构的中介，降低了交易成本和时间。</li>
<li><strong>智能合约和金融衍生品：</strong> 区块链上的智能合约使得金融交易更加透明、安全，减少了欺诈和错误。智能合约还可以用于创建金融衍生品，如期权和合成资产。</li>
<li><strong>数字货币和加密资产：</strong> 区块链驱动了数字货币的发展，例如比特币和以太坊。这些数字货币可以作为替代传统货币的一种形式，提供更快速、低成本的跨境交易。</li>
</ul>
</li>
<li>
<p><strong>数据管理</strong></p>
<ul>
<li><strong>去中心化的数据存储：</strong> 区块链允许数据的去中心化存储，消除了单一点的故障，并提高了数据的可靠性和安全性。</li>
<li><strong>数据透明性和可追溯性：</strong> 区块链的不可篡改性确保了数据的真实性，每一次数据变动都被记录在区块中，使得数据的历史可追溯，增加了数据的透明性。</li>
</ul>
</li>
<li>
<p><strong>物联网应用</strong></p>
<ul>
<li><strong>设备身份和安全：</strong> 区块链可以为物联网设备提供唯一的身份标识，并通过智能合约确保设备之间的安全通信，防止未经授权的访问。</li>
<li><strong>数据共享和互操作性：</strong> 区块链技术可以提供一个安全的、去中心化的平台，促进不同物联网设备之间的数据共享和互操作性。</li>
</ul>
</li>
<li>
<p><strong>产品防伪</strong></p>
<ul>
<li><strong>溯源和真实性验证：</strong> 区块链可以用于建立产品的溯源系统，追踪产品的生产、运输和销售过程。通过在区块链上存储相关信息，可以实现产品真实性的验证，防止假冒伪劣产品的流通。</li>
</ul>
</li>
<li>
<p><strong>知识产权</strong></p>
<ul>
<li><strong>版权保护：</strong> 区块链可以记录数字内容的产权信息，确保创作者的权益得到保护。这有助于防止盗版和未经授权的复制。</li>
<li><strong>智能合约和版权交易：</strong> 利用智能合约，艺术家和创作者可以更直接地参与到版权交易中，确保他们收到应有的报酬。</li>
</ul>
</li>
<li>
<p><strong>智能合约</strong></p>
<ul>
<li><strong>自动化合同执行：</strong> 智能合约是一种基于区块链的自动化合同，能够自动执行合同中规定的条件。这降低了合同执行的成本，减少了争议的可能性。</li>
<li><strong>供应链管理：</strong> 智能合约在供应链中的应用可以自动化和优化整个流程，提高透明度、降低欺诈风险，并实现供应链各方之间的信任。</li>
</ul>
</li>
</ol>
<h3 id="智能合约">智能合约</h3>
<ol>
<li><strong>定义：</strong> 一套以数字形式定义的承诺，包括合约参与者可以在上面执行这些承诺的协议。</li>
<li><strong>特征</strong></li>
</ol>
<ul>
<li><strong>承诺（Commitment）：</strong> 承诺在这里指的是合约参与者协商后同意的各自的权利和义务，承诺的各项内容共同定义了某个特定的合约的本质与目的。</li>
<li><strong>数字形式（Digitally）：</strong> 数字形式是指合约必须以机器语言而非自然语来进行具体的实现，由计算机程序自动执行，且一般合约以代码形式执行后就不可更改。</li>
<li><strong>计算机协议（Computer Protocol）：</strong> 协议是技术实现，在选择的协议基础之上，合约承诺被最终实现，并且其执行的全过程被记录下来。</li>
</ul>
<h3 id="公有链、私有链、联盟链对比">公有链、私有链、联盟链对比</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>公有链</th>
<th>私有链</th>
<th>联盟链</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>参与者</strong></td>
<td>公众可加入，去中心化</td>
<td>受限制的参与者，通常由单一组织或实体控制</td>
<td>多个组织或实体共同控制</td>
</tr>
<tr>
<td><strong>权限控制</strong></td>
<td>完全去中心化，任何人都可以参与和验证交易</td>
<td>高度集中化，由单一组织或实体掌控</td>
<td>中度去中心化，由多个组织或实体共同控制</td>
</tr>
<tr>
<td><strong>共识机制</strong></td>
<td>公开的共识机制（例如工作量证明、权益证明）</td>
<td>通常由中心化的共识机制（例如拜占庭容错）控制</td>
<td>多方共同控制的共识机制（例如拜占庭容错或权益证明）</td>
</tr>
<tr>
<td><strong>隐私性</strong></td>
<td>相对较低，所有交易对公众可见</td>
<td>高，仅授权的参与者能够查看和验证交易</td>
<td>中，由参与方确定信息的共享程度</td>
</tr>
<tr>
<td><strong>效率</strong></td>
<td>相对较低，因为需要通过共识达成一致</td>
<td>相对高，因为参与者较少，交易速度更快</td>
<td>取决于联盟链的具体设计，通常在公有链和私有链之间</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>高，由去中心化的共识机制保障</td>
<td>由集中化的参与者和权限控制提供较高的安全性</td>
<td>中，取决于共识机制和参与者的信任度</td>
</tr>
<tr>
<td><strong>特性记账权</strong></td>
<td>所有参与者均具有相同的记账权</td>
<td>由中心化的参与者拥有记账权</td>
<td>由多个共同控制的参与者共享记账权</td>
</tr>
<tr>
<td><strong>激励机制</strong></td>
<td>通常通过代币激励，如比特币和以太坊</td>
<td>可以由中心化机构提供激励，也可以采用其他机制</td>
<td>取决于具体设计，可能结合公有链和私有链的激励机制</td>
</tr>
<tr>
<td><strong>中心化程度</strong></td>
<td>完全去中心化</td>
<td>高度中心化</td>
<td>中度去中心化</td>
</tr>
<tr>
<td><strong>突出特点</strong></td>
<td>匿名性、公开性</td>
<td>高度隐私、集中化控制</td>
<td>多方参与、中度隐私、共同控制</td>
</tr>
<tr>
<td><strong>承载能力</strong></td>
<td>通常较低，因为要处理大量的公开交易</td>
<td>相对较高，因为面向特定组织或实体</td>
<td>取决于联盟链的设计和规模，通常介于公有链和私有链之间</td>
</tr>
</tbody>
</table>
<h3 id="区块链技术演进">区块链技术演进</h3>
<p><strong>1.侧链技术（Sidechain）</strong><br>
2012 年,侧链的概念首次出现在比特币聊天室中,它是为了解决如何改进比特币协议、增加新的功能模式。2014 年以来,已经出现了很多具有新功能的区块链,许多与比特币竞争的数字货币,如莱特币、狗狗币等竞相迅猛发展。比特币的开发团队为了减少这些竞争币给比特币带来的影响,开始计划升级比特币的功能。他们考虑到直接在比特币链上进行功能添加有一定的风险,因为一旦新功能在实践中发生软件故障,已运行的比特币网络将会面临不可预测的潜在安全问题。此外,由于比特币本身的特性,如果要对其进行较大规模的改动,需要获得多数比特币矿工的支持。但是,在全球范围内获得多数比特币矿工的同意显然十分困难,出于对这些现实因素的考虑,比特币核心开发者便提出了侧链技术。</p>
<p>一方面,侧链技术最重要的作用就是支持用户去访问和使用新的服务。基于侧链技术,比特币可以作为一种存储货币,在侧链上开发和设计新的功能,以此来提升比特币的竞争力。例如,用户可以通过比特币从本区块链网络转移到另外的区块链网络进行使用，利用其他区块链网络的隐私特性、智能合约以及高效的交易处理功能来弥补比特币网络的不足。另一方面,新功能的添加通过侧链技术完成以后,即使由于安全升级导致侧链异常,主链也不会受到任何的影响,仍然可以正常运行,这也是侧链技术所带来的突出优势。</p>
<p>从本质上来看,侧链技术是一种跨区块链网络的解决方案,能够实现将数字资产从第一个区块链网络转移到第二个区块链网络,之后又可以在某个时间节点将该数字资产从第二个区块链网络安全地转回第一个区块链网络,如图 1.6 所示。通常来说，第一个区块继被称为主区块链或者主链,第二个区块链就被称为侧链。这种数字资产在不同区块18为了实现侧链技术,几位比特币的核心开发者,Adam Back、Matt Corallo 等人共同链之间进行安全转移的技术为区块链应用提供了新的发展空间。发起创立了Blockstream公司,明确了侧链技术的协议实现及方案细节。最初开发设计的侧链技术,一般主链专指比特币区块链网络，随着技术的更新发展,主链同样也可以是任何正式上线运行的区块链网络。</p>
<p><img src="/img/blockchain_sec/1_2.jpg" alt="主链和侧链"></p>
<p>严格来说,侧链并非区块链的一种类型,它只是在区块链的现实应用过程中,开发者对区块链的一种功能扩展,因此也不能特指某一个区块链,而是所有遵守侧链技术的区块链网络的通称。侧链可以被理解成一个独立的区块链网络,侧链上的数据及运行程序也是与主链相互独立的。因此,它在运行过程中并不会增加主链的负担,在解决数据过度膨胀的问题上,不失为一种有效的手段。</p>
<p>侧链的实现主要基于双向锚定(Two-Way Peg,2WP)方式。基于 2WP 技术,数字资产在主链中将被锁定起来,同时等价的数字资产将会在侧链中得到释放。相应地，当需要对侧链中的数字资产进行锁定的时候,主链中等价的数字资产也会被释放出来。2WP 实现过程中的主要挑战在于如何兼容主链,保证侧链协议的运行不会对主链的正常运行流程产生影响。</p>
<table>
<thead>
<tr>
<th>作用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>扩展性</strong></td>
<td>通过使用侧链，在不影响主链的情况下扩展区块链网络的处理能力。</td>
</tr>
<tr>
<td><strong>定制化应用</strong></td>
<td>允许创建适用于特定用途的自定义区块链，满足特定企业或组织的需求。</td>
</tr>
<tr>
<td><strong>隐私保护</strong></td>
<td>提供更高级别的隐私保护，通过侧链实现特定的隐私功能，避免直接影响主链。</td>
</tr>
<tr>
<td><strong>交互操作性</strong></td>
<td>有助于不同区块链网络之间的互操作性，通过创建支持跨链通信的侧链。</td>
</tr>
<tr>
<td><strong>新型协议和功能实验</strong></td>
<td>用于测试和实验新的区块链协议和功能，而不会影响主链的稳定性。</td>
</tr>
<tr>
<td><strong>资产跨链转移</strong></td>
<td>允许在不同的链上传输和交换资产，解决数字资产互通性的问题。</td>
</tr>
</tbody>
</table>
<p>侧链技术则是将交易处理转移到一个与主链并行的区块链上。侧链与主链之间可以通过桥接技术进行连接，以实现资产的转移。侧链可以根据需要设计不同的参数，以满足不同的扩容需求。</p>
<p><strong>2.闪电网络（Lightning Network）</strong><br>
比特币作为最大的数字货币体系,每秒处理交易的数量为 7笔,每笔交易最终确认需要等待至少6 个块的时间，这样的处理效率显然无法满足现实应用的需求,与金融系统的交易速率更无法相比。为了解决比特币中存在的交易处理慢问题，闪电网络应运而生，它实际上也属于侧链技术的一种,通过在不同交易方之间建立一条链下可扩展的微支付通道,多方之间在链下完成频繁的双向交易操作,无须链上交易全网确认,显然会提升比特币交易处理的效率。</p>
<p>闪电网络模型如图 1.7 所示,假设 Alice 和 Bob 两人之间需要频繁地进行交易，显然这将会产生高昂的交易费用,并且,其交易效率也难以满足一般的商业场景的要求。基于以上困难,两人通过闪电网络开启一条微支付通道。在开启支付通道中,Alice 和 Bob 各自将 10 个比特币转给一个由双方共同控制的地址账户,该地址账户的共同管理可以通过多重签名技术来实现。开启支付通道的过程是一笔普通的交易上传到比特币网络当中日交易最终确认,则双方可以在链下的支付通道里进行频繁的交易操作。直至双方确认不会再发生交易，想通过类似提现的方式来获取最后的金额,则可共同约定关闭该通道。</p>
<p><img src="/img/blockchain_sec/1_3.jpg" alt="闪电网络模型"></p>
<p>在闪电网络中,主要通过 RSMC(Recoverable Sequence Maturity Contract)和HTLC(Hashed TimeLock Contract)两种方法来解决链下交易中面临的一些安全问题，RSMC 称为可撤销的顺序成熟度合同,支持了双向的支付通道,开始时两方都向共同地址中发送一笔资金进行锁定。通过设定惩罚机制,假定某一方中途退出,则需要等待一段确认时间。而另一方确认对方有非法操作,可无须等待立即拿走所有的资金,以此来保证交易的双方不出现抵赖或者反悔行为。在微支付通道中的每一步交易操作都由密码学技术来保证执行的有效性。</p>
<p>RSMC实现了两方之间的双向支付通道(Alice 和 Bob),但存在的一个问题是,如果任意的两人之间进行交易都需要相互协商来建立一条支付通道，显然不是很高效的。为了支持不同用户在无须建立支付通道的前提下实现链下的安全交易,就产生了 HTLCHTLC称为哈希时间锁合约,它是为了支持在不同节点之间在微支付通道交易而产生的。假设 Alice 和 Bob 之间存在一条支付通道,Bob 和 Carl之间也存在这样一条支付通道。当Alice和 Carl之间需要进行交易时,可以无须再建立一条新的通道,基于 HTLC就可以实现 Alice 和Carl之间的交易操作:Alice 通过 HTLC 锁定一定金额的资金 y,同时选取一个秘密参数值,通过设定一定的时间期限 T,如果 Bob 能够在 T 时间内向Alice 出示 H(z),Bob 就能获得这笔资金;如果在约定 T时间内无法提供 H(x),则这笔金额将被自动解锁并返还给 Alice。同理,Bob和 Carl之间的交易操作也可以按照此过执行,这样Alice和Carl 两方之间完成链下的 HTLC交易操作,如图 1.8 所示。</p>
<p><img src="/img/blockchain_sec/1_4.jpg" alt="闪电网络模型"></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>RSMC（Recoverable Sequence Maturity Contract）</th>
<th>HTLC（Hashed Time-Locked Contract）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>用途</strong></td>
<td>主要用于支付通道内部的资金管理和通道的关闭。</td>
<td>用于实现闪电网络中的跨支付通道的支付。</td>
</tr>
<tr>
<td><strong>合约类型</strong></td>
<td>二者间有共同点，是比特币脚本合约的一种。</td>
<td>具体实现了HTLC概念，是跨通道支付的基础。</td>
</tr>
<tr>
<td><strong>交易延迟</strong></td>
<td>RSMC具有相对较短的交易延迟，支持快速的资金锁定和解锁。</td>
<td>HTLC引入了时间锁，支付可能需要一些时间来完成。</td>
</tr>
<tr>
<td><strong>资金锁定和解锁</strong></td>
<td>RSMC允许通道内的资金被快速、灵活地锁定和解锁。</td>
<td>HTLC在支付开始前会锁定资金，支付完成后解锁资金。</td>
</tr>
<tr>
<td><strong>可撤销性</strong></td>
<td>RSMC支持支付通道的双方都能主动撤销未广播的交易，提供较强的可撤销性。</td>
<td>HTLC本质上支持原子交换，具有更强的可撤销性。</td>
</tr>
<tr>
<td><strong>冗余交易</strong></td>
<td>RSMC的撤销交易较为冗余，因为每次更新通道状态都需要新的撤销交易。</td>
<td>HTLC引入的Revocable Sequence Maturity Contract（Revocable RSMC）减少了冗余。</td>
</tr>
<tr>
<td><strong>支付追踪和解密</strong></td>
<td>RSMC的支付更易于追踪，因为没有对支付金额进行加密。</td>
<td>HTLC的支付通过哈希锁定，对支付金额进行了加密。</td>
</tr>
<tr>
<td><strong>隐私性</strong></td>
<td>相对较低，因为支付金额是公开的，可能泄露用户的交易信息。</td>
<td>相对较高，支付金额是加密的，提高了用户的交易隐私。</td>
</tr>
<tr>
<td><strong>典型应用场景</strong></td>
<td>通道内部的资金管理，通道的开启和关闭。</td>
<td>实现闪电网络中的跨支付通道的支付。</td>
</tr>
</tbody>
</table>
<p><strong>3.zk-SNARK（Zero-Knowledge Succinct Non-Interactive Argument of Knowledge）</strong></p>
<p>区块链技术实现了一套无须依赖可信机构的去中心化应用,所有的交易信息都需通过广播、验证和确认的方式最终被写人区块链,且生成的交易信息无法抵赖，也无法定。然而,这些交易详情是在众目腰瞬之下完成验证和确认的，这也意味着，交易的发肃者、接收者、接收时间、金额数量等信息都是公开的。然而,在很多的应用场景里，这些有易信息属于敏感信息,用户不愿对外公布,包括对区块链平台的维护者。那么，如何在即保证数据是真实、准确的情况下,又能同时保证对数据进行可验证呢? 基于零知识证明技术就可以被用来解决此问题。</p>
<p>20 世纪 80 年代初,S.Goldwasser,S, Micali 及 c.Rackoff 等人提出了零知识证明的概念,他们设想在一些特殊场景之下,证明者需要让验证者相信某个论断是正确的，但是出于隐私性的考虑,却又无法将证明的对象直接呈现给验证者,而零知识证明旨在使得证明者在不向验证者提供任何隐私信息的情况下,达到证明者的目的。在零知识证明协议过程中,可能涉及两方或更多方完成一项任务所需采取的一系列步骤。证明过程中证明者在不向验证者泄露任何关于被证明消息的信息的情况下,向验证者证明并使其相信自己知道或拥有被证明消息。交互式零知识证明是指在证明过程中,证明者和验证者之间必须经过交互才能完成的零知识证明,与此相反,在定理证明过程中证明者和验证者不需要交互的零知识证明被称为非交互零知识证明。零知识证明是密码学为我们提供的强大利器之一。如果将零知识证明用于安全验证,许多场景下的数据安全问题可以得到有效解决。</p>
<p>零知识证明是一种密码学技术，它可以让一个人向另一个人证明自己知道某个秘密，而不需要透露这个秘密本身。零知识证明具备以下三个特性：</p>
<ul>
<li><strong>完备性</strong>：如果证明方和验证方都是诚实的,并且它们都遵循证明过程的每一步来进行正确的计算,那么这个证明一定会是成功的,验证方一定会接受证明方。</li>
<li><strong>可靠性</strong>：任何其他人都无法假冒证明方身份使得一个伪造的证明成功被验证方接受。</li>
<li><strong>零知识性</strong>：证明过程执行完之后,验证方只获得了“证明方拥有这个知识”的信息,而没有获得关于这个知识本身的任何信息。</li>
</ul>
<p>在零知识证明过程中,存在两方角色: 证明者(Prover)、验证者(Verifier)。下面以一个例子来说明零知识证明技术。图 1.9 所示的是一个山洞示意图,在山洞深处有一扇门。</p>
<p><img src="/img/blockchain_sec/1_5.jpg" alt="零知识证明示例"></p>
<p>只有知道咒语的人才能将其打开。证明者想向验证者证明,他知道打开这扇门的咒语,但 具不想当着验证者的面将门打开,否则咒语就会被验证者知道。那证明者如何实现这个过程呢? 证明者进人山洞里面,验证者随机地喊出从右边进人,证明者随即从右边进人从左边出来。无论验证者选择让证明者从左还是从右，只要证明者能从相对应的门走出来,则说明证明者确实知道打开门的咒语。而在这个过程中,证明者没有向验证者透露任何关于咒语的信息,在确保咒语隐私的情况下,向验证者证明了“我知道咒语这个事实。</p>
<p>另一个例子,有一个盲人手中拿了两个颜色不一样的圆球,一个正常人如何向这个盲人证明这两个圆球的颜色不一样? 并且这个正常人不能够向盲人透露球的颜色,也不能够找第三个人来参与。证明者(即正常人)要向验证者(即盲人)证明他知道球的颜色不一样,但盲人不能够知道其他任何信息包括球的颜色,以及不能够加入第三个人来帮助证明者证明球的颜色。那应该如何完成呢? 首先盲人每只手拿一个球,给正常人看过之后让他闭上眼睛,盲人可以选择交换两只手中的球或者不交换,然后让正常人睁开眼睛并说出盲人手中的圆球是否交换。经过多轮测试之后,如果盲人手中的球颜色不一样,那么正常人每轮都可以回答正确,这样就完成了零知识证明的过程。</p>
<p>这两个是零知识证明中的典型例子。在区块链中将零知识证明引人,可以实现在不需要泄露交易敏感信息的前提下实现对交易的有效性验证,这就是 k-SNARK。zk.SNARK 的全称是 Zero-Knowledge Succinct Non-interactive Argument of Knowledge.即零知识-简洁的非交互式知识证明。系统要求证明者在不透露自己敏感信息的前提下,向验证者(Verifier)证明其确实知道某个信息，而且是真实的。zk-SNARK 是一种简洁且非交互式的零知识证明,首先 k-SNARK 的构造必须简洁,简洁的零知识证明只需要毫秒就可以完成验证,证据(Proof)长度只有几百字节。在传统的交互式零知识证明构造中,证明者和验证者需要来回发送几轮消息才能完成验证,而非交互式零知识证明只需要证明者向验证者发送一次证据即可让验证者相信证明人的论断(Statement)是可信的。</p>
<p><strong>4.有向无环图（Directed Acyclic Graph，DAG）</strong><br>
为了解决区块链交易确认速率慢、资源消耗大的问题,有向无环图(Directed AcyclicGraph,DAG)技术被提出来。DAG 本质上是一种数据结构,同样属于分布式账本技术。与原有由区块组成的单链区块链不同,DAG 是由交易所组成的网络。DAG 中的交易在角色上类似于区块链的区块,这些交易被当作网络节点,共同组成了复杂的网络拓扑结构,如图1.10 所示。</p>
<p>DAG 是异步共识的,基于图的方式以交易本身作为基础单元进行数据存储,有效提升了区块链在存储和效率方面的性能,包括 DagCoin,IOTA,ByteBall 等在内的系统采用的是基于 DAG结构的区块链技术</p>
<p><img src="/img/blockchain_sec/1_6.jpg" alt="区块链结构与有向无环图"></p>
<h2 id="第2章-区块链构造">第2章 区块链构造</h2>
<h3 id="比特币网络概览">比特币网络概览</h3>
<p><img src="/img/blockchain_sec/2_1.jpg" alt="比特币网络概览"></p>
<h3 id="区块的具体结构">区块的具体结构</h3>
<p><img src="/img/blockchain_sec/2_2.jpg" alt="区块的具体结构"></p>
<h3 id="区块难度-目标值">区块难度/目标值</h3>
<ol>
<li><strong>区块计算公式</strong></li>
</ol>
<p>比特币的新目标值是由难度值决定的，难度值是一个指数形式的十六进制数。难度值的计算公式如下：</p>
<p>$$<br>
\text{target} = \text{coefficient} \times 2^{8 \times (\text{exponent} - 3)}<br>
$$</p>
<p>其中，<code>coefficient</code> 是一个十六进制数，<code>exponent</code> 是一个整数。</p>
<p>比特币的新目标值会根据系统的平均出块时间来动态调整，以保证每10分钟出一个区块。调整的规则如下：</p>
<ul>
<li>每2016个区块产生后会调整一次（大约2周14天）</li>
<li>调整的计算公式是：</li>
</ul>
<p>$$<br>
\text{新难度值} = \text{旧难度值} \times \frac{\text{最近2016个区块的真正时间}}{\text{最近2016个区块的预期时间}}<br>
$$</p>
<ul>
<li>最近2016个区块的预期时间，当然是：$2016 * 10min$。即：</li>
</ul>
<p>$$<br>
\text{预期时间} = 2016 \times 10 \text{分钟}<br>
$$</p>
<ol start="2">
<li><strong>哈希目标值</strong><br>
<img src="/img/blockchain_sec/2_3.jpg" alt="哈希目标值"></li>
</ol>
<h3 id="交易">交易</h3>
<ol>
<li>交易过程</li>
</ol>
<blockquote>
<p>一个地址的$UTXO（Unspent Transaction Output）$数值不能被分割花费，除非通过交易由该$UTXO$生成多个新地址的$UTXO$。</p>
</blockquote>
<p><img src="/img/blockchain_sec/2_4.jpg" alt="哈希目标值"></p>
<p>在比特币中,矿工只把验证有效的交易放入新的区块,同时,其他矿工在验证区块有效性时,也会验证交易的有效性,若该交易不是有效的,则该区块不会被接受。参与节点在验证交易过程中,除了需要验证交易数据结构的正确性外,还需要验证交易输入的所有权(见2.4节),以及检查输人的$UTXO$是否已经被花费过。之所以检查$UTXO$是否被花费是为了防止双重支付攻击。在现实世界中,1 元钱一旦花出去,不可能被重复花费然而数字形式的货币花费出去之后,很有可能再次被用来与其他人进行交易。区块链技术可以抵御双重支付攻击,这是由于区块链的每个全节点存有一个 $UTXO$ 数据库，可以通过该数据库来检查交易输人是否为未被花费的 $UTXO$。此外,区块链还提供了简单支付验证机制$(Simple Payment Verification,SPV)$,其他参与节点(如轻量级节点)也可以借助该机制对交易进行快速验证。具体方法是计算交易的哈希值和默克尔树根节点值并在必要时向全区块链参与节点请求构造默克尔树的中间节点的哈希值,即可验证该笔交易是否存在于历史区块中。</p>
<p>比特币地址的生成是通过对公钥进行双重哈希,它可以被公开用来接收 UTXO。公钥相对应的私钥则由用户秘密保存,它是有权花费对应地址 $UTXO$ 的证明。目前，比特币地址的格式被分为两种:发送到公钥地址的格式$(Pay-to-Pubic-Key-Hash,P2PKH)$和发送到脚本地址的格式$(Pay-to-Script-Hash,P2SH)$。下面主要介绍 $P2PKH$ 的生成方式,后一种格式与其类似。</p>
<p>比特币地址采取了基于 $Base58 $编码的方式来生成地址,主要是为了消除一些易混淆的字符。实现过程相比于其他的 $Base64$ 编码,在字符的选择上有一些细微的差别,它不包含字符$0、O、I$和$l$,以及$+$和$/$。如图 2.8 所示,首先,使用 $RIPEMD-160$ 哈希算法和$SHA-256$ 哈希算法计算版本号加上公钥的双重哈希结果。版本号指明了格式的类别，使用$0x00$ 表示前一种格式,$0x05$ 表示后一种格式,$P2PKH$的版本号为$3$。然后,将 $20$字节的双重哈希结果加上版本号通过两次 $SHA-256$ 哈希计算得到 $36$ 字节的校验码，用来检验地址的正确性。最后,只取校验码的前$ 4 $字节加上 $1$字节的版本号和 $20$ 字节的双重哈希结果通过$ Base58$ 编码得到 $26-35$ 个字符不等的地址。可以看出，经过如图 2.8 所示的计算步骤之后,生成的地址相比于公钥长度要短。</p>
<p><img src="/img/blockchain_sec/2_5.jpg" alt="比特币网络地址产生过程"></p>
<h3 id="区块链网络拓扑">区块链网络拓扑</h3>
<p>与比特币网络类似,大多数公有链采用了基于点对点$(Peer-to-Peer,P2P)$非结构化的网络拓扑结构来构建区块链网络。在该拓扑结构中,网络的各个参与节点被认为是资源对等的,共同提供网络服务。这种网络结构能够使一个区块链系统快速、随机化地组织网络,支持网络参与节点的频繁接入和断开,具有较高的容错性。对于联盟链和私有链它们的区块链网络的规模通常比公有链网络小,所以倾向采用全连接的网络拓扑结构总体而言,根据通信目的的不同,区块链节点之间的通信可以分为以下两种方式。</p>
<p>(1)为了维持节点与区块链网络之间连接的通信。通信内容包括索取其他节点的地址信息和广播自己的地址信息。当有新的节点加人区块链网络时,该新节点首先会读取种子节点的地址信息，然后向这些种子节点请求其相邻节点的地址信息,当新节点连接上这些相邻节点后,它继续向这些相邻节点请求更多的相邻节点地址信息并与其建立连接，直到节点的相邻节点数量达到稳定。节点加人区块链网络以后,各个节点会定期以 ping的方式确认其相邻节点是否可达,如果存在不可达节点,就使用新节点替代这些不可达节点。另外,节点也会定期向其相邻节点广播自己的地址信息,以确保新节点的信息被更多节点接收。</p>
<p>(2)为了完成区块链上层业务的通信。通常来说,通信的内容包括转发交易信息和同步区块信息(在这里,交易和区块是区块链中的数据结构,将在交易层介绍)。在转发交易信息方面,节点采用的是中继转发模式。具体来说,发送节点先向其相邻节点转发此交易,待相邻节点收到交易后,它们再转发给自己的相邻节点,并以这样的方式进行下去,直到将交易传输到整个区块链网络。在同步区块信息方面,节点采用的是请求-响应模式具体来说，一个节点可以向其相邻节点发送自己本地所保存的区块链高度,若该高度小于其相邻节点所保存的区块链高度,该节点就请求自己欠缺的区块;若大于其相邻节点所保存的区块链高度,则其相邻节点反向请求区块信息。在这种模式下,每个节点不断地和各自的相邻节点交换本地保存的区块信息,从而使整个网络中所有参与节点都同步存储一致的区块链信息。</p>
<h3 id="区块链网络协议">区块链网络协议</h3>
<p>一般来说,随机组织网络的网络协议主要有两种:<strong>基于 DNS 服务器协议和基于Kademlia 协议</strong>。本节就以一个新节点准备加人比特币网络时随机发现网络节点的例子来介绍这两种网络协议。对于基于 DNS 服务器协议的区块链网络来说,一个节点新加入时会首先去询问区块链系统中已经编好码的 DNS 服务器,得到一组随机化的已经存在于区块链网络的节点的 IP 地址,然后节点会将这些地址填充到它的对等节点连接列表中对于基于 Kademlia 协议的区块链网络来说,由于网络中的每个节点都维护了$160$个存有网络信息的哈希列表,一个新加人的节点可以获取任意网络节点中存储的节点信息,它通过向网络节点发送查询命令来填充自己的列表。由于随机化连接节点的方式可能存在某些对等节点的连接路径不是最优路径的问题，一些研究者提出了以连接最近节点来组成区块链网络架构的方法。</p>
<p>在比特币中,大多数的参与节点基于DNS服务器协议加人网络。通常情况下，参与区块链网络架构的方法。节点通过监听 $8333$端口来接收外来连接,每个节点最多同时可以向其他节点发起$8$条连接,且同时接收不超过$125$ 条的连接。比特币网络为了检测参与节点的加人和离开状态它要求参与节点每隔$24$小时发送 $addr $消息向全网广播自己的$IP$ 地址，得到$addr$消息的节点可以向相邻节点转发该消息。参与节点除了通过 $addr$ 消息发现其他节点之外,也可以发送 $getaddr$ 消息请求以获得其他节点的$IP $地址,从而获得网络中大多数节点的$IP$地址。</p>
<h3 id="区块链数据传播">区块链数据传播</h3>
<p>如图2.10所示,在数据传播方面,参与节点通过发送$inv$ 消息向所有邻居节点发送区地址。块或者交易的哈希数据,邻居节点首先判断接收到的哈希数据是否为新的数据,如果是新的数据，则向节点发送$getdata$ 消息获取哈希数据所对应的区块或者交易的实际数据,然后验证数据的有效性,并以同样的方式向它们的所有邻居节点传播数据。由接收者主动发送$getdata $请求数据的方式避免了不必要的网络流量。另一方面，比特币网络会每隔$100$毫秒随机地中转部分$inv$消息以实现将交易传播给网络的大多数节点。对于主动发送$inv$ 消息的参与者来说,如果它们的交易没有被处理,可以多次重发交易数据。</p>
<p><img src="/img/blockchain_sec/2_6.png" alt="比特币交易传播"></p>
<p>在P2P的网络架构下,对等节点之间是通过洪泛的方法发送消息的，这使得区块链网络很容易随着网络节点的增多而加大负载.甚至有些网络连接因网络资源有限而断开进而造成网络分片现象。例如,针对比特币区块链提出的网络 BlockNDN 无法防止网络分片现象发生。同时,采用基于 P2P 的网络结构也是导致区块链系统延展性受限的影响因素之一，目前一些试图提高比特币区块链延展性的工作没有考虑这种因素,因此这些方案的有效性还有待分析。例如,试图增加区块大小容纳更多的交易数据来提高区块链的交易吞吐量,但是由于网络带宽的限制,这反而增加了块传播时间。此外,还有试图增加节点连接度来使区块尽快传播到更多的网络节点,然而这进一步加大了网络负载,容易导致网络分片。为了应对 P2P应用层网络的局限性,研究者陆续提出了优化后的区块链网络协议,如BCXP。</p>
<h3 id="区块链节点">区块链节点</h3>
<p>一般来说,根据一个区块链系统的身份管理机制的不同,节点加人网络的限制也不同。对于公开链,节点可以任意地加人或者离开区块链网络,而对于联盟链或者私有链系统对节点的加人有严格的身份验证机制。区块链中长期参与的节点彼此之间并没有功能和角色上的区分,每个节点的作用是对等的,一个节点既可以作为客户端同时也可以作为服务器。如图2.11所示,区块链中的节点通常是路由、共识、钱包区块链数据库多个功能的集合。路由功能是指节点在全网络中提供路由转发功能。钱包包括以下两种:冷钱包(Cold Wallet)和热钱包(Hot Wallet)。冷钱包指的是脱离了网络连接的离线钱包利用离线存储的方式对数字货币进行管理。相反地,热钱包需要连接网络来进行交易，因此也是极易遭受攻击的一种钱包类型。</p>
<p><img src="/img/blockchain_sec/2_7.jpg" alt="区块链节点功能"></p>
<p>在某个特定时间段内,依据区块链节点执行操作的不同,节点可以被分为3种:全节点、轻量级节点和共识节点。具体来说,全节点存储了整个区块链数据的完整备份,因此可以独立地验证任意一笔交易数据的有效性。轻量级节点只备份了区块头数据,因此在验证某笔具体交易时,需要向全节点请求相应的区块数据协助验证。对于共识节点,它可以是全节点也可以是轻量级节点,主要参与运行区块链的共识协议,同时与其他节点通信并交换信息来保证区块链数据的一致性,它也被称为矿工。</p>
<p>本质上讲,整个区块链系统的安全性取决于所使用的共识协议。通常情况下,区块链系统所采用的共识协议决定了系统中所能容忍的恶意节点数量。为了保证系统的安全性,恶意节点在全节点中所占的比重不能超过一定的阙值。假定全节点数量为 n,对于比特币来说,恶意节点数不能超过 50%,即n/2。其他基于拜占庭共识协议的区块链容忍较低的恶意攻击者数量为 n/3,这部分内容将在第 4 章进行阐述。</p>
<h2 id="第3章-区块链密码学基础">第3章 区块链密码学基础</h2>
<h3 id="群的基本定义及性质">群的基本定义及性质</h3>
<h4 id="群的定义">群的定义</h4>
<p>在非空集合$G$上定义一个二元运算符“$·$”,并且该集合满足下面4个属性。</p>
<ol>
<li>封闭性:对于任意$a,b∈G$,有$a·b∈G$.</li>
<li>结合律:对于任意$a,b,c∈G$,有$a·b·c=(a·b)·c=a·(b·c)$。</li>
<li>存在单位元: $∃i∈G$,对于元素$a∈G$,都可以得到$a·i=i·a=a$。</li>
<li>存在逆元:对于任意$a∈G$,存在一个元素$a^{-1}∈G$,使得$a·a^{-1}=a^{-1}·a=i$。</li>
</ol>
<p>$a^{-1}$则为元素$a$在集合$G$上的逆元。</p>
<p>如果某个代数系统满足上述所有性质，则称其为群(Group),记为$(G，·)$。</p>
<p>交换律:对任意的$a,b∈G$,有$a·b=b·a$。</p>
<p>如果某个群除了满足以上封闭性、结合律、存在单位元、存在逆元4 个属性之外,还满足交换律,则称该群为交换群或者阿贝尔群。</p>
<h4 id="群的性质">群的性质</h4>
<ol>
<li>群中的单位元是唯一的。</li>
<li>群中任一元素的逆元是唯一的。</li>
<li>对于任意的$a,b,c∈G$,如果有$a·b=a·c$,则有$b=c$。</li>
<li>对于任意的$a,b∈G$,有$(a·b)^{-1}=b^{-1}·a^{-1}$。</li>
<li>对于任意的$a∈G$,元素$a$与自身的$n$次运算,其中$n∈N$,可以表示为<br>
$a^n=a·a·…·a$</li>
</ol>
<p>这里需要注意$n=0$的情况,定义$a^0=i$,其中元素$i$是$G$中的单位元。</p>
<p>如果分别使用普通乘法和普通加法的符号来定义$G$ 中的二元运算“$+$”和“$·$”,则对于乘法运算,$a^n$表示$a$ 的$n$ 次幂,加法运算 $na=a+a+…十a$,可以得到如表 3.1所示的性质。</p>
<p>如果群$G$中包含的所有元素个数是一个有限整数,则称$G$为有限群,否则称为无限群。有限群$G$ 中元素的个数,称为这个有限群的阶。若$G$ 是一个有限群,它的阶表示为 $|G|$ 。</p>
<p>特别地，如果一个集合在某种运算上是一个群,但其在其他运算上未必是一个群。</p>
<h4 id="有限域">有限域</h4>
<p>有限域指的是包含有限个元素的域。显然，$Z_q$（$q$为素数）就是一个有限域。可以得到关于有限域的性质为有限域的阶必为素数的幂。举例而言，假设 $F$ 是一个有限域，则存在素数 $p$ 和正整数 $n$，使得 $|F| = p^n$，将这个有限域记为 $F^n_p$ 或 $GF(p^n)$。反之，对于每一个这样的素数幂 $p^n$，都存在这样唯一的阶为 $p^n$ 的有限域。当 $n=1$ 时，把有限域 $GF(p)$ 称为素数域。密码学中普遍采用的域是阶为 $p$ 的素数域 $GF(p)$ 和特征为 $2$ 的 $GF(2^m)$ 域。</p>
<h3 id="整数群、椭圆曲线群和双线性映射群">整数群、椭圆曲线群和双线性映射群</h3>
<h4 id="整数群">整数群</h4>
<p>由整数集合$Z$构成的群,即为整数群。整数群有如下的一些性质。</p>
<ol>
<li>整数集合$Z$在加法运算上可以构成阿贝尔群,写作$(Z,+)$,它的全部元素都是$1$生成的,$0 $是这个群的单位元,每一个元素的逆元是自身的相反数。</li>
<li>整数集合$Z$在乘法运算上不能够构成群,因为除了元素 $1$和$-1$外，其他所有素的乘法逆元都不存在。</li>
</ol>
<p>特别地,$(Z_p,+)$称为模 $p$ 的整数群,它包含的元素是模$p$的$p$ 个剩余类$([0],[1],[2],…,[p-1])$。显然,$Z_p$是一个加法循环群,$Z_p=&lt;[1]&gt;$,其中$[1]$就是它的一个生成元。对于任何与$p$互素的整数$r,[r]$都是$Z$的生成元。</p>
<h4 id="椭圆曲线群">椭圆曲线群</h4>
<p>椭圆曲线密码(Elliptic Curves Cryptography,ECC)是基于圆曲线数学理论的算法,属于公钥加密算法,是迄今为止被实践证明安全有效的三类公钥密码体制之一,其以高效性能在实际系统中被广泛应用。椭圆曲线离散对数问题的困难性决定了 ECC 算法的安全性。椭圆曲线离散对数问题是一个比大整数因子分解问题(RSA 算法基础)以及离散对数问题(DSA 算法基础)更困难的问题。相比于 RSA 算法,ECC算法的优势在其能够用更少的位长度获得与 RSA 同等强度的安全性，因此 ECC 算法可以节约计算开销、密钥管理存储开销以及通信带宽,使得ECC算法可以适用于一些计算能力较弱或者对移动性要求较高的设备,例如<br>
手机、智能卡等小型或移动型设备。</p>
<p>所有满足椭圆曲线方程点的集合就构成了椭圆曲线群下面将介绍 3 种基于不同域的椭圆曲线。</p>
<ol>
<li>实数域上的椭圆曲线</li>
</ol>
<p>椭圆曲线并非字面上理解的椭圆,只是它的曲线方程与计算椭圆的周长方程类似(见图 3.2)。一般来说,椭圆曲线指的就是维尔斯特拉斯(Weierstrass)方程，即<br>
$y^2+axy+by=x^3+cx^2+dx+e$</p>
<p>椭圆曲线是由满足方程的全体解集$(x,y)$再加上一个无穷远点$O$  构成的集合,该方程中的参数 $a,b,c,d$ 是满足某些定条件的实数。上述曲线方程通过坐标转化为以下的简化式,即<br>
$y^2=x^3+ax+b$</p>
<p>由这个方程确定的椭圆曲线记为 $E(a,b)$或$E$。椭圆曲线是关于 x轴对称的。椭圆曲线的加法运算可以定义为:如果椭圆曲线上 $3 $个点位于同一直线,那么它们的和为$O$。椭圆曲线上的加法也具有加法运算的一般性质,如交换律、结合律等。</p>
<ol start="2">
<li>有限域$GF(p)$上的椭圆曲线<br>
有限城$GF(p)$上的椭圆曲线定义为满足式(3.3)同余式的所有几何解$(x，y)∈GF(p)$和一个无穷远点$O=(x,\infty)$构成的集合:<br>
$$y^2=x^3+ax+b(mod\ p)$$<br>
式中$p$是一个大于$2^{100}$的素数;$a,b∈GF(p)$是满足$4a^3+27b^2\neq0(mod\  p)$的常数。这类椭圆曲线通常用$E_p(a,b)$来表示,即</li>
</ol>
<p>$$E_p(a,b)={(x,y)∪Ο | y^2≡x^3+ax+b(mod\ p)}$$</p>
<p>该椭圆曲线上只有有限个点数 $N$(称为椭圆曲线的阶,包含有无穷远点)。$N$ 越大,安全性越高,即群中元素越多,越能抵抗穷举搜索攻击。</p>
<p>比特币系统的区块链实现采用的是椭圆曲线 $sep256k1$,$secp256k1$ 是基于有限域$GF(p)$上的椭圆曲线,其中$p=2^{256}-2^{32}-2^9-2^7-2^4-1$。</p>
<ol start="3">
<li>有限域$GF(2^m)$上的椭圆曲线<br>
有限域 $GF(2^m)$中的元素是$ m $位的字符串,这些字符串可以表示为系数在 $GF(2)$上<br>
的多项式:</li>
</ol>
<p>$$\lbrace a_{m-1}x^{m-1}+a_{m-2}x^{m-2}+···+a_1x+a_0:a_i∈\lbrace 0,1\rbrace\rbrace$$</p>
<p>$GF(2^m)$上的椭圆曲线是定义为满足同余式(3.6)的所有几何解$(x，y)∈GF(2^m)$和一个无穷远点 $O=(x,\infty)$构成的集合。</p>
<p>$$y^2+xy=x^3+ax^2+b$$</p>
<p>其中,$m&gt;160,a,b∈GF(2^m)$且$b\neq0$。这类椭圆曲线通常可以用 $E_2(a,b)$来表示,即$$E_2(a,b)=\lbrace(x,y)∪O | y^2+xy=x^3+ax^2+b\rbrace$$</p>
<h4 id="双线性映射群">双线性映射群</h4>
<p>双线性映射也称双线性配对,一个双线性映射是由两个向量空间中的元素,一起生成第三个向量空间中的一个元素的函数,并且该函数对每个参数都是线性的。总而言之,给出一个双线性群组的定义$(G_1,G_2,G_T,p,g_1,g_2;e)$,其中 $G_1,G_2和G_T$是阶为素数 p的乘法循环群,$g_1和g_2$分别是$G_1和G_2$的一个生成元。一个映射 $e:G_1×G_2→G_T$称为双线性映射,当它满足如下3个性质。</p>
<ol>
<li>双线性:对于$∀a,b∈Z_p,均有e(g_1^a,g_2^b)=e(g_1,g_2)^{ab}$</li>
<li>非退化性:$∃g_1∈G_1,g_2∈G_2,使得e(g_1,g_2)≠1$。</li>
<li>可计算性:对于$∀u∈G_1,v∈G_2$,存在有效的算法计算 $e(u,v)$。<br>
若$G_1=G_2$,则称这个双线性映射是对称的,否则是非对称的。</li>
</ol>
<h3 id="密码学困难问题">密码学困难问题</h3>
<h4 id="离散对数问题">离散对数问题</h4>
<p>基于离散对数的公钥加密算法作为常用的公钥加密算法之一,其加密算法的安全性要远远高于基于大整数分解的 RSA 加密算法，而且离散对数问题(Discrete LogarithmProblem,DLP)的计算复杂度要比大整数分解问题更高。经过多年研究，人们无法构造出一个概率多项式时间来解决离散对数问题的方案。</p>
<h5 id="离散对数问题定义">离散对数问题定义</h5>
<p>离散对数问题的定义为:当给定一个素数 $p$,以及有限域$Z_p$上的一个本原元$a$时，对$Z_p$上的任意正整数$b$,都可以找到唯一的整数$c,0&lt;c&lt;p-2$,使得$a^c≡b(mod\ p)$,通常用$log_a^b$来表示$c$。一般而言,如果仔细选择$p$,则可以认为该问题是难解的,目前还没有找到可以在多项式时间内计算离散对数问题的算法。为了抵抗已知的攻击，选择的素数$p$需要满足以下两个条件:一是为至少 $150 $位的十进制整数;二是$p-1$至少有一个大的素数因子。</p>
<h5 id="离散对数问题性质">离散对数问题性质</h5>
<p>离散对数问题的困难性与有限域上的生成元无关,任何可以计算$log_a^b$ 的离散对数算法同样可以用来计算任意其他底数的离散对数问题。</p>
<h4 id="大整数分解问题">大整数分解问题</h4>
<p>大整数分解问题(Integer Factorization Problem,IFP)指的是对于任意给定的两个大素数的乘积,找出该乘积的因子,这个问题是困难的。大整数分解问题是数论中的一个基本问题,普遍认为不存在高效的概率多项式时间算法能够分解一个大整数，因此它是一个非常重要的研究问题。</p>
<p>将大整数分解问题具体定义为:任意选定两个长度为$λ$的大素数$p$ 和$g$,并计算 $n=pq$。对于给定 $n$,若存在一个可忽略的函数$negl(λ)$,使得n能够被分解为 $p$ 乘以 $g $的概率不大于 $negl(λ)$,则可以称该大整数 $n$ 的分解问题是一个困难问题。</p>
<h4 id="CDH-DDH-问题">CDH/DDH 问题</h4>
<p>计算 Diffie-Hellman(Computational Diffie-Hellman,CDH)假设是 Whitfield Diffi和 Martin Hellmn 两位教授在构造密协议协商的时候提出来的。一般把任意群 $G$的三元素组$(g^x,g^y,g^{xy})$称为DH组。对于任意为素数q的循环群$G$,$g∈G$ 是一个生成元，二元函数$dh_g:G^2→G$的定义为:随机选择两个元素$X,Y∈G$,令$X=g^x,Y=g^y$,计算函数$dh_g(X,Y)=g^{xy}$。CDH同题的困难性指的是在已知$G,g,g^x,g^y$的情况下,计算二元函数$dh_g$是困难的,即存在一个可忽略的函数 $negl(λ)$,使得计算出二元函数 $dh_g$ 的概率不大于 $negl(λ)$。</p>
<p>判定 Difie-Hedlman(Decisional Difie Helman,DDH)假设是 CDH 假设的判定形式,也就是计算问题对应的判定问题,用来判断不可分辨性。DDH 假设具体定义如下:对于任意阶为素数$ g$ 的循环群$G$，$g∈G$ 是一个生成元,随机选取$3$个元素 $X,Y,Z∈G$，其中$X=g^x,Y=g^y,且有 dh_g=g^{xy}$。存在一个可忽略的函数$negl(λ)$,使得区分 $Z=dh_g$;或者$Z$是随机选取的概率不大于$negl(λ)$。</p>
<h3 id="BDH-DBDH-问题">BDH/DBDH 问题</h3>
<p>双线性 Diffie-Hellman( Bilinear Diffie-Hellman,BDH)问题是对给定的 $3$ 个元素$g^a,g^b,g^c$,计算$e(g,g)^{abc}$。具体定义如下。</p>
<p>计算 BDH 假设是对于任意阶为素数$ q$ 的循环群$G_1,G_2,G_3$,其中 $g∈G_1,h∈G_2$是两个生成元,存在一个可高效计算的同构 $\phi:G_1→G_2$,使得对于生成元$g,h$,有$\phi(g)=h$。随机选择$a,b,c∈Z_q$,有 $g^a,g^c,h^a,h^b$,BDH 问题的难解性在于计算 $e(g,h)^{abc}$是困难的,即存在一个可忽略的函数 $negl(λ)$,使得计算出 $e(g,h)^{abc}$的概率不大于 $negl(λ)$。</p>
<p>同样地,BDH 假设的判定形式是 DBDH(Decisional Bilinear Diffie-Hellman)假设。对于任意阶为素数 $q$ 的循环群$G_1,G_2,G_3$,其中 $g∈G_1,h∈G_2$是两个生成元,存在一个可高效计算的同构 $\phi:G_1→G_2$,使得对于生成元 g,h,有 $\phi(g)=h$。随机选择$a,b,c∈Z_q,W∈G_3$,已知 $g^a,g^c,h^a,h^b,e(g,h)^{abc}$,存在一个可忽略的函数 $negl(λ)$,使得区分$W=e(g,h)^{abc}$或者 $W $是随机选取的概率不大于$negl(λ)$。</p>
<h3 id="哈希函数">哈希函数</h3>
<h4 id="哈希函数定义">哈希函数定义</h4>
<p>密码学上的哈希函数(Hash Funtion),也称杂凑函数。其目的是将任意长度的消息$m$ 压缩或者映射为某一固定长度的消息摘要,表示为 $H(m)$,该映射是一个多对一的映射。$H(m)$也可以当作消息 $m$ 的指纹,一旦 $m$ 发生变化,$H(m)$也会随之改变。</p>
<p>根据是否需要密钥,哈希函数可分为以下两类。</p>
<ol>
<li>带密钥的哈希函数:有两个不同的输入,分别为消息和密钥。一个带密钥的哈希函数通常用来作为消息认证码,即消息验证码(Message Authentication Code,MAC)。</li>
<li>不带密钥的哈希函数:只有一个消息输人,这样产生的消息摘要必须被安全存放,不能被篡改。</li>
</ol>
<p>根据设计结构,哈希函数可以分为 3类。</p>
<ol>
<li>标准哈希函数。</li>
<li>基于分组加密的哈希函数。</li>
<li>基于模数运算的哈希函数等。</li>
</ol>
<p>目前,主要的标准哈希函数可以分为两类。</p>
<ol>
<li>$MD$系列的哈希函数,例如 $MD4、MD5、MDS、HAVAL、RIPEMD$等</li>
<li>$SHA$系列的哈希函数,例如 $SHA-1,SHA-256、SHA-384、SHA-512$等</li>
</ol>
<h4 id="哈希函数主要性质">哈希函数主要性质</h4>
<p>哈希函数H必须满足以下6 种性质。</p>
<ol>
<li>$H$的输人可以是任何大小的数据块,即 $H$ 的输人可以是任意长度的。</li>
<li>$H$的输出是固定大小的数据块。</li>
<li>对任意消息$x$,求 $H(x)$是可行的,并可用软件或硬件实现。</li>
<li>对任意给定的哈希值 $h$,找到 $y$ 且满足 $H(x)=h$,计算上是不可行的。</li>
<li>对任意给定的值,找到 $y$,满足 $H(x)=H(y)$并且$x\neq y$,计算上是不可行的。</li>
<li>找到任意的 $x,y$ 且$x\neq y$,使得 $H(x)=H(y)$,计算上是不可行的。<br>
基于以上性质,可以将哈希函数分为两大类:弱碰撞哈希函数和强碰撞哈希函数。弱碰撞哈希函数与强碰撞哈希函数必须同时满足前 3 个条件,主要区别在于后 3 方面。</li>
</ol>
<p><strong>弱碰撞哈希函数</strong><br>
满足上面性质(4)和(5)的哈希函数,称这个哈希函 $H(x)$是碰撞的。</p>
<p><strong>强碰撞哈希函数</strong></p>
<p>满足上面性质(4),(5)和(6)的哈希函数,称这个哈希函数 H(x)是强碰撞的在以上的性质中,性质(4)的意义是指哈希函数是单向性的,通常也称抗原像性,那么H(x)也是单向杂凑函数;性质(5)代表弱碰撞性,可以称为抗第二原像性;性质(6)代表强碰撞性，也可以称为抗碰撞性,用来防止攻击者对哈希函数实施自由起始碰撞攻击，即生日攻击。</p>
<h4 id="哈希函数安全性">哈希函数安全性</h4>
<p>哈希函数在密码系统中使用十分广泛，包括加密方案、签名方案等都有哈希函数的存在,因此哈希函数也已经成为很多黑客攻击的目标。对哈希函数的攻击主要在于破坏其某些特性。例如,可以根据其输出求得输人,找到某条消息使得它的输出与原消息的输出相同,或者找到不同的两条消息,使它们的输出相同。最具有代表性的对哈希函数的攻击为以下两种。</p>
<ol>
<li>
<p><strong>字典攻击</strong><br>
字典攻击(Dictionary Attack)的定义是,在破解密码或密钥过程中,通过逐一尝试用户自定义词典中所有可能的密码(单词或短语),这种攻击方式称为字典攻击。字典攻击与暴力破解相似,区别在于,暴力破解会逐一尝试所有可能的组合密码,没有预先预定好的单词列表,而字典攻击会使用一个预先定义好的单词列表(可能的密码)进行逐一尝试因此,字典攻击对用单向哈希函数加密的口令文件特别有效。攻击者通过编制含有多达几十万个常用口令的表,然后用单向哈希函数对所有口令进行运算,并将结果存储到文件中,攻击者通过非法途径获得加密的口令文件后,比较这两个文件,观察是否有匹配的口令密文,这种攻击方式的成功率非常高。</p>
</li>
<li>
<p>生日攻击<br>
生日攻击(Birthday Attack)的原理是一个统计问题。一个房间里有多少人才能够使得最少有一人与你的生日相同的概率大于 1/2 呢?答案是 253。那么应该有多少人才能够使得他们中至少有两人的生日相同的概率大于 1/2 呢?23 人即可。寻找特定生日的某人,或者是寻找两个随机的具有相同生日的两个人,与对单向哈希函数进行穷举攻击的方法是相同的原理:前者对应了给定消息$m$的哈希值$H(m)$,攻击者不断生成其他消息$m’$,以使得 $H(m)=H(m’)$;后者对应的场景是,攻击者寻找两个随机的消息 $m$和$m$并使得 $H(m)=H(m’)$,而后者称为生日攻击,这种攻击方式没有利用哈希函数的结构和任何代数弱性质,只依赖于消息摘要的长度,即哈希值的长度。为了抵抗生日攻击,哈希函数安全性的一个必要条件就是消息摘要必须足够长。</p>
</li>
</ol>
<h4 id="哈希函数主要应用">哈希函数主要应用</h4>
<p>在密码学中,哈希函数有非常多的应用场景,包含数据认证、数字签名、伪随机数生成和密钥生成等。</p>
<ol>
<li>
<p><strong>数据认证</strong><br>
哈希函数的重要应用之一就是生成文件或者消息 $m$ 的摘要值 $H(m)$,该值被安全地存储,对消息$m$的任意改动都可以通过对改动后的 $m $进行相同的哈希运算而被检测出来,这样的操作保证了数据的完整性,也可以实现对消息的安全认证。对于哈希函数的不同应用,包括 HMAC,即基于哈希函数的消息验证码,其基本思想就是用密钥和消息一起进行哈希操作,确保消息的完整性,使得在传输过程中对消息的任何修改都能够被接收者检测到。</p>
</li>
<li>
<p><strong>数字签名</strong><br>
哈希函数经常被应用在数字签名算法中。在现实应用中,需要签名认证的消息$ m $本身非常大,如果直接在消息 $m$ 上做数字签名效率会非常低。通常情况下,为实现对消息$m$ 的高效数字签名,首先计算出 $m$ 的哈希值 $H(m)$,然后采用私对 $H(m)$进行签名操作,所得到的 $Sig(H(m))$就是用户对消息 $m$ 的签名。利用哈希函数进行数字签名的优势是,可以实现对于消息的不可否认性,消息发布者只能用自己的私钥对哈希值进行签名,接收者使用发布者的公钥进行解密,从而确认消息确实由该消息发布者发出。</p>
</li>
<li>
<p><strong>伪随机数生成</strong><br>
从哈希函数的定义来看,哈希函数具有生成随机性质的数据序列的特征。通过选择一个随机函数,把消息的随机函数值作为它的哈希值来产生,从而得到伪随机数。因此，哈希函数也可以用作伪随机数的生成器。</p>
</li>
<li>
<p><strong>密钥生成</strong><br>
利用哈希函数的单向性,用旧的密钥计算出新的密钥序列,从而使得现有密钥具有泄露后不危及先前所用的密钥的性质,也就是使用哈希函数能够产生具有前向安全的密钥总体而言,哈希函数在密码学的应用中一直发挥着重要的作用,在区块链中也有着十分广泛的应用,如区块链中的链式结构就是通过让每一个区块包含上一个区块的区块头哈希值来实现的。此外,区块链中的默克尔树构造、工作量证明算法、钱包地址等都用到了哈希算法。</p>
</li>
</ol>
<h3 id="默克尔树">默克尔树</h3>
<ol>
<li><strong>基本概念</strong><br>
默克尔树(Merkle Tree),也称 Hash Tree,是用于存储哈希值的二叉树。默克尔树<br>
包含叶节点和非叶节点,其中叶节点用于存放数据块(例如,文件或者文件的集合)的哈希值,所有非叶节点是其对应所有子节点的组合结果的哈希值。<br>
图3.5为一个默克尔树的结构。在树的最底层,也就是叶节点,类似于哈希列表，需要计算的数据被分制成不同的数据块,将数据块的哈希值存放于叶节点。接着计算时并不是直接计算叶节点的哈希值,而是把相邻的两个叶节点的哈希值合并成一个字符串，然后运算这个合并字符串的哈希值。例如,图 3.5 中 $H_6= H(H_2,H_3)= H(H(L_1),H(L_2))$，从而得到一个“子哈希值”。如果最底层的叶节点总数不是双数,那么必然出现一个无法配对的单身哈希数据块，这种情况就直接对它进行哈希运算,也能得到它的子哈希值。以此类推,就可以得到数目更少的新一层的哈希值,最终必然形成一个哈希树结构,直到树根的位置,就只剩一个根哈希值,称为默克尔树根节点值(Merkle Tree Root)。</li>
</ol>
<p><img src="/img/blockchain_sec/3_1.jpg" alt="默克尔树示意图"></p>
<ol start="2">
<li>
<p><strong>主要特点</strong><br>
默克尔树相比其他数据结构,具有一些特殊的性质。</p>
<ol>
<li>默克尔树是一种树状结构,大多数是二叉树，也有可能是多叉树,但无论是几叉<br>
树,它都具有树状结构的所有特点。</li>
<li>默克尔树的所有叶节点的值是数据集合的单元数据的哈希值。</li>
<li>默克尔树非叶节点的值是根据它左右子节点的值,按照特定的哈希算法计算<br>
得出。</li>
</ol>
</li>
</ol>
<p>一般而言,通常采用SHA-2 和 MD5 作为加密的哈希算法。但如果仅仅防止数据不是蓄意的损坏或篡改,可以改用一些安全性较低但效率较高的校验和算法,如循环冗余校验(Cyclic Redundancy Check,CRC)。</p>
<p>在区块链中,假设一个默克尔树包含 N 笔交易数据当需要验证一笔指定的交易是否存在于某一区块中时，参与者至多花费 $2log_2(N)$次的计算就可以得到结果。这主要是由Merkle 树的构建方式来决定的,它的叶节点值由交易数据的哈希计算得到,并自底向上计算哈希值构建更新上一层节点的数值,直到计算得到默克尔树根节点值,并验证其是否发生变化。假设区块中的交易数量为奇数,则可以重复某笔交易来获得偶数笔交易,避免叶节点无法配对的现象出现,并实现默克尔树的构建。</p>
<h3 id="布隆过滤器">布隆过滤器</h3>
<ol>
<li>
<p><strong>基本概念</strong><br>
20世纪70 年代,Burton Howard Bloom 教授提出了布隆过滤器(Bloom Filter)的概念,它的核心包含一系列哈希映射函数和一个很长的二进制向量,用于快速检索判断一个元素是否存在于某个集合中。布隆过滤器的优点在于空间效率和查询效率非常高,远远区块链安全超过一般的算法,因为它在进行查询时,采用位数组表示一个集合,这样的算法结构大大节省了存储空间,提高了效率,但它也有不足之处:删除困难,以及存在一定概率的误识别,也就是假正例(False Positives)的现象，即当布隆过滤器经过运算向系统报告某一元素在集合中时,事实上它判断错误,该元素并不在集合中,布隆过滤器将一个不属于集合的元素误检测为集合中的元素。相对于假正例现象,布隆过滤器不会发生假反例(False Negatives),也就是如果一个元素不在查询集合中,那么布隆过滤器是不会向系统报告该元素属于集合。换句话说,布隆过滤器判断一个元素不在集合中,就一定不在，但当它判断一个元素在集合中,就存在一定的判断误差,可能导致结果不准确。布隆过滤器的优缺点反映了它是用较小的错误率来换取较高的运算效率,适用能容忍容错率的应用场景，而无法适用“零错误”的场景。</p>
<p>布隆过滤器的常用的应用场景包含:判别某个元素是否存在于一个集合中,为实现这个目标,通常的做法是采用哈希表(Hash Table)数据结构,它可以通过一个哈希函数将一个元素映射成一个位阵列中的某个点,并且这些位阵列的初始值都为 0,当有元素映射到位阵列中的某一点时,就将这一点的值设置为 1。因此,要知道某个集合中是否有该元素,只需要判断这个点在哈希表中对应的位置是否为 1,就可以知道集合中有没有该元素。这就是布隆过滤器的基本思想,算法的具体过程如图 3.6 所示。将所有元素通过布隆过滤器保存至集合中,然后通过比较确定该元素是否存在于该集合。链表、树等结构也采用同样的方式进行判断。</p>
<p><img src="/img/blockchain_sec/3_2.jpg" alt="默克尔树示意图"></p>
<p>但采用这样的方式进行数据存储和查询,存在着一些难以避免的问题:首先，随着集合中元素的增加,哈希表所需要的存储空间越来越大,检索速度也会变得越来越慢。其次,这样的结构面临的另一个问题就是冲突,假设哈希函数是合适并且良好的，如果位阵列长度为 m 个点,那么若想将冲突率降低到 1%,这个哈希表就只能容纳 m/100 个元素显然就无法实现所有空间有效的要求:为解决无法实现所有空间有效的问题，解决方法是可以使用多个哈希函数,数据可以采用多个哈希函数进行映射存储,便可以实现空间有效,正确判断某个元素是否在集合中。</p>
</li>
<li>
<p><strong>布隆过滤器的算法过程</strong></p>
<ol>
<li>选取$ k$个哈希函数,每个函数可以把目标数据 $d $哈希为 $1$个整数</li>
<li>初始化一个长度为$n $位的数组,每位初始化为 $0$。</li>
<li>在某个数据$d$ 加人集合时,用个哈希丽数计算出 个哈希值，并把数组中对应的位置为 $1$。</li>
<li>在判断数据 $d$ 是否存在于该集合时,用k个哈希函数计算出 个哈希值,并查询数组中对应的位,如果所有的位都是 $1$,则认为该$ key$ 在集合中;反之,则不存在。</li>
</ol>
</li>
<li>
<p><strong>布隆过滤器的主要特点</strong><br>
<strong>布隆过滤器的优势有以下 5 点:</strong></p>
<ol>
<li>空间上的低存储量和时间上的高效性,布隆过滤器的存储空间、插人和查询时间都是常数,相比于其他的数据结构,布隆过滤器有着天然具备的高效性;</li>
<li>布隆过滤器中采用的哈希函数相互之间没有关系,具有硬件并行实现的编辑性;</li>
<li>布隆过滤器不需要存储元素本身,因此对于某些保密要求非常严格的数据和场合,在安全性上相比其他数据结构具有绝对优势；</li>
<li>布隆过滤器可以用于表示全集数据,实现数据的完备性;</li>
<li>布隆过滤器还具备的特点是,当哈希函数的数量k和阵列数量 m 相同时,使用同一组哈希函数的两个布隆过滤器的交并差运算可以使用位操作进行。</li>
</ol>
<p><strong>布隆过滤器也存在一定劣势:</strong></p>
<ol>
<li>随着存人的元素数量增加,数据查询的误算率也会随之增加。</li>
<li>从布隆过滤器中安全地删除元素信息较为困难,通常采用的方法是把位列阵变成整数数组,对插人元素进行计数,每插人一个元素相应的计数器加 1,这样删除元素时将计数器减 1。然而,这样的操作可能导致信息的泄露,因为首先必须保证删除的元素的确在布隆过滤器里面,而这一点单凭过滤器是无法保证的。</li>
</ol>
</li>
</ol>
<h3 id="数字签名">数字签名</h3>
<h4 id="基本概念">基本概念</h4>
<ol>
<li>
<p><strong>数字签名性质</strong></p>
<ol>
<li>唯一性。对一个文档的签名,是指对文档的哈希结果进行签名,从函数的角度来说,文档和签名之间存在一一对应的映射关系,不同文档的哈希值不同,对它的签名结果也是不同的。</li>
<li>不可否认性。签名者采用自己的私钥对某个文档进行签名,一旦签名完成,签名者不能否认该签名，同时其他人在不知道签名者私钥的情况下,不能够伪造该签名者的签名。</li>
<li>时效性。为了避免一个签名被重复使用,文档的签名需要具备时间属性,保证签 名的时效性。</li>
</ol>
</li>
<li>
<p><strong>数字签名分类</strong></p>
<ol>
<li><strong>按照签名用户分类</strong>。依照用户的个数分类,数字签名方案包括单个用户或多个用户的签名,通常情况下数字签名都是单个用户的操作,当有特别需求时会用到多个用户共同计算的数字签名,它被称为多重数字签名,依照签名的步骤中是不是有序,多重签名分为有序多重数字签名和广播多重数字签名。</li>
<li><strong>按照数字签名的特性分类</strong>。根据签名的特性分类,数字签名包括自动回复和不自动回复的签名方案。</li>
<li><strong>按照数学难题分类</strong>。依照签名方案根据的问题难解程度分类，数字签名包括基于离散对数问题的数字签名方案和基于大整数分解问题的数字签名方案。更进一步,著名的 EIGamal,DSS 签名方案便是基于离散对数问题的数字签名方案,RSA 签名方案是最突出的基于大整数分解问题的数字签名方案。离散对数问题中还包括一类椭圆曲线离散对数,椭圆曲线签名方案的安全性便是基于椭圆曲线离散对数问题的难以解决特性。</li>
<li><strong>按照数字签名的实现分类</strong>。按照数字签名的实现分类,数字签名包括仲裁数字签名和直接数字签名。仲裁数字签名涉及三方:签名者、接收者和仲裁者。完整的签名过程需要三方协作完成,其中仲裁者是一个可信第三方。直接数字签名的操作是在数据签名者和数据接收者之间完成的。</li>
</ol>
</li>
</ol>
<h4 id="椭圆曲线数字签名">椭圆曲线数字签名</h4>
<p>1985 年,Neal Koblitz 和 Victor Miller 提出了椭圆曲线密码(ECC)系统,它可以看作是离散对数密码系统的演化,只是元素的选取变换为椭圆曲线上的一个点。椭圆曲线密码系统的优势在于可以达到和离散对数密码系统同等安全性的同时,具有更小的参数、钥长度和更快的运算速率,因此能够适用存储、计算环境受限的场景。在椭圆曲线密码:统中,基于椭圆曲线离散对数问题(Elliptic Curve Discrete Logarithm Problem,ECDLI的难解性,可以构造数字签名方案,也就是椭圆曲线数字签名算法(Elliptic Curve DigiSignature Algorithm,ECDSA),下面重点介绍算法的执行步骤。</p>
<ol>
<li>
<p><strong>数字签名算法</strong><br>
Alice 要将一份签名的消息发送给 Bob,为了保证通信的安全性,双方首先需要定义一组如下的椭圆曲线签名算法的参数:$(CURVE,G,n)$</p>
<p>具体来说,CURVE是选取的椭圆曲线的几何方程和点域,$G $是圆曲线上的基点表示可倍积阶数(Multiplicative Order),它是一个很大的质数,几何意义在于满足 $nG=0$,即点倍积 $nG$ 的结果是没有意义的,而任何一个小于$n$的正整数$m=[1,n-1]$,点倍积$mG$ 都可以映射为该椭圆曲线上的一个点。</p>
<p>然后,Alice 生成一对公钥和私钥。私钥是从$[1,n-1]$随机选取的,即$d_A=rand(1,n-1)$<br>
公钥计算如式(3.17)所示:$Q_A=d_A×G$</p>
<p>Alice 通过以下步骤对消息$ m $进行签名。</p>
<ol>
<li>采用哈希函数(MD5或 SHA-1)计算消息m的哈希值,得到$e=H(m)$。</li>
<li>对$e$进行二进制分解，将最高位$L$个位记为$z$,其中$L_n$表示的二进制长度。<br>
需要注意的一点是,$z $的取值可能大于 $n$,但长度不会比 $n$ 更长。</li>
<li>选择一个随机整数$ k ∈[1,n-1]$。</li>
<li>计算椭圆曲线上的点$(x_1,y_1)=kG$。</li>
<li>计算$r=x_1mod\ n$,若$r=0$,返回3。</li>
<li>计算$s=k^{-1}(z十rd_A)mod\ n$,若$s=0$,返回3。</li>
<li>Alice 生成的数字签名为 $ρ=(r,s)$。</li>
</ol>
</li>
<li>
<p><strong>数字签名的验证</strong><br>
消息接收者 Bob 收到的文件包含两部分内容:一个是签名文件 $ρ$,另一个是发送者的公钥,因此 Bob 需要分别验证这两部分的真实性、有效性和正确性。</p>
<ul>
<li>验证公钥
<ol>
<li>公钥的坐标$Q_A$应该是有效的,不会等于一个极限值空点。</li>
<li>对公钥 $Q_A$的坐标进行验证,它必须是圆曲线上的一点。</li>
<li>公钥$Q_A$与n的关系必须满足条件:$ n×Q_A = O$</li>
</ol>
</li>
<li>验证签名文件
<ol>
<li>验证$ρ=(r,s)$均是处于$[1,n-1]$范围内的整数,否则验证失败。</li>
<li>计算$e=H(n)$。</li>
<li>计算$e$的二进制分解,并取最高位$L_n$个位，记为$z$。</li>
<li>计算$w,w=s^{-1}mod\ n$。</li>
<li>计算参数$u_1,u_2$,其中$u_1=zw\ mod\ n,u_2=rw\ mod\ n$。</li>
<li>计算$(x_1，y_1)$,判断$(x_1，y_1)$这个点是否属于椭圆曲线，若不是则验证无效,具体的验证方法是计算式(3.19),判断左右两边是否相等:$(x_1,y_1)=u_1×G+u_2×Q_A$；如果不成立,那么对消息$ m $的签名验证失败。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="EIGamal签名">EIGamal签名</h4>
<p>基于有限域上离散对数问题难以解决的特性,1985年,有名的EIGamal数字签名方案得以提出。下面是获得签名结果所需要完成的具体步骤。</p>
<ol>
<li>任选一个大素数 $p$,群$G$上的一个本原元$α$和一个随机整数$d,d[1,p-2]$。</li>
<li>计算$β,β=a^d\ mod\ p$。</li>
<li>令$p,α,β$作为公钥，$d$ 作为私钥。</li>
<li>签名过程:计算消息的哈希值$x=H(m)$,任选整数$k,k∈[1,p-2]$,且$(k,p-1)=1$,然后令$r=α_k\ mod\ p,s=(x-dr)k^{-1}\ mod\ (p-1)$,则最终的数字签名结果是$(r,s)$。</li>
<li>对数据完成签名后,将最终的数据签名结果和明文数据共同传输给数据接收者</li>
<li>接收者收到消息后,计算$t=β^rα^s\ mod\ p$。</li>
<li>当满足:$t=α^x\ mod\ p$时,说明签名结果有效,消息在传输过程中是完整的,没有被篡改,否则表明签名无效。</li>
</ol>
<p>由于有限域上的离散对数问题是难解的,攻击者不能根据已知信息推测出私钥，保证了 EIGamal 数字签名方案的安全性。一般地,素数 $p$ 的长度不得少于 $1024 $位,签名方案由$(r,s)$数对组成,其中$r$和$s$的位长度都与$p $相同。</p>
<h4 id="多重签名">多重签名</h4>
<p>在数字签名领域,除了一个人对一份文件进行签名的情况,有时还需要多个人同时对一份文件进行签名,这种需求常常发生在电子商务、资金监管等场景。简单来说,就是多个用户对一份文件具有签名权,共同来产生文件的签名,这就是多重数字签名的含义。具体地,假定有 $N $个用户${1,2,…,N}$,每个用户都拥有一对公钥和私钥，用户用各自的私钥签署文件 $m$,最后得到关于文件 $m$ 的多重签名。</p>
<p>在多重签名的场景中,按照要不要提前约定签名者的签名序列,可以将多重签名分为有序多重数字签名和广播多重数字签名。顾名思义,有序多重数字签名就是将数据依照既定的排列顺序发送给签名者完成签名。与有序多重数字签名相反的广播多重数字签名方案中,每个签名成员各自完成单个签名数据,发给数据收集者,由收集者最终合成多重签名的数据,然后发给验证者来完成验证操作。多重签名主要包含 3 个参与方:消息发送者、消息签名者以及签名验证者。但需要注意的一点是广播多重数字签名中还需要引人消息收集者。常规地,多重签名包括 3 个算法:系统建立、获得签名和签名验证。</p>
<p>下面通过一个基于椭圆曲线的广播多重数字签名算法的例子来展示多重数字签名的<br>
过程。</p>
<ol>
<li>
<p><strong>系统建立</strong><br>
令$GF(g)$代表一个包括$q$个元素的有限域,这里 $q$ 是一个大于$2^{160}$的大素数,抽取$GF(q)$上一条安全的椭圆曲线 $E: y^2=x^3+ax十b(a,b∈GF(q))$,$G$ 是$E$ 的基点(即$nG=0$),$M$ 是需要签名的数据。设有 $m$ 个数据签名者 $U_1,U_2,…,U_m$,对每个签名者$U_i(i=1,2,…,m)$随机抽取一个隐藏值 $d_i(d_i∈Z_q)$作为自身的私钥,设置公钥 $Q_i=d_iG$并公布出去。$P$ 是一个预设的正整数。</p>
</li>
<li>
<p><strong>获得签名</strong><br>
对于每个签名者 $U_i(i=1,2,…,m)$和签名验证者$U_v$消息拥有者发送消息$(M,T)$，其中$T$是签名时间标志,要求签名者在给定时间 $△T$ 内完成签名。对消息 $M$，消息拥有者计算$e=H(M,T)$,并发送给$U_i$,和$U_v$,然后$U_i$和$U_v$进行如下操作。</p>
<ol>
<li>每一个签名者$U_i(i=1,2,…,m)$选取一个随机整数 $k_i$;,其中$k_i∈[1,m-1]$。</li>
<li>计算$R_i=k_iG=(x_i;y_i)$,若$x_i=0$ 转回1;否则计算 $r_i=x_i\ mod\ m$。</li>
<li>签名者$U_i$计算$s_i=k_ie+d_ir_i\ mod\ m$,若$s_i=0$转1;反之将数据签名$(M,(r_i,s_i))$发送给数据收集者 $U_c$。</li>
<li>数据收集者 $U_c$收到签名数据后,依次对单个的签名完成验证,若验证不正确则要求该签名者重发,但重发次数不能超过$ P$。</li>
<li>若是全部签名者的签名所得 $s_i$ 验证都是有用且正确的,数据收集者 $U_c$ 设置$\sum_{i=1}^m s_i$，则$s$ 作为最后的广播签名$U_v$。将 $sig(M)=(M,(r_1,r_2…r_m,s))$ 发送给签名验证者$U_v$。</li>
</ol>
</li>
</ol>
<h4 id="群签名">群签名</h4>
<ol>
<li>
<p><strong>群签名的定义</strong><br>
群签名概念的提出首次出现在 1991 年的欧密会上。从字面上理解,群签名首先包含系列合法的群成员，在一个群签名方案中,群组中任意一个群成员都能够以匿名的形式代表整个群组对一个消息进行签名,与普通的数字签名方案类似,群签名结果也是可以公开验证的，系统中的验证者可以采用群公钥对签名进行验证,确认该签名确实来自群组，证明签名由群组里的合法成员生成,但并不能确定群组里签名者的身份,只有当签名结果发生争议时,群管理员利用系统权限可以追踪到群组里签名成员的真实身份。</p>
<p>一般情况下，群签名方案涉及3个实体:群中心群管理员和群成员。其中,群中心负责方案的初始化建立;群管理员负责在签名发生争议时,追踪群组里签名者的真实身份信息;群成员构成一个完整的群组,可以以群组的名义对数据签名。另外,群签名方案还包括以下5个算法。</p>
<ol>
<li>系统建立<br>
系统建立算法由群组中的权威机构群管理中心执行,输入系统的安全参数入,输出方案中群组的公钥和私钥对。</li>
<li>成员加入<br>
成员加人算法由权威机构群中心与群成员交互履行,获得群成员的公钥$k_P$和私钥$k$,群管理中心获得公钥$k_P$信息,私钥$k$ 由群成员保存。</li>
<li>签名<br>
签名算法由群组里的一个合法成员执行,输人消息 $m$ 和自己的私钥$k$,输出消息m的群签名$SIG$</li>
<li>验证<br>
验证算法由验证者履行,输人消息 $m$、群签名 $SIG$ 以及群公，作出关于该群签名是 否正确的判定。</li>
<li>打开签名<br>
打开签名算法由群管理员履行,输人消息 $m$、群签名 $SIG$以及群管理员的私钥,可以追踪到群组里签名成员的真实身份。</li>
</ol>
</li>
<li>
<p><strong>群签名的特性</strong></p>
<ol>
<li>代表群组对消息进行签名的只能是群组里的合法群成员。</li>
<li>方案中的验证者只能作出签名是否正确的判定,而他不可以获得签名成员的身份信息。</li>
<li>当签名得到的结果出现争议时,只有群管理员可以打开签名，追踪到签名者的身份信息。</li>
</ol>
</li>
<li>
<p><strong>群签名的安全性</strong><br>
一个好的群签名方案除了具有优质的算法,还需要满足如下的安全要求。</p>
<ol>
<li>正确性<br>
群组里的每一位合法群成员只有按照正确的步骤进行签名,得到的签名结果才能被验证者验证通过。</li>
<li>匿名性<br>
在群签名系统中,除了群管理员和其他权威机构,任何人都不能从签名中获得签名者的身份信息。</li>
<li>防伪造性<br>
群组里的合法成员用自己的私钥能够产生消息的合法签名,其他人不能盗用合法成员的私钥,伪造其签名结果。</li>
<li>非关联性<br>
除权威机构外,任何人想通过多个签名信息获得签名成员更多的身份信息,在计算上是不可行的。</li>
<li>可追踪性<br>
在签名结果产生争议时,群管理员或权威机构利用系统权限能够打开签名,查找到签名者的身份,即每一个群签名都是可被跟踪的。</li>
<li>不可否认性如果群组中任意一位合法成员用自己的私钥代表群组对消息进行签名,那么对于该群签名，他不能否认和抵赖。</li>
</ol>
</li>
</ol>
<h4 id="环签名">环签名</h4>
<ol>
<li>
<p><strong>环签名的定义</strong></p>
<p>环签名的概念首次由 3 位著名的密码学家于 2001 年提出，是指签名者在签名的过程中,通过引人其他人的公钥来隐藏自己私钥的一种签名方案。环签名的提出晚于群签名，一者有相似也有不同,可以把环签名看作是群签名的一种特殊形式或者是简化版的群答名。在环签名方案中,没有管理中心，没有环的创建,只有环成员,而且环成员之间不需要协同互助。当某个合法的环成员要对消息进行签名时,他首先创建一个临时群组，然后用自己的私钥和其他环成员的公钥独立地对一个消息进行签名，这样就能将自己的私钥信息隐藏在多个公钥中,不需要群组中其他环成员的帮助,同时这些环成员也不一定知道自己包含在某个群组中。</p>
<p>假设签名集合中有 $n$个环成员，一个完整的环签名方案主要由以下3个步骤组成。</p>
<ol>
<li>密钥产生<br>
输人安全参数$ λ$,对于系统中的每一位环成员,产生相应的公钥和私钥对$(k_{p_i},k_{s_i})(i=1,2,…,n)$,需要注意的一点是，这些公钥和私钥对可能来自不同的公钥密码体制。</li>
<li>签名<br>
输人数据$m$、签名者的私钥$k_{s_j}$和其他环成员的公钥$k_p={k_{p_i}|i=1,2,··,n,i\neq j}$,得到数据$m$的环签名$r$。</li>
<li>验证<br>
输人数据 $m$ 和环签名$r$,验证者作出该签名是否正确的判定,即签名者是不是群组中有效的环成员。</li>
</ol>
</li>
<li>
<p><strong>环签名的特性</strong></p>
<p>环签名具有良好的特性:可以实现签名者的无条件匿名,环签名是特殊的群签名,没有权威机构和初始建立阶段,签名者的身份信息对于验证者来说是完全匿名的;签名者对需要匿名的匿名区域和跨度具备决议权,即环成员的个数 是由签名者决议的;显而易见,对于群签名能够实现的功能,环签名也可以完成,并且参与方更少,不需要权威机构和管理员。</p>
</li>
<li>
<p><strong>环签名的安全性</strong></p>
<ol>
<li>正确性<br>
环成员依照既定的算法执行得到环签名结果,并且在传输过程中不存在篡改的情况那么签名结果就可以被验证通过。</li>
<li>无条件匿名性<br>
攻击者根据环签名,无法确定是哪个环成员生成了这个签名，即使他采用非法途径获得了所有可能的环签名者的私钥,攻击者确认真实签名者身份信息的概率不高于 1/n,n是可能的签名者的个数。</li>
<li>不可伪造性<br>
非签名者的环成员不能够捏造真实数据签名者的签名,对外部攻击者即便他截获了一个正确的环签名,可是他不知道任何环成员的私钥,不能够形成对该签名的捏造，捏造正确的概率是可以忽略不计的。</li>
</ol>
</li>
<li>
<p><strong>环签名与群签名的比较</strong></p>
<ol>
<li>相同点<br>
环签名和群签名都是某个成员代表整个群组对消息进行签名,对于验证者来说，他能够验证这个签名是否来自群体中的成员,而无法知道这个签名者到底是群体中的哪一个.即验证者只能验证签名的有效性,不能获得签名者的身份信息，以此来实现签名者的匿名性。</li>
<li>不同点</li>
</ol>
<ul>
<li>在群签名中,每一个签名都是可被跟踪的,只有群管理员具有系统权限，必要的时候可以追踪到签名者的真实身份信息;而环签名中没有管理员，因此签名无法做到可追踪性,除非签名者主动暴露自己的身份信息。</li>
<li>群签名中的群管理员负责系统的维护,环签名没有环的建立,签名者只是选取临时群组中环成员的公钥,每一个环成员的身份都是平等的。</li>
</ul>
</li>
</ol>
<h2 id="第4章-区块链共识协议">第4章 区块链共识协议</h2>
<h3 id="CAP原理">CAP原理</h3>
<p>CAP 原理是用于设计分布式系统的基本原理,由计算机科学家 Eric Brewer 所提出。CAP 原理定义一个分布式系统不可能同时满足一致性、可用性和分区容错性。CAP 原理阐述了这 3 个特性不能在异步通信网络环境中同时满足,只能满足其中任意两个特性，即满足一致性和可用性、一致性和分区容错性,或者可用性和分区容错性,如图 4.1 所示。具体来说,3 个特性的定义如下。</p>
<ol>
<li>一致性($Consistency$):指分布式系统中节点对事务操作具有原子性,每个操作都可以及时被完成,以至于所有的事务都是有序的。</li>
<li>可用性($Availability$): 指分布式系统必须响应正确节点发出的每个事务请求。</li>
<li>分区容错性($Partition-Tolerance$): 允许分布式系统中的部分节点接收不到其他节点发送的事务信息。例如,当分布式系统分区以后,一个分区的节点接收不到另一个分区的节点发送的事务信息。</li>
</ol>
<p>其中,一致性和可用性是依据一个分布式系统是否满足分区容错性的需要来定义的。换句话说,如果一个分布式系统必须具备一致性,那么即使有些节点没有接收到其他节点的信息,系统也要维持一致性这一特性。类似地,如果可用性是必需的,那么即使存在分区现象,系统也必须响应每一个正确节点的请求。因此,CAP 问题可描述为这样的问题:异步网络中的分布式系统在满足分区容错的情况下,可用性和一致性二者取其一。</p>
<p>用一个通俗的例子来理解 $CAP$ 问题:假设现在存在一个 A 地和 B 地共同维护的分布式数据库,用户 Alice 在 A 地的数据库修改了一项数据。在 A 地的数据跟 B 地的数据库同步该用户事务操作结果的时间内,B 地的用户 Bob 请求读取 B 地数据库的数据由于是在异步的网络环境下,存在网络延迟问题,A 地所发生的事务操作结果还没同到B地。如果要保证可用性,B 地的数据库必须对用户的读请求进行及时响应，而 Bol得到的数据肯定和 Alice 的数据不一样,这样显然不满足一致性。而如果要保证一致性那么B地数据库这时应该要锁定数据库且与 A 地数据库同步事务操作结果，然而,这个时候 B地的用户不能访问到 B 地的数据库,这样就失去了可用性。</p>
<p><img src="/img/blockchain_sec/4_1.png" alt="区块链扩展“不可能三角”"></p>
<p>区别于上述的 CAP原理,以太坊创始人 Vitalik Buterin 将区块链的可扩展性问题描述为“扩展不可能三角”问题。该问题在要求每个参与者验证每一笔交易的情况下,区块链最多只能满足如下 3 个特性中的两个特性:区块生成的去中心化性、安全性和可扩展性,如图 4.3 所示。实际上,区块链为了达到安全性和去中心化的特性,牺牲了可扩展性(可用性),因而无法满足很多实时应用场景的需求。然而,如果区块链系统要达到较好的可扩展性，同时满足较高的安全性,那么系统就不得不牺牲去中心化特性。同样地，既要实现高可扩展性以及完全的去中心化特性,安全性又会被削弱。实际上,如果要量化这3个特性，区块生成的去中心化性根据块生成者的数量来评估,安全性指攻击者发起拜占庭攻击成功的开销,而可扩展性可以通过区块链单位时间内处理的交易数量来评估。</p>
<h3 id="Paxos-算法">Paxos 算法</h3>
<p>Paxos 算法由著名计算机科学家 Leslie Lamport 提出，它是实现异步通信环境下容<br>
错分布式系统中共识问题的经典算法之一。值得注意的是,这里所说的容错是指容忍计算机崩溃而引发的错误$(Cash Fault Tolerance,CFT)$,如硬件错误、软件错误或内存错误,并非指容忍拜占庭错误。</p>
<p>首先，让我们来先回顾一下分布式共识问题。假设存在多个参与者,每个参与者都可以发出提议,每个提议中包含一个值,这里的共识问题是指有且仅有一个提议的值被选中。如果没有一个参与者提议值,则没有任何提议值被选中。如果一个提议的值已经被选中,那么所有参与者都会承认已选中的这个值。Lamport 将这个共识问题中的一致性描述成 3 个必须满足的条件。</p>
<p>(1)只有提议的值被选中。<br>
(2)有且只有一个值被选中。<br>
(3)每一个参与者仅承认被选中的值。</p>
<p>接着,Lamport 教授提出了支持容错的 Paxos 算法，以实现在异步网络环境下满足上述3个条件的共识算法。Paxos 算法主要解决用户在低可靠的服务器环境中,满足一定条件下即可实现可靠、确定的共识一致性。即使在不满足条件的情况下,也可以保证服务器实现一致性。</p>
<p>在介绍 Paxos 算法之前,首先先介绍该算法对参与者角色的定义和每个角色的职能具体来说,参与者被定义为三种角色:提议者、接受者和承认者。其中,提议者负责给出提议值,接受者接受和选中提议者提议过的值,承认者则是承认接受者选中的提议值。初步分析来看,只有一个接受者时是选中一个提议值最简单的情况,接受者接受并选中第一个由提议者发送给它的提议值就可以了。然而在这种单个接受者情况下,如果出现因机器导致的单点故障问题,就会直接导致接受者失败处理,共识问题就进行不下去了。因此,本节主要讨论存在多个接受者的情况,并且规定只有那个被大多数接受者接受并选中的提议者才被最终选中和被承认者承认(任意两个大多数接受者集合中都至少有一个相同的接受者)。为了更好地理解 Paxos 算法,需要了解描述算法应该满足什么样的要求才能解决共识问题。</p>
<p>首先,考虑实现即使只有一个提议者提议出一个值,也要选中一个提议值的情况。假定一个接受者必须接受它收到的第一个提议值(记为 P1),是否可以呢?答案是否定的因为当多个提议者提议出不同的值且每个接受者只接受了一个提议值时,不存在一个提议值被大多数接受者接受的情况。以只有两个不同提议值的简单情况为例,假设各有一半的接受者分别接受了一个提议,任何同时在两个大多数接受者集合的接受者如果出现失败的情况,都会导致没有一个提议者被选中。</p>
<p>P1 要求不完备,应该允许一个接受者可以接受不止一个提议值。通过给一个接受者可能接受的每一个提议值标上序号,不同的提议值一定有不一样的序号,先提议的值比后提议的值有更小的序号。现在我们考虑实现当一个提议值已经被大多数接受者接受了它就被选中的情况。在这个情况下,允许有多个提议值被选中的情况,但这些被选中的提议值必须确保是相同的一个值。</p>
<p>基于以上的考虑,定义如果一个提议值  被选中,那么任何一个具有更大序号、被选中的提议值也应该是 v(记为 P2)。如果 P2 被满足,那么就实现了只有一个提议者被选中。由于提议值被选中之前要先至少被一个接受者接受,那么设置条件 P2a: 如果一个提议值被选中,那么任何一个具有更大序号的、被一个接受者接受的提议值也应该是v。然而,P2a 满足了条件 P2 但不满足条件 P1。因为最初已经声明了网络是异步的,所以可能存在这样一种情况:一个刚刚“苏醒”的提议者提议了一个具有更大序号的不同于”的值,然后被某个刚刚“苏醒”的还没接受任何提议值的接受者接受了。注意到这个情况满足 P1 但破坏了条件 P2a,因此需要加强 P2a 的条件,定义条件 P2b 为如果一个提议值被选中,那么任何一个具有更大序号的、由任何提议者提议的值也应该是 v。条件P2b蕴含了 P2a,所以条件 P2b 也蕴含了条件 P2。接下来证明如果条件 P2b 被满足,才能解决共识问题。</p>
<p>假如某个序号为 m 的提议值 被选中了,那么证明任何由提议者提议的序号为n(n&gt;m)的值也是 就相当于证明任何由提议者提议的序号为 m,…,(n1)的值是。因为序号为 m 的提议值 被选中了,所以必须存在大多数接受者已经接受了这个提议值,记这个大多数接受者为集合 C。基于序号 n 的提议值,序号为 m 的提议值 被选中意味着C 中的每一个接受者已经接受了序号从 m 到(n-1)的一个提议值，且它们的值都为v。此外,由于任何一个大多数接受者集合和 C 至少包含一个共同接受者,因此在满足如下 P2c 条件的情况下,可以得出序号 n 的提议值也是v。</p>
<p>P2c: 如果一个序号为n 的提议值 被提议，那么存在一个大多数接受者集合 S 满足S 中没有一个接受者已经接受了任何序号小于n 的提议值，或者被 S接受的所有小于序号n 提议值中那个具有最大序号的提议值就是。</p>
<p>现在讨论满足 P2c 的情况,从而来证明序号 n 的提议值是。一个提议者提议序号为n 的提议值必须先承认已经(或即将)被大多数接受者接受序号最大的提议值。由于预测提议值是否将要被接受者接受比较困难，因此这个提议者只是承诺不存在这样的情况,也就是说,要求接受者不能再接受任何小于序号为 n 的提议值,具体定义如下。</p>
<p>(1)准备阶段。一个提议者选择一个序号 n,然后向每个接受者发出请求,要求接受者承诺:①小于序号 n 的提议值不会被接受;②已经接受的最大序号(序号小于 n)的提<br>
议值为 v。<br>
(2) 接受阶段。如果这个提议者收到的承诺是来自大多数接受者的,它就提议一个提议值 v,序号为 n;如果收到的承诺中没有包含提议值 即②不成立),它就提议一个自己选择的提议值 v,序号为 n。</p>
<p>在上述的定义下,我们得出这一结论:当且仅当一个接受者没有在准备阶段回复一个序号大于 n 请求的承诺,他就会接受一个序号为  的提议值。如果一个接受者在准备阶段接收序号为 n 的请求,而且他也回复过一个序号为 n+1 请求的承诺,那么他将不再接受序号为 n 的提议值,并且直接忽略序号为  的提议值。注意,接受者必须记住已经接受的序号最大的提议值和其序号。因此,Paxos 算法分为两个阶段,每个阶段包含以下两个步骤。</p>
<p><strong>阶段一</strong><br>
(1) 一个提议者在准备阶段发出一个序号 n 的请求给大多数接受者。<br>
(2) 如果一个接受者收到的请求所包含的序号大于他之前回复过的请求的序号，则他回复一个不再接受的序号小于 n 的提议值以及一个他已经接受的序号最大的提议值v。</p>
<p><strong>阶段二</strong><br>
(1)如果这个提议者收到来自大多数接受者的承诺,则他在接受阶段发送一个序号为 n 的提议值v。<br>
(2)如果一个接受者在接受阶段收到一个序号 n 的提议值同时他之前没有回复过为n的提议值V。备阶段序号为n+1的请求的承诺,那么他将接受这个序号为 n 的提议值。</p>
<p>假设存在1个提议者,3个接受者和2个承认者。图 4.4 展示了既不存在网络错误不存在机器错误情况下的 Paxos算法。其中V是指${V_a,V_b,V_c}$中最后的那个值或是提议者自己选择的值。图4.5展示了在有一个接受者因机器错误出现失败情况下,Paxo.算法仍然能实现共识。</p>
<p><img src="/img/blockchain_sec/4_2.png" alt="Paxos算法交互过程:不存在错误的情况"></p>
<p><img src="/img/blockchain_sec/4_2.png" alt="Paxos算法交互过程:存在一个错误接受者的情况"></p>
<h3 id="Raft-算法">Raft 算法</h3>
<p>4.3 节解析了第一个实现共识协议的算法-Paxos 算法,它在过去的几十年内一直是共识协议的代名词,但是该算法本身晦涩难懂,这使得它很难投人实际的应用。一些著名的计算机科学家甚至在 2012 年的计算机网络顶级会议 NSDI(USENIX Symposium onNetworked Systems,Design and Implementation)上表达了对 Paxos 算法的不满。于是同样解决了分布式共识问题的 Raft 算法以一种更易理解的方式被提出。</p>
<p>Raft 算法被分解为 3 个子问题,分别为选举领导节点、日志备份和一致性问题。Raft算法基于领导节点实现分布式节点对日志数据的共识,只要当前不存在领导节点,新的领导节点就会被选举。领导节点从客户端节点接收写人日志的新数据,同时发送消息同步其他节点的日志数据。在算法中,日志数据的数据项和它们的顺序是以状态机的形式进行更新的，一致性要求所有分布式节点的状态要保持相同。</p>
<p>在Raft 算法中,分布式网络节点被分为 3 种,即领导节点(Leader)、随从节点(Follower)和候选节点(Candidate)。在正常情况下,领导节点只有一个,其余的节点都是随从节点。领导节点的职责在于接收并处理客户端的所有请求，随从节点负责响应领导节点和候选节点发出的请求。而候选节点用于产生新的领导节点。另一方面,Raft 算法给出了任期这一定义,任期是指任意时长的时段,同时有一个连续的整数标识。开始一个任期意味着新的领导节点从候选节点中根据大多数投票原则选举产生,被选中的候选节点就成为该任期内的领导节点。值得注意的是,由于在异步网络环境下,网络可能出现通信分片的现象,这样可能导致在分布式节点中不存在大多数投票选出的领导节点。在这种情况下,该任期被中断,新的任期被开启,这保证了在任何情况下,一个任期内都最多只有一个领导节点。</p>
<p>图4.6 展示了节点在不同状态下的状态机迁移过程。每个随从节点各设置了一个任意随机时长的倒计时器(Election Timeout),通常为 150~300ms。一般情况下,节点在收到选举请求或者收到领导节点的心跳(Heartbeat)信息时会重新设置计时器。首先,节点从加人网络开始,假设网络中还不存在领导节点,它们会首先成为随从节点。此后,在一个计时器结束计时之后,这个节点状态自动变为候选节点。这时一个任期开始,候选节点向其他节点发出选举领导节点的请求消息。假设该节点获得大多数(超过半数)的投票，则该节点状态就变为领导节点,以上的过程称为选择领导节点。在领导节点任期内,它持续给其他的随从节点定时地发送心跳消息,从而确保其他节点状态的一致性。当网络中不存在领导节点向外发出心跳包时,开启新任期，随从节点变成候选节点重新选择新的领导节点。注意,每次收到领导节点的心跳包时,随从节点都要重置计时器。若在一个任期内,同时又有两个随从节点变成候选节点,并且都收到同样来自其他节点的票数,那么这个任期被中断,新的任期被开启。Raft 算法根据轮数来进行,每一轮的节点状态都会被记录下来,如果出现新一轮的选举过程,则原来的领导节点自动降级为随从节点。如果候节点 B转发请求给其他随从节点时,不能收到大多数随从节点承认请求的响应,于是它<br>
不可以执行“写人 3”的操作。当客户端 C2 向领导节点C发出“写人 8”的请求时,领导节点C最终可以收到大多数随从节点的承认响应,于是更新日志操作成功。如图4.9 所示假设节点 A、B、C、D 和E可以通信,领导节点 B收到任期序号更高的领导者C的心跳,于是停止发送心跳包。同时,节点 A 和 B 回滚它们没有收到承认的更新日志请求(“写人3”的请求)且与领导节点 C同步日志数据。</p>
<p><img src="/img/blockchain_sec/4_4.png" alt="网络分片时领导节点情况"></p>
<p><img src="/img/blockchain_sec/4_5.png" alt="Paxos算法交互过程:不存在错误的情况"></p>
<p><img src="/img/blockchain_sec/4_6.png" alt="结束网络分片时的同步节点日志"></p>
<h3 id="拜占庭问题与算法">拜占庭问题与算法</h3>
<p>拜占庭容错指的是一个可靠的分布式计算系统必须能够处理计算过程中的任意错误，除了容忍 Paxos 算法中的机器崩溃而导致的错误以外,还包括网络拥塞和遭到恶意攻击引起的错误。从拜占庭问题很容易联想到拜占庭将军问题，假设有 $n$ 个将军各自坚守在相互隔离的战地，通过信差相互通信并达成“进攻”或是“撤退”的一致性指令。然而,这$n $个将军中存在一些叛徒将军可能发送错误的指令，以此来阻挠所有忠诚的将军达成一致性指令的行为。计算机科学家 Lamport 教授形式化地证明了当叛徒将军至多为$m(m&gt;0)$,将军总数不小于$3m+1$的情况下,所有忠诚的将军都获得一致的指令。他把拜占庭将军问题归纳为一个施令将军向其他 $n-1$个副将军发送指令的问题。这个过程要实现指令一致性必须满足以下两个条件。</p>
<p>(1) 所有忠诚的副将军遵循一样的指令<br>
(2) 如果施令将军是忠诚的,则每个忠诚的副将军都会遵循施令将军发送的指令。</p>
<p>Lamport 教授指出当存在 1个叛徒将军、将军总数为3 时,拜占庭将军问题不能解决。如图 4.10 中所示,施令将军和副将军 1是忠诚的,副将军 2 是叛徒。施令将军向副将军 1和副将军 2 发送“攻击”的指令,忠诚的副将军 1 报告“攻击”指令给副将军 2,而叛徒副将军 2 会报告给副将军 1 其收到的是“撤退”的指令。副将军 1 必须执行“进攻”指令，上述条件(2)才可以满足。</p>
<p>假设施令将军是叛徒,副将军 1 和 2 是忠诚的,施令将军发出“攻击”指令给副将军1而发出“撤退”指令给副将军 2,如图 4.11 所示。由于副将军1不能判断施令将军和副将军 2哪一个是叛徒,因此对于副将军 1来说当前的情况与上面讨论的情况其实是相同的他都遵循“攻击”的指令。而对于副将军 2,为满足条件(2),他将执行“撤退”指令。最终将军们不能达成一致性的指令,上述条件(1)不满足。因此,基于这个例子,推广到有m个叛徒将军而将军总数少于 $3m十1$ 的情形时,解决拜占庭将军问题的方法是不存在的。</p>
<p><img src="/img/blockchain_sec/4_7.png" alt="将军总数为3、叛徒将军为1的情形"></p>
<p><img src="/img/blockchain_sec/4_8.png" alt="将军总数为3、施令将军为叛徒的情形"></p>
<p>接下来讨论在 $m$ 个叛徒将军总数不少于$3m +1$的情形下解决拜占庭将军问题的算法$OM(m)$。$OM(m)$算法规定一个施令将军使用口头消息直接向其他$n-1$个将军发出指令。默认情况下,口头消息满足$3$个假设。</p>
<p>(1)每条口头消息都被正确地传输。规定了叛徒不能干扰任意两个将军之间的消息传输。<br>
(2)接收者知道消息的发送者,不允许叛徒伪造其他将军发送的消息。<br>
(3)任何丢失的消息可以被检测到。允许将军发现叛徒不发送消息的行为,在这种情况下,接收者默认该消息为“撤退”指令。</p>
<p>此外,算法还定义了大多数投票函数 $majority(·)$用于从$n-1$个消息 $v_1,v_2,…,v_{n-1}$中获得大多数相同的消息 ,若不存在大多数相同的消息，则输出“撤退”。基于上述假设和大多数投票函数,算法$ OM(m)$的定义如下。</p>
<p>$OM(m)$定义:当$m=0$时,算法执行如下的操作<br>
(1)施令将军发送指令给每一个副将军。<br>
(2)每一个副将军执行从施令将军获得的指令,当没有收到任何指令时,执行“撤退”指令。</p>
<p>当$m&gt;0$时,算法执行如下操作。<br>
(1)施令将军发送指令给每一个副将军。<br>
(2)每一个副将军，收到施令将军的指令,记为$v_i$,若没有收到任何指令,则记为“撤退”;每个副将军作为施令将军执行算法 $OM(m-1)$,向其他$n-2$个副将军发送$v_i$。<br>
(3)每一个副将军，收到从其他副将军$j$($i$不等于$j$)获得的指令,记为$v_j$ ,若没有收到任何指令,则记为“撤退”。最后,副将军:执行大多数投票函数得出的指令$majority(v_1,v_2,…,v_{n-1})$。</p>
<p>实际上，$OM(m)$属子一种递归算法,递归调用 $n-1$次 $OM(m-1)$算法,这$n-1$次中每一次调用了$n-2$次$OM(m-2)$算法,如此递归下去，直到$ m=0$。</p>
<p>为了让读者更易理解 $OM(m)$算法,图 4.12 展示了$m=1、n=4$ 的拜占庭将军问题，4个将军中,副将军3是叛徒,其他将军是忠诚的将军。首先施令将军执行 OM(1)算法，发送指令v给3个副将军;然后,副将军1 执行 OM(O)算法发送指令v 给副将军 2。同时叛徒副将军3发送其他指令x给副将军 2,最后(上述定义(3)),副将军 2 获得了两个指令$v$和一个指令$x$,因此,他通过大多数投票函数得出指令 。</p>
<p><img src="/img/blockchain_sec/4_9.png" alt="将军总数为 4、徒副将军个数为1的情形"></p>
<h3 id="区块链共识基本需求">区块链共识基本需求</h3>
<h4 id="激励兼容">激励兼容</h4>
<p>区块链共识协议需要确保每位参与者能够基于他在区块链的实际贡献获得最高的收益,这称为激励兼容性(Incentive compatible)。在激励兼容的环境下,任何一个参与者不可以采取自私策略谋取更高的收益,否则,整个区块链的安全性不能得到保证。实际上，这一特性也体现了参与者节点在区块链获益的公平性,例如,在比特币中,矿工可以获得的收益与其在区块链上贡献的算力成正比，比特币的作者把这称为“一个 CPU 一个投票权”。</p>
<p>现实世界中对比特币的攻击,如自私挖矿(Self-mining)、女巫攻击(Sybil Attack),破坏了类似于比特币的区块链的激励兼容性。为提高交易吞吐量,有些区块链协议增加区块的大小和区块的生成速率,但这种措施也破坏了激励兼容性。这是因为当区块变大,该区块在网络中传播到所有节点的时间也变长。例如,网络中的参与节点可能还没收到之前的区块,新的区块就已经产生了,从而加重了区块链的分叉现象，破坏了激励兼容性。因此,如何设计支持高吞吐量又能满足激励兼容性的区块链是一个有挑战的问题。</p>
<h4 id="最终共识">最终共识</h4>
<p>最终共识(Final Consensus)是指所有诚实的参与者最终会对区块链的交易数据拥一致性视图,这主要是针对类似于比特币的区块链系统来说的，其他类型的区块链可以法到即时共识(Instant Consensus)。</p>
<p>在比特币区块链系统中,在大部分的参与者都是诚实的情况下,提交到块的交易数报被全网最终确认至少需要 6个区块的确认时间,这就是最终的由来。交易用户要等待丝1小时才能确信交易被最终写进了区块链,这使得比特币区块链系统不适合一些实时交易的场景,而实现即时共识的区块链则可以保证。即时共识指一旦某个区块被添加到区块链上,这个区块就再也不会被区块链抛弃。这类区块链的共识协议往往是基于传统的拜占庭共识算法实现的,属于这类区块链系统的包括 Hyperledger、PeerCensus 等。</p>
<h4 id="活跃性">活跃性</h4>
<p>活跃性是指区块链的参与者愿意持续地创建交易、处理交易和维护区块链的交易历史。区块链的活跃性受两个因素的影响:@参与者的收益贡献比;@区块的生成时间与传播时间。第一个因素指对参与者的金钱激励,它应该与参与者对区块链的贡献成正比,在这一方面,不少研究者讨论如何合理地设置交易费来保证参与者能持续有动力参与区块链。如果交易费太低,且相应的交易又总能被处理,那么久而久之,交易用户就会不愿意支付高的交易费用,进而导致矿工不会有动力去积极地处理交易、维护区块链。另一方面，区块的生成速率与传播时间也关系到区块链的安全性,较高的区块生成速率和较长的传播时间都会降低区块链的活跃性。</p>
<h4 id="正确性">正确性</h4>
<p>正确性是指区块链交易和区块数据的正确性。对于一般的数字加密货币系统来说最关键的安全特性是能够抵抗双重支付攻击。具体来说,签名算法保证了交易不能被伪造，同时有效的交易被添加到区块链后经过一段时间的确认时间最终成为被全网节点承认的正确交易,例如,在比特币区块链系统中,需要等待 6 个区块被确认的时间,大约为1小时。矿工通过竞争解答一个密码学困难问题,并生成一个正确区块,产生的区块的正确性被其他参与节点共同验证。</p>
<h2 id="第5章-区块链安全与隐私">第5章 区块链安全与隐私</h2>
<h3 id="区块链数据安全威胁">区块链数据安全威胁</h3>
<p>区块链之所以能够在以数字货币为代表的应用领域中大放异彩，同时也能够得到其他应用领域的广泛关注,是由于区块链系统具有去中心化、可追溯、不可篡改、不可伪造不可否认和可编程等特点。然而,区块链在安全和隐私方面的挑战仍然制约着区块链的快速发展。</p>
<p>首先,区块链是集信息安全与隐私保护于一体的新型技术,其相应的安全评估检测方法还处于发展过程中,这些技术(包括共识算法、激励机制、智能合约等)在某些关键环境下存在一定的安全隐患,并且已有的安全检测手段还无法完全应用到区块链中。例如,共识协议中的攻击问题:在 Pow 中存在的问题是集中51%算力攻击的问题,即攻击者若获得了整个区块链网络的 51%算力,就有控制整个区块网络的能力,其中也包括篡改和伪造。在比特币应用中,上述提到的 51%的攻击问题带来的后果是攻击者可以实现双重支付(Double Spending),于是提出了 PoS 协议来替换 PoW 协议,上述协议的替换有效避免了某种程度上 51%算力攻击的问题,然而新的问题会随之产生。现有的新的攻击问题有Nothing at Stake,此问题会导致共识节点不计成本地对区块链进行分叉处理，这样会造成区块链网络中不断地产生很多分叉。漏洞检测是安全问题的一个重要方面，从漏洞检测的角度出发，区块链无法提供有效的代码漏洞检测。例如在以太坊中,虽然提供了一些模板和测试环境以方便开发者开发智能合约,但由于智能合约逻辑的复杂性和分布式运行的特性,使得智能合约在代码的编写和密码模块的利用上不可避免地让黑客有可乘之机。同时,网络架构的不一致性使得传统的人侵检测技术无法直接适用到区块链系统中,这也是导致区块链上各种安全问题无法解决的重要缘由之一。其次,量子计算机、人工智能、大数据分析等计算机技术的快速发展同样给区块链带来了安全威胁。尤其是量子计算机的出现会对区块链的安全性造成巨大冲击,量子计算机一旦产生,任意大整数的快速分解从理论上就变得极其容易,破解长度为 1024 位的非对称加密密钥只需要很短的时间,一些传统的计算性理论假设不再成立,例如基于数论的困难假设不再是密码学上的“困难”问题。2019 年 10月 24 日,科技公司巨头谷歌的量子计算机研究团队在 Nature发表论文,此论文正式向世界宣告量子计算机已被成功研发,该计算机可以有效解决当前计算机不能解决的难题,量子计算机只用 3 分 20 秒就可以完成当前第一超算需要计算10 000 年的实验,这也表明基于传统非对称密码学的区块链技术在安全性上面临挑战。</p>
<p>此外,区块链的理论安全与实际应用安全之间还存在一些鸿沟。2014 年,JuanA.Garay、Aggelos Kiayias 和 Nikos Leonardos 3 位教授最先给出了有关比特币区块链的安全形式化分析和证明,列举了比特币有关的两个安全特性:公共前缀和链质量并通过协议分析得出比特币协议实现区块链的 3 个特性(活跃性、一致性和正确性)。虽然从理论上分析区块链的网络安全性比较高,但实际网络环境、用户自身安全意识和黑客主动攻击等方面的问题,仍然给区块链系统的应用带来了不可低估的安全威胁。鉴于区块链采用的网络结构是不同于传统的 P2P 结构,攻击者无法通过控制少部分节点的方式来实现对整个网络控制,但是由于实际网络部署时,各个节点之间配置的安全防护等级不同，导致攻击者可有针对性地从低安全防护等级的节点开始发起攻击,通过控制大多数节点阻碍区块链系统的正常运行。另一方面,用户在使用过程中对密钥的管理不严格,安全意识不足,或被钓鱼网站所诱骗,丢失自己的密钥,也会引发安全问题。以金融领域为例,由于区块链与金融紧密关联,相关的用户或者机构成为黑客的重点攻击目标,而一些传统用户应用层的攻击手段在区块链技术中依然可行,因此就其存在的安全问题,不论是用户自身引发的还是传统攻击手段引起的都不可忽视。</p>
<p>最后,匿名性、去中心化、防篡改性、自治化等特点虽然是区块链的技术标签,但与此同时也给区块链系统的安全监管带来了一系列难题。<br>
(1) 区块链的匿名性使得区块链网络系统中发生的漏洞利用等安全事件以及骗取数字货币等网络犯罪的溯源难度增加。当非授权用户利用区块链技术进行违法犯罪活动或者对系统实施攻击使得系统变得不安全时,系统很难追踪并从系统中剔除恶意用户和攻击者。例如勒索病毒，黑客利用操作系统漏洞将用户的文件进行加密处理,需要用户发送-定量的比特币来获取解密密钥。虽然比特币地址在用户交易的过程中是公开的,但其较高的匿名性使得无法链接到现实中的非法参与者。<br>
(2) 区块链的去中心化特性导致攻击者可以在更多方面进行攻击,使得系统的安全监管的难度增大,基于区块链的分布式存储模式,数据存储在不同的节点而不是集中式的服务器,且用户的通信传输方式为点对点,不需要通过可信的集中服务器或平台，因此用<br>
户交易过程中很难获取监管数据,监管的技术接口也难以实现。(3)区块链的防篡改特性为恶意信息的传播提供庇护,使对数据内容的监管变得异常困难。具体地说,攻击者通过交易的方式向区块链中写人一些非法信息,利用区块链自身的同步机制实现非法信息的迅速传播,由于防篡改特性使这些非法信息难以被删除,加大了互联网监管的难度。<br>
(4)数据安全责任边界不清晰。在实际应用中,节点通常指的是区块链平台、应用系统、数据所有者等实体,区块链中的这些实体互不信任,这会导致在出现安全问题时,难以划清安全责任界限。<br>
总而言之,区块链本身存在诸多呱须解决的安全问题,这些问题随着区块链应用技术的迅速发展变得更加突出。因此,确保区块链的安全性是当前区块链广泛应用面临的最棘手的问题之一。</p>
<h3 id="区块链隐私泄露威胁">区块链隐私泄露威胁</h3>
<p>5.1.1 节主要从与区块链相关的一系列安全问题进行了阐述,与此同时,由于区块链在各个应用领域迅速的扩展延伸,使其在隐私泄露方面的问题也受到广泛关注。区块链技术之所以能够迅速发展并应用到相应的各领域,其优势在于数据的存储和处理不依赖于某个中心节点,从而避免了单点故障和权限滥用的恶意行为,是传统的中心化架构、集中式服务无法比拟的。然而,区块链中的数据需要分布式网络中的各个节点来共同维护从而达到一致性共识,因此交易中的信息需要公开,让所有节点都能进行验证,这就使得区块链(主要指公有链、联盟链)上的公开信息毫无隐私可言。</p>
<ol>
<li><strong>身份信息泄露</strong><br>
公有链没有准人机制,任何节点(包括攻击者节点)都可加人网络中进行数据维护,监听区块链网络节点之间传输的数据。因此,当攻击者想要推测出某个交易者的身份信息时,首先分析获取到的交易数据,其次通过给出的背景知识,将二者结合得到最终的交易参与者的真实身份，上述攻击可以成功的原因在于区块链上交易数据是可以关联的。通过交易的关联性关系,攻击者可以削弱区块链地址的匿名性,甚至暴露用户的真实身份例如,Alice 在某个区块链交易平台上购买了一个比特币,它利用信用卡来进行支付,由于在美国 2000 美元以上的交易都需要实名,因此实名制使得攻击者可以通过交易的地址金额和时间等相关数据从支付地址关联到实际支付人,从而达到获取交易者身份信息的目的。</li>
</ol>
<p>数据挖掘技术为攻击者得到关联的交易地址提供了可能性。具体地,攻击者可以通过分析交易与交易之间的关系,得到某个地址的所有相关交易数据流。由于每笔交易都记录了所有的输人地址和输出地址的信息,通过对特定地址进行检索,就能够发现该地址的全部相关交易,只要任意一个地址对应的用户真实身份信息被暴露,其他所有和该地址有关的地址都可能属于这个用户或相关用户,会致使更多的用户隐私数据泄露。此外,区快链服务提供商也有可能存在某些漏洞被攻击者利用，泄露用户隐私。如 2015 年，比特而论坛 Bitcointalk 就遭受网络攻击,被攻击者窃取了 49.9 万用户数据,包括用户名、密码、电子邮箱等。</p>
<p>数据的公开透明既是区块链技术的优势,也是区块链技术的劣势,它使得敏感信息得不到保护,通过从区块链网络中提取有价值的敏感数据,联合不同网络和平台下的用户数据,即使用户的交易费用通过比特币进行支付,也无法保证其隐私的安全性。具体地，通过利用区块链浏览器,与比特币相关的每笔交易信息都是公开可查询的,包括资金流向(即发送地址、接收地址)、交易金额、交易时间等。虽然用户使用的是匿名地址,无法直接利用交易地址查询到交易者真实的个人信息,但要查询到用户的真实信息还是有迹可循的。根据现有的研究表明,即使通过隐私保护的方法实现身份隐私,但是利用数据挖掘等手段对比特币交易信息统计分析，同时结合一些现实非比特币的交易记录,能够确认出40%的比特币用户的真实信息。因此,简单地通过比特币的地址来实现用户交易的匿名性,这种匿名体制是不完善的,确切地说,是一种伪匿名性。</p>
<ol start="2">
<li><strong>交易数据泄露</strong><br>
大数据分析处理技术不断进步,基于大数据挖掘的分析技术可以将用户的真实身份和资金使用情况识别出来。《纽约时报》曾报道,根据用户的购物习惯、消费记录、出行数据等信息,可以准确地预测个人的隐私信息。例如,数据分析师可以通过用户的消费行为预测出某些女性购物者是否已经怀孕。一些看似无关紧要的数据可能揭示用户的敏感信息,而且一旦恶意用户出于经济利益等考虑去挖掘这类数据并进行非法利用,就很有可能损害其他合法用户的经济财产安全,甚至人身安全。</li>
</ol>
<p>在区块链与其他具体应用相结合的情形中,会涉及大量高度隐私的数据。例如,在金融业务场景中,用户与银行之间的交易记录或者银行之间的相互交易记录都是极其敏感的数据,属于银行的核心数据,因此不论是用户还是银行,都不希望彼此之间的交易记录被其他非授权用户查看。此外,在医疗场景中,多个医院组成的联盟链可以有效促进数据的共享、有利于病情的诊断,但是个人病情同样属于极度隐私的数据,患者并不想将个人的医疗数据公开地放置在区块链环境中。由此可以看出,若想要区块链技术及其应用覆盖到其他的应用场景，隐私泄露应该是最先需要解决的问题。</p>
<p>区块链的多节点共同维护、公开透明等特性是把双刃剑,这项技术在带来安全性的同时,也造成了新的数据隐私性问题。第 4 章中的区块链经典理论一一不可能三角,也即中心化、可扩展性和安全性三者之间的相互制约关系。同样,对于区块链的隐私性(安全性)和性能(可扩展性)之间的权衡也一直是实际应用中需要考虑的问题。为了做到安全的隐私保护,势必会影响系统的可扩展性,如何实现在保护数据隐私的同时依然能够支持不同节点针对数据进行安全、高效地验证是区块链领域中的热点研究方向,如何更进一步地保障区块链的隐私性就成为该领域的重要问题之一。</p>
<p>目前,从两方面考虑，既能保护隐私同时兼顾性能,有一种解决的方法就是提升硬件性能,例如,可以采用具有隐私保护功能的硬件设备 Intel SGX 同时保障效率。SGX 是由英特尔公司开发的,旨在为商用计算机上进行的安全敏感计算提供完整性和机密性的指令集扩展,SGX 的核心技术是封装,即通过提供硬件安全的强制性保障将合法的运行软件封装在 Enclave 中,为软件的执行提供可信的环境,防止恶意者的攻击以及软件的越权访问,但此技术并不能对所有的攻击都能够识别和隔离,只能保证 Enclave 中运行数据的机密性和完整性。</p>
<p>通过密码协议来增强区块链的隐私性保护也是研究的热门方向,包括使用零知识证明、安全多方计算等技术来解决链上交易公开透明的问题。目前针对区块链隐私保护机制的研究按照层级来划分,主要包括网络层、数据层以及应用层 3 方面的隐私保护。</p>
<p>总体而言,区块链利用自身的优势为去中心化的分布式系统提供了强大的技术支撑,但是区块链本身会面临不同的安全问题和隐私威胁。为了满足实际应用的需求,需要识别这些安全问题,同时要引人有效的机制来避免安全问题的产生。</p>
<h3 id="区块链安全目标">区块链安全目标</h3>
<p>虽然区块链被证明了在满足一定的条件之后在理论上是安全的,这包括区块链所使用的密码学技术,但是在实现过程和应用过程中,由于开发者没有充分预估系统的使用环境,使得区块链系统遭受了各种攻击行为。区块链的安全性问题涵盖范围较广,从用户应用端到底层数据端都有安全问题存在。本节以区块链存在的安全问题为切人点,依次介绍区块链应用过程中包含的安全性问题。具体来说,区块链的安全目标是指利用一些现有的密码学技术手段和实施方法来保障区块链系统的应用安全,其中,应用安全主要涉及应用过程中的数据安全、共识安全、智能合约安全、内容安全、密钥安全、跨链交易安全、隐私保护以及具体的密码算法安全的设计和证明等,如图 5.2 所示。在上述的主要标中,首先要实现的是数据安全,数据安全是其他方面各层级安全的基本前提。</p>
<p><img src="/img/blockchain_sec/5_1.png" alt="区块链的主要安全目标"></p>
<h4 id="数据安全">数据安全</h4>
<p>区块链实质上是一种去中心化的分布式存储系统,其保存有大量的与区块链相关的敏感数据,如用户的支付信息、交易过程、智能合约执行代码和具体的中间执行的状态等.如何保护敏感数据的隐私性是实现区块链安全的关键所在。下面基于信息安全方面的保密性、完整性、可用性、可控性和不可否认性 5 个特性定义区块链的数据安全。</p>
<ol>
<li>保密性</li>
</ol>
<p>保密性是指避免合法用户或者实体的敏感数据泄露给非授权的或者恶意的参与者在基于区块链的应用中,为了实现敏感数据的保密性,要求应用系统采用符合要求的、可靠的、具有安全性证明的身份认证算法、访问控制协议和安全审计机制。其中,身份认证算法是用来在计算机及网络环境中判断用户是否合法的一组认证规则,它是访问控制的基础。在传统的身份认证体系中最常用的方法是基于可信第三方的身份认证,主要是通过用户的口令或指纹等预存在平台的信息来确认用户身份。在区块链的身份认证中,每个区块或用户的加入方式和有效的身份鉴别认证方式都是确定的。例如,在公有链(如比特币中),身份认证是通过验证用户是否有合法的私钥(即口令)来验证用户身份的。为了实现身份认证又不破坏匿名性,学者们利用零知识证明方法提供相应的身份认证服务,被称为 ChainAchor 框架，此架构使得合法用户的身份可以有选择地打开,因为每个参与者都拥有多个有效交易身份。访问控制是一种按用户预设的身份来设定用户对某些信息项访问权限的技术。此技术是实现访问控制的一种最基本的方式,它允许授权用户按照权限级别来访问或使用系统的资源,任何非法用户对系统资源的访问都会被禁止。一般来说,通过对数据进行加密来实现访问控制,合法用户只有拥有与加密公钥相对应的解密私钥,才能满足访问权限,解密查看信息。对于公有链,其访问控制是通过私钥来实现的.用户可以任意加人公有链中查看数据、发送交易等操作,但在联盟链和私有链中,它有-套严格的准人机制,用户需要获得其他节点的同意才能有权限操作和访问链上的数据。</p>
<p>审计监管是指区块链能够对非授权的数据泄露事件进行监管,包括事件的监控、分析和追责等。它主要从法律层面保障区块链数据的保密性,确保非授权的数据泄露等不安全行为得到相应的惩罚,从管理角度来控制攻击者的恶意行为。</p>
<ol start="2">
<li>完整性</li>
</ol>
<p>完整性是指数据接收者得到的数据和数据发送者发送的数据是一致的,即在数据传输的过程中没有遭受恶意者的篡改。区块链利用冗余性较大的分布式数据库系统来保障链上数据的不可篡改性。区块链中的完整性主要指用户发布的交易信息、智能合约执行的中间状态不可篡改和不可伪造。在区块链中,任何已经确认的交易记录都不能被修改，已经发生的所有行为不可抵赖,例如,区块链系统中的攻击者若进行双重支付,则此行为无法抵赖。对于底层数据,数据完整性通常是基于相应的密码组件实现的,如数字签名哈希函数等。其中,区块链中最为典型的哈希值体系结构是基于默克尔树的,使其能够维护数据完整性,同时验证数据的有效性。在共识层面上,数据存储的一致性是依靠各类共识机制(如 Pow、PoS 等)实现的。</p>
<ol start="3">
<li>可用性<br>
可用性指合法用户可以对区块链系统中的数据随时地进行访同和使用。区块链系能的可用性首先应该具备抵抗单点放障和分布式容错的能力,使得系统在遭受各类攻击的仍然能够提供可靠的服务。同时,由于区块链网络主要是点对点的分布式结构,所以少分的节点受到攻击或产生放障将不会对整个区块链系统的运行产生较大的影响,系统可以对外提供正常的服务。然而现有的一些攻击行为,例如自私挖矿,通过控制少部分点来获取全网络超过 50%的资源,会影响区块链系统的可用性。此外,可用性还要求统在遭受实际攻击时,能够在一定时间内完成修复和重构,保证系统的正常运行。其次区块链系统的可用性还表现在能够为合法用户提供无差别服务,每个参与的节点都可以获得有效的、正确的数据,即使是新加入系统的节点也可获取相应的服务。</li>
</ol>
<p>在限定时间内响应用户的访问数据请求是可用性非常重要的一方面,在区块链系统中有限时间内响应用户的访问数据请求的主要表现形式为可扩展性。可扩展性在区块销中要求系统具有低延时、高交易吞吐量等特性,考虑到区块链体系结构存在着不可能三问题,为了使实现的系统具有更好的可扩展性,会在安全性、去中心化两个特性中牺牲基部分性能满足实际应用的需求。</p>
<ol start="4">
<li>可控性</li>
</ol>
<p>可控性指系统或数据在传输范围和存储空间的可控程度。对于区块链,可控性主要指区块链的数据在链上存储的可控安全程度。公有链中允许任何节点在任意时间都可加人,支持任意交易数据的发送,但是一定的匿名性使得非法的交易行为难以追踪。例如暗网中有许多的用户利用比特币来进行黑市交易,甚至成为比特币的最大用户,这在一定程度上对区块链系统的可控性造成很大的冲击。因此,构建安全可控的联盟链更加符合数据安全的要求。此外,对于使用区块链技术的合法用户,可控性需要保证在不同个体之间,实现数字资产或数据在链上的安全控制权转移,防止非法用户对这些资产或数据的操作控制。</p>
<ol start="5">
<li>不可否认性<br>
不可否认性通常指用户不能否认自己发送信息的行为以及信息的内容,也称不可抵赖性,在此处是指用户无法否认在区块链系统中的操作行为。在区块链中,用户发送的数据都通过交易的形式被记录下来,一且经过一定周期被确认后将无法修改。由于交易的产生与用户的地址唯一绑定拥有该地址的用户无法否认其在区块链中所做出的操作行为。不可否认性要求在不同参与者之间,用户无法抵赖以自己身份参与所完成的操作,需要与身份认证进行关联,同时系统支持安全审计功能.相关的审计日志需要被准确地记录下来。</li>
</ol>
<h4 id="共识安全">共识安全</h4>
<p>由于区块链网络中的节点包含个人计算机或移动客户端,与传统网络架构中的专用服务器相比,性能低、抗攻击能力差,所以这些节点很容易被攻击者或者恶意用户攻击此外,在中心化架构中,管理者只需针对一台或者少数几台服务器进行重点保护,而在区块链网络,所有节点地位平等,很难对地理位置分散的众多节点采用相同的防护措施,这样攻击者可以选取安全保护较为薄弱的节点进行人侵,破坏区块链网络中数据的同步性。</p>
<p>共识机制用来保证区块链网络中的节点能够对某个提案达成一致,例如所有节点就某个区块可以加人区块链的问题,以此来确保区块链主链上数据的一致性,这是区块链的核心思想。区块链上的共识安全是实现数据安全的基石,起着重要的作用。保证区块链系统的最终共识、激励兼容性、活跃性以及正确性是实现共识机制的核心,也是衡量共识<br>
安全的重要属性。其中，满足最终共识是共识安全中需要保证的最基本特性。</p>
<p>最终共识是不同节点在共同约定的协议的保障下,整个系统对某些操作行为产生的结果的一致认同。在区块链系统中,满足最终共识要求在数据达成共识并存储到区块链后无法被更改。也就是说,所有节点的最终共识只有在主链上达成才能对各类攻击者行之有效,因为只有在主链上形成共识,攻击者就无法通过在分叉链上达成共识、抛弃主链来实施攻击。激励兼容性和活跃性主要是指在区块链网络中,要有足够多的节点持续地参与到区块链系统的维护过程中,这需要共识协议能够提供持续可靠的激励机制吸引节点参与。如果攻击者可以通过某种方式破坏共识协议的激励机制,这就会影响正常用户参与使用或维护区块链的积极性,从而在一定程度上降低区块链的活跃性。正确性要求共识协议能够抵抗双重支付攻击。虽然理论上需要达到 50%以上的算力才能控制区块链网络实现双重支付,但是在实际的网络环境中,攻击者通过使用一些如自私挖矿之类的攻击策略,在一定周期之后,可以将全网的算力往自己设定的这条主链上来运行,使得原始的这条链被废弃,已产生的交易转账信息也随之失效。造成双重支付攻击的策略有很多种,本书将在第 8 章中进一步描述。</p>
<h4 id="智能合约安全">智能合约安全</h4>
<p>智能合约能够支持用户编写任意的代码逻辑,一旦部署之后,区块链网络中的任意节点都需要执行智能合约上的代码,且代码逻辑不可修改。当输人满足一定的条件后,合约就会自动运行程序,即使智能合约的发布者也无法阻碍程序的自动执行。正因如此,若存在漏洞问题无法通过传统补丁的方式去修改,只能重新部署合约,那么漏洞合约上涉及的金额也无法挽回。近年来,智能合约频繁出现漏洞,导致攻击案例层出不穷,给用户和社会带来了巨大的经济损失。</p>
<p>智能合约主要从软件代码层面来考虑其安全性。软件代码层面的安全由开发安全和运行安全两部分组成，同时,开发安全又包含逻辑安全和代码安全。逻辑安全即指开发人员首先应该在编写之前结合实际功能来设计符合逻辑的、简洁的、具有可行性的代码,因为代码出错的风险与复杂性是相关联的;其次,在代码的编写过程中需尽量使用安全且目前较为成熟的开发语言,并且需要确保符合规范,合约和函数可以进行模块化管理,并养成使用安全库的习惯。此外,开发人员要准确地掌握黑客常用的攻击手段,从而在代码的编写过程中尽量避免此类型的攻击,同时了解常见的智能合约漏洞,对编写的合约进行仔细地排查,保证编译后的代码不存在这些漏洞。</p>
<p>运行安全作为一种安全保护机制,它能够随时保持更新,是对智能合约在实际虚拟机平台或系统中运行的安全保护。运行安全的基础是保持更新,即当有新的漏洞被发现时，要及时检查部署智能合约是否受到影响。当用到的库或者工具有更新时,智能合约也要及时更新,并使用最新的安全技术。若智能合约的漏洞问题、甚至被攻击者攻击出现在执行过程中,运行安全的要求是不会对本地参与区块链的系统或设备造成影响,这就需要做到隔离运行,即智能合约并不运行在本地系统上,而是运行在系统的隔离环境中,如系统虚拟机等,这样在很大程度上避免了本地支持智能合约运行的系统遭受恶意者的攻击例如,以太坊为了实现代码在隔离环境中运行,专门提供了虚拟机供合约代码运行。同时运行安全也要求即使智能合约调用了有漏洞的合约,也不会执行异常。为了实现这个目标,需要确保智能合约在开发中尽量保证模块化,即合约逻辑简单化、代码函数模块化,且需要降低模块之间的依赖性,高耦合低内聚。使得智能合约能够通过接口的方式进行安全调用,并且达到阻止异常结果通过合约调用技术方式扩散到整个区块链的目的,在一定程度上有效地确保了智能合约的安全性和可用性。良好的模块化能够降低智能合约的复杂性,使得智能合约的设计、调试和维护简单化。</p>
<h4 id="内容安全">内容安全</h4>
<p>内容安全是对数据内容本身的规范性要求，它建立在数据安全的基础之上,主要描述的是存储在区块链分布式系统中的数据要达到法律法规的要求和符合用户道德规范的标准，阻止和避免不合要求的内容在网络中传播。那么要如何解决有关内容安全的问题呢主要的解决方式是有效控制不良信息在区块链上的传播和加强对信息的管理,探索对销上违法信息审核与用户隐私保护需求间的平衡，明确区块链开发者、区块链平台运行者<br>
区块链使用者等不同角色的安全责任。</p>
<p>针对区块链内容的攻击的主要形式包括恶意信息攻击和资源滥用攻击。其中,恶意信息攻击是影响区块链内容安全的主要攻击形式,它指的是攻击者刻意向区块链中写入恐怖信息、虚假信息等。这些恶意信息利用区块链数据传播速度快、达成共识后不可修改等特性,可以很快传播到全世界,造成极大的危害。区块链中的恶意信息使得区块链会被杀毒软件结束正常运行,或者引起政治敏感等问题。资源滥用攻击指的是节点之间恶频繁交互使得区块的数据量大幅度不可控制地增长,导致普通节点由于存储不足无法容纳区块数据。这就致使可以维护区块链稳定运行以及达成主链数据共识的可靠节点逐减少,从而区块链掌握在少数有计算资源、存储资源的大公司手中,从资源的存储和掌情况可以看出这与区块链的去中心化的特性不相符合。以以太坊的资源滥用攻击为例2017年 2月,攻击者利用大数量级别的垃圾交易信息来攻击以太坊 Ropsten 的测试链通过阻塞网络信道的方式导致区块链系统无法正常工作。</p>
<p>因此,内容安全可控是将区块链系统应用于各个场景的关键。内容安全也影响着政府和社会对区块链技术的接受度。在公有链中,数据一旦被用户匿名地记录就无法再对数据做出修改和追溯。因此探索基于联盟链架构的区块链应用场景对于规范内容安全重有意义,可以有计划地实施信息过滤、网络监测等技术手段为区块链的内容安全提供保魔。例如,已有研究机构(阿里巴巴)申请了与区块链内容保护相关的专利技术,该专利表明政府等机构需要以第三方管理员的身份加人系统并获取区块链中的交易数据。与此同时,该系统具有与其他区块链系统不同的特殊功能,可以向区块链发布特殊处理指令,目系统中的其他节点对于特殊指令的做法是先确认其合法,确认后才能公布到整个区块链网络,此过程是对预先设定的监管执行的智能合约的调用。</p>
<h4 id="密钥安全">密钥安全</h4>
<p>在区块链系统中,若代表着用户身份和数字资产的私钥被泄露则意味着用户丧失了对自身拥有的数字资产的支配权和控制权。因此,私钥安全为密码系统安全运行奠定了基础,也为区块链系统正常运行提供了保障。如图 5.3 所示,私钥安全指的是私钥整个生命周期的安全,主要包括私钥的随机生成,安全存储、使用,以及撤销、更新等阶段。区块链中的私钥一般由非对称算法产生,例如比特币采用基于圆曲线算法的非对称算法。非对称算法密钥主要是由随机数生成器产生的，通常使用满足随机预言机(RandomOracle,RO)模型的种子来作为随机数生成的基础。私钥的存储常常通过软件或硬件的方式来实现。软件的方式包括以文件或字符串的方式存储在服务器环境中,硬件方式一般利用现有的芯片设备或安全装置作为存储密码的工具和载体。这两种方式都存在被黑客窃取或暴力破解的风险。</p>
<p><img src="/img/blockchain_sec/5_2.png" alt="区块链的主要安全目标"></p>
<p>在私钥使用过程中,由于使用者可能遭受钓鱼、缓存侧信道等攻击,私钥将直接暴露给攻击者,这样会导致使用者失去对账户的唯一控制权。在基于中心化架构的传统应用系统中,若用户私钥丢失还可以向管理员提出申请并重新找回丢失的私钥。但在分布式的区块链中,没有管理员的角色来对参与交易的用户进行统一的私钥管理,所以用户自己就是自身私钥的管理者,而由于普通用户的安全意识不足,丢失私钥的情况就时有发生这是因为区块链系统一般存在钱包客户端(有网页版或独立客户端版),采用传统方法对用户发起的攻击形式,在区块链应用中依然存在,用户一不小心就极容易中招。因此,如可保护用户私钥的使用安全是区块链系统在设计过程中需要重点考虑的因素。</p>
<p>为了保证高可用性,区块链系统需要支持私钥的动态操作,如撤销和更新等,然而现有的比特币等公有链并不支持私钥的更新和撒销操作,只能通过重新申请的方式将数资产转移到另二个私钥所对应的公钥中。在实际的区块链集成应用场景中,需要考虑户由于意外而丢失私钥的情况,可以通过线下实名的方式找回，这类似于银行密码丢失用户通过户口或身份证来认证身份,重新设置密码。</p>
<h4 id="跨链交易安全">跨链交易安全</h4>
<p>1.6.1 节中的侧链技术是实现跨链交易的一种方式目前还存在包括公证人机制、中继、哈希锁定技术、分布式私钥控制技术等方式来构造的跨链交易方案。跨链技术出现的主要目的是实现了区块链系统中不同区块链之间的互通。大量的区块链应用平台随着区块链技术的推广应运而生,为了防止信息孤岛情形的出现,造成链与链之间的数据无法百通,实现不同链条之间的信息交互就显得十分必要。每个区块链网络都是相对封闭的独立系统,节点内部都会互不信任,因此要解决不同链之间的互信问题就非常困难。一般司以通过解决两条链之间的双向错定问题来实现链与链之间的交易，假设在 A 链上生成 p链上的铺定币,那么需要同时将 B 链上等价的数字货币进行锁定，类似于 B 链上的数字货币跳转到 A 链上进行使用。在实际操作过程中，需要解决两条链之间应用程序互操作性以及数据的无缝更新性问题,保证两条链的实时、准确交互。如果是通过设计一种中间链来对接两条链的方式,例如 FUSION 公有链分布式控制权服务(Distributed ControRights Service),利用锁人和解锁技术实现代币分布式控制权管理获得和解除，这一技术能够确保操作的准确性,防止两边同时都具有或都不具有对代币的控制权，保证跨链操作的原子性。</p>
<h4 id="隐私保护">隐私保护</h4>
<p>区块链系统中的信息在交易过程中为了实现各个节点间数据的同步和交易的共识是需要对外公开的,例如交易金额或中间状态。除此之外,攻击者可以通过用户交易之间的关联性对用户隐私信息进行推断。并且区块链系统中利用全局公开的账本存储所有用户的所有交易,因为存储账本是全局公开性的,使得攻击者可以很容易地获得交易的所有数据。通过分析交易中的关联关系,攻击者能够逐步降低区块链地址的匿名性,甚至能够发现匿名地址所关联的用户真实身份信息。因此,系统通过处理用户敏感数据减少隐私泄露的方式来保护用户的隐私。区块链中的关于数据隐私保护问题主要包含身份隐私保护和交易数据隐私保护。</p>
<p>(1) 身份隐私(Identity Privacy)保护。身份隐私是指参与交易的用户的真实身份和交易记录之间的链接关系是保密的且无法关联的。实现匿名性保护是电子现金中身份隐私的核心问题。中本聪描述了理想电子现金的 6 个标准,其中就包括隐私保护,指的是用户与其交易之间的关系必须是任何人都无法追踪的。具体地,完全匿名的数字货币模型必须满足以下两个属性。<br>
①不可追踪性(Untraceability): 对每笔交易的输人,都无法推测出是否由同一个人发起。<br>
②无关联性(Unlinkability): 对于区块链中任意的两笔交易输出,都无法链接到一个交易用户。<br>
(2)交易数据隐私(Transaction Data Privacy)保护。在区块链中,除了区块头之外其余的数据属于交易信息,它包括参与者的地址信息、交易金额、交易时间等。此外,对于以太坊这种支持图灵完备智能合约的区块链系统,如果构建一套去中心化的 DApp,交易还可以用来保存用户其他的信息，例如中间状态变量、交易总量等信息。交易数据隐私就是指这些交易中所包含的敏感记录。一般写人交易中的数据是否需要进行隐私保护是以用户的需求和场景而定的。</p>
<h4 id="密码算法安全">密码算法安全</h4>
<p>随着量子计算机的迅速发展,这给传统密码算法协议的安全性带来了严峻威胁。研究抗量子计算安全的密码算法已经成为密码学领域的一个重要课题。同样地,由密码学底层构建的区块链技术也会受到巨大的冲击。目前,量子计算机的研发在全球各地科研工作者的努力下正逐渐成为可能。2015 年,对量子计算机有很深造诣的 IBM 研究机构研发了一台能够进行量子计算云服务的量子计算机,并免费对外开放使用权,尽管此台计算机仅仅含有 5 个量子位。2018 年和 2019 年,谷歌和IBM 公司在美国物理学年会和国际消费电子展上先后推出了量子计算模型和量子计算芯片。另外,D-Wave 公司不甘落后,也积极推出量子计算机。因此,研究抗量子计算攻击的区块链技术迫在眉睫。</p>
<h3 id="区块链层级分类安全">区块链层级分类安全</h3>
<p>在 5.2 节的介绍中,主要介绍了与区块链相关的数据、共识等的安全目标。各个目标也说明了区块链在当前阶段中还存在着诸多的安全威胁,黑客的攻击手段层出不穷,如果在使用或者开发过程中不重点防范,则会出现相应的安全问题。此外,数字货币基于区块链技术去中心化的优势使得跨境交易的流程变得简单且交易效率提高,但各个国家对加密数字货币所持有的态度相差较大,缺乏国际上统一的规范，这也让监管区块链系统变得更加困难。因此,掌握已有的或可能有的安全问题对进一步开发和使用区块链技术非常重要。</p>
<p>如图 5.4 所示,可以将区块链系统分为应用层、智能合约层、共识层、网络层以及数据层。本节从五层结构出发,简要分析和列举每层可能遇到的安全风险。</p>
<p><img src="/img/blockchain_sec/5_3.png" alt="区块链层级结构"></p>
<p>(1)应用层主要功能是为了用户之间进行交互,实现分布式账本状态更新。应用层<br>
主要指各种区块链的交易平台、钱包客户端、Web 应用端等,主要关注私钥管理以及应用客户端等存在的安全问题。</p>
<p>(2)智能合约层是区块链系统的基础也是关键。关键在于它是用户用来实现去中心<br>
化DApp 的主要模块,它封装了与应用需求相对应的逻辑算法和实现代码。基础在于它是编写区块链系统的主要组成部分,从非图灵完备的脚本代码(如比特币)发展到图灵完备的智能合约(如以太坊),但由于在开发过程或合约运行过程中的安全问题,导致在智能<br>
合约层中存在的安全威胁相对较多。</p>
<p>(3)共识层主要包括各类共识算法和激励机制,包括 PoW、PoS 和 PBFT 等共识算法。在实际网络的部署和共识算法的安全假设中存在一定的鸿沟，会导致节点之间最<br>
共识的不一致性。</p>
<p>(4)网络层主要由两个机制和一个网络组成,包括传播机制、通信机制和分布式网络等技术。对于网络层来说,它涉及的安全问题属于传统安全问题范畴,例如分布式拒绝服务(DDoS)攻击、日蚀攻击(Eclipse Attack)等。此外，网络层还关注隐藏网络节点的数据接口,有一种攻击方式是利用网络节点不该暴露的接口挖掘节点和用户信息,从而实现数字货币非法转移的目的,造成用户经济损失。</p>
<p>(5)数据层主要涉及底层的区块、交易等数据的存储和管理。一般来说,数据层安全性是由密码学理论所支撑的,常用的密码学算法包括数字签名、哈希函数和零知识证明等。密码学算法经过许多年的研究和发展,技术水平已经较为成熟。但是,在一些具体的区块链项目,由于对底层技术不熟悉或者本身区块链平台的不完善,会造成项目中存在一些安全隐患。数据层作为区块链的底层基础构建,一旦出现漏洞等应用问题,就会给上层的应用带来严重危害。</p>
<ol>
<li>应用层<br>
在应用层中,用户会与该层的各种应用程序进行直接交互,无须考虑底层的技术实现。一般来说,应用层与区块链具体的应用有着密切的关系,目前区块链技术的应用场呈现出越来越广泛的趋势,典型的包括数字金融业务、数据版权保护应用、供应链管理等数字金融类场景是区块链技术的早期应用方式,除了比特币以外。目前已经出现大量的争币，例如以太币、零币、门罗币等。用户可以通过各种各样的数字货币客户端实施交易内买一些商品或者服务。这些数字金融类的应用都有各自对应的客户端,例如比特而专门的比特币钱包,而以太坊也有专门的以太坊钱包。</li>
</ol>
<p>区块链系统应用前景极为丰富，这也让区块链系统本身面临前所未有的挑战。应用层通常与区块链系统直接交互,因此它面临的安全挑战主要由以下3方面引起。</p>
<p>(1)传统攻击威胁:传统针对 We 网页或动客户端的攻击方式在区块应用层中也适用,恶意攻击者常常可以利用一些传统的攻击手段对区块链系统实施攻击,例如钓佳网站、App 伪造漏洞直接盗取用户的个人私钥。所以,防御传统攻击是区块链应用层安全中需要解决的首要问题。</p>
<p>(2)第三方服务漏洞:区块链系统还依赖区块链服务提供商和第三方中介机构。例如,用户为了管理自己的密钥,可能使用比特币钱包供应商提供的密钥管理服务，这样攻击者就可以利用后门攻击等方式窃取用户的密钥。</p>
<p>(3)客户端开发漏洞:在应用客户端开发过程中,代码漏洞是一个难以完全杜绝的问题,特别是利用第三方进行开发,很可能产生越权漏洞或遭受供应链攻击等威胁。</p>
<ol start="2">
<li>智能合约层<br>
智能合约给用户带来了可编程的区块链应用能力,用户可以无须关心如何设计区块链底层协议(如共识协议、交易模式等),只要具备一定的计算机基础都可以创建智能合约来构建去中心化应用，也可以通过调用智能合约接口的方式来使用去中心化服务。然而,智能合约技术给人们带来许多技术上的优势,但是使用该技术也不得不去应对诸多的安全挑战。主要原因在于,智能合约这一概念由来已久,但真正开始在区块链中使用的时间却不长,由于对其底层的运行机制和原理了解不深,对开发者和普通使用者还是极容易出现安全问题。据腾讯安全团队统计,2018 年上半年,仅仅由于智能合约漏洞而造成的直接经济损失就超过数十亿美元,智能合约技术当前面临的主要问题包括以下 3 点。</li>
</ol>
<p>(1)代码开发漏洞:大部分的智能合约安全漏洞是由于创建者在编写智能合约代码时无意识地埋下了安全隐患。区块链中的智能合约,如以太坊,默认采用的编程语言是Solidity。由于合约代码和传统的 Java/C++ 等代码运行模式不同,导致出现了一套新的编程需求和规范，然而很多的开发者在还没有完全掌握该语言的情况下就发布了智能合约代码,导致被攻击者利用,造成使用者的经济损失。例如,有学者发现以太坊上有上百万个智能合约不符合 ERC-20 标准的代币(Token)合约,存在潜在的安全威胁。此外,也存在部分合约漏洞是创建者有意识地在合约中设置陷阱的情况,其利用使用者对合约的不熟悉来获取某种经济利益。目前,代码开发过程中产生的漏洞形式包括可重人攻击、交易依赖攻击、时间戳依赖攻击等。</p>
<p>(2)验证机制不完善:智能合约目前还缺少有效的形式化验证机制来保证合约的运行安全。一般而言,一种语言的发展会伴随着各种的组件和工具的产生,主要是为了提供便捷的调用和安全性检查。区块链中的智能合约由于发展时间还不是很长,相应的生态<br>
还未完善,这也是导致智能合约出现安全漏洞的原因之一。</p>
<p>(3)外部调用漏洞:创建者会依赖一些可信实体,通过提供对外数据接口来实现智合约与外部系统的连接。预言机是区块链智能合约与外部 Web API 对接的实体,但是由于中心化的原因,其自身的可信度也存在疑问,而且容易遭受外部黑客攻击或发生自身单点故障的问题。</p>
<ol start="3">
<li>共识层<br>
共识层能够保证区块链的正常运行,是区块链的核心所在。共识层安全主要依据共识机制来确保区块链节点在复杂的网络通信模式中共享同一份有效的区块链视图，即它能够为全网对区块链数据的一致性提供保障。不同的共识协议或多或少都存在这样或那样的安全问题,现有的破坏共识层安全的攻击方式多种多样,如自私挖矿攻击、女巫攻击等，主要的原因包括以下 3 点。</li>
</ol>
<p>(1) 缺乏形式化安全证明:共识机制的安全性依赖于网络实际运行环境,包括时序性、节点数量、资源(算力或权益)分布等因素。传统的安全性分析方法不能全部应用于区块链场景，造成共识机制缺乏有效的安全性证明。</p>
<p>(2)安全性假设较强:与传统密码方案将安全性归结为计算困难问题不同,共识机制的安全性是基于假设节点的诚实比例,对于不同的区块链网络,由于加人节点的数量能力等不同,诚实比例的数量很容易发生动态性调整,造成共识协议的安全假设不成立。</p>
<p>(3)扩展性较差:可扩展性是区块链不可能三角重要的一方面,为了保证去中心化的特性,往往以牺牲区块链的可扩展性为代价,比特币就是最典型的例子,它要耗费 10 分钟才会生成一个新的区块,确认一批交易。如何改善区块链自身存在的可扩展性差的问题，同时保证一定的去中心化安全特性是目前区块链共识层重点考虑的方面。</p>
<ol start="4">
<li>网络层<br>
区块链系统网络层可以确保各个区块链节点之间通过点对点网络进行有效的数据传输。区块链网络采用 P2P技术进行节点与节点之间的通信,具备去中心化、动态变化等特性。在公有链中,网络中的节点由关系平等的服务器构成,散布于不同物理位置的任何节点可以在任何时刻自由地选择加入或者退出区块链节点网络。典型地，如比特币网络就是建立在互联网基础之上,来自全球各地的任何节点可选择在任意时候退出。截至2019 年6月,比特币网络的节点数量已经超过 5000 个,总体节点数量大约为10万个。</li>
</ol>
<p>网络层中的安全问题主要是 P2P 分布式网络安全和隐私保护。在 P2P 分布式网络安全中,与传统的客户-服务器架构模式相比,P2P 分布式网络无法使用防火墙来实现内外网隔离或使用人侵检测技术来有针对性地进行防御,而且 P2P 中的节点由于安全等级和防护能力不统一,更容易遭受安全攻击。另一方面,根据分布式点对点网络的拓扑结构,可以依据网络通信的路由信息有针对性地发起攻击行为,例如,日蚀攻击就是这种攻击方式的典型代表,通过破坏目标节点与主网节点数据视图的一致性为其他攻击行为提供铺垫。</p>
<p>在网络层安全中，隐私安全问题表现得更为明显,尽管对区块链中传输的数据进行了加密处理,攻击者无法查看到明文信息,但是通信的路由信息显示了节点之间的源地址和目的地址,攻击者可以通过监听不同交易发起者的 IP 信息来推测出用户的隐私信息。</p>
<ol start="5">
<li>数据层<br>
数据层是在网络层基础之上,提供区块链数据的管理功能。一般来说,可以从 3 个层而理解数据库系统的可信度:存储可信度、处理可信度和外部访问可信度,如图 5.5所示。</li>
</ol>
<p>(1)存储可信度:指当区块链上的数据结果被确认保存后会避免数据丢失或数据被篡改的情况。存储可信度要求系统能够提供传统数据库管理系统和事务处理中所要求的事务持久性,同时也要求数据库系统在出现存储错误、通信故障或遭受蓄意攻击时,仍可以保证数据存储的正确性。</p>
<p>(2)处理可信度:指数据处理(计算)的正确性,也指数据处理过程和输出结果可审计与可溯源。即使通过共识算法来保证对于主链的共识,分布式的区块链网络架构也会由于网络延时、外部攻击等问题造成各节点在同一时间点上所看到的数据视图的不-致。因此,如何在保证数据处理正确性的前提下平衡性能是处理可信度重要的考量指标。同时,多节点验证机制和链式的数据记录方式天然支持了数据的可审计性和可溯源性。</p>
<p>(3)外部访问可信度:指数据库的访问控制机制,允许具备访问权限的用户来操作和查看数据库,阻止非法用户查看和使用数据库中的数据。外部访问可信度依据不同的应用场景(如公有链、联盟链),有不同的访问控制机制。</p>
<p>一般来说,对区块链数据层的恶意攻击包括以上 3 方面。区块链上的数据主要保存在各个区块上,区块与区块之间以链式数据结构的方式链接。区块链上的数据所面临威胁主要有资源滥用和恶意信息攻击。</p>
<p>此外,数据层中非常重要的一个方面是数据的隐私保护问题。区块链中的交易记录在往是公开可查询的,没有使用任何额外的数据保护技术对其进行保护。区块链交易记梁或多或少地包含一些敏感数据,有可能泄露用户的隐私。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://timefy.github.io">水木时</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://timefy.github.io/posts/665ba237.html">https://timefy.github.io/posts/665ba237.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://timefy.github.io" target="_blank">水木时</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">学习记录</a><a class="post-meta__tags" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a></div><div class="post_share"><div class="social-share" data-image="/img/img/6.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/776f3c45.html" title="隐私保护相关"><img class="cover" src="/img/img/7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">隐私保护相关</div></div></a></div><div class="next-post pull-right"><a href="/posts/76189c5e.html" title="信息泄露"><img class="cover" src="/img/img/5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">信息泄露</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/2fa412f3.html" title="MahtJax语法入门指南"><img class="cover" src="/img/img/10.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-09</div><div class="title">MahtJax语法入门指南</div></div></a></div><div><a href="/posts/79b9413.html" title="数学符号参考"><img class="cover" src="/img/img/11.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-16</div><div class="title">数学符号参考</div></div></a></div><div><a href="/posts/776f3c45.html" title="隐私保护相关"><img class="cover" src="/img/img/7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-06</div><div class="title">隐私保护相关</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/img.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">水木时</div><div class="author-info__description">以其德，悟其道</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/timefy"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">以德立身，融道于行</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E7%BB%AA%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">第1章 绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.1.</span> <span class="toc-text">区块链本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.2.</span> <span class="toc-text">区块链技术是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E9%98%B6%E6%AE%B5"><span class="toc-number">1.3.</span> <span class="toc-text">区块链技术发展阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7"><span class="toc-number">1.4.</span> <span class="toc-text">区块链基础特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%95%E5%8F%91%E7%9A%84%E6%B7%B1%E5%88%BB%E5%8F%98%E9%9D%A9"><span class="toc-number">1.5.</span> <span class="toc-text">区块链引发的深刻变革</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6"><span class="toc-number">1.6.</span> <span class="toc-text">智能合约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E6%9C%89%E9%93%BE%E3%80%81%E7%A7%81%E6%9C%89%E9%93%BE%E3%80%81%E8%81%94%E7%9B%9F%E9%93%BE%E5%AF%B9%E6%AF%94"><span class="toc-number">1.7.</span> <span class="toc-text">公有链、私有链、联盟链对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B"><span class="toc-number">1.8.</span> <span class="toc-text">区块链技术演进</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E5%8C%BA%E5%9D%97%E9%93%BE%E6%9E%84%E9%80%A0"><span class="toc-number">2.</span> <span class="toc-text">第2章 区块链构造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E7%89%B9%E5%B8%81%E7%BD%91%E7%BB%9C%E6%A6%82%E8%A7%88"><span class="toc-number">2.1.</span> <span class="toc-text">比特币网络概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E7%9A%84%E5%85%B7%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">区块的具体结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%9A%BE%E5%BA%A6-%E7%9B%AE%E6%A0%87%E5%80%BC"><span class="toc-number">2.3.</span> <span class="toc-text">区块难度&#x2F;目标值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%98%93"><span class="toc-number">2.4.</span> <span class="toc-text">交易</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91"><span class="toc-number">2.5.</span> <span class="toc-text">区块链网络拓扑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.6.</span> <span class="toc-text">区块链网络协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%95%B0%E6%8D%AE%E4%BC%A0%E6%92%AD"><span class="toc-number">2.7.</span> <span class="toc-text">区块链数据传播</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E8%8A%82%E7%82%B9"><span class="toc-number">2.8.</span> <span class="toc-text">区块链节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80"><span class="toc-number">3.</span> <span class="toc-text">第3章 区块链密码学基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BE%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%80%A7%E8%B4%A8"><span class="toc-number">3.1.</span> <span class="toc-text">群的基本定义及性质</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BE%A4%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.1.</span> <span class="toc-text">群的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BE%A4%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">3.1.2.</span> <span class="toc-text">群的性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E9%99%90%E5%9F%9F"><span class="toc-number">3.1.3.</span> <span class="toc-text">有限域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%BE%A4%E3%80%81%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E7%BE%A4%E5%92%8C%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%98%A0%E5%B0%84%E7%BE%A4"><span class="toc-number">3.2.</span> <span class="toc-text">整数群、椭圆曲线群和双线性映射群</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%BE%A4"><span class="toc-number">3.2.1.</span> <span class="toc-text">整数群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E7%BE%A4"><span class="toc-number">3.2.2.</span> <span class="toc-text">椭圆曲线群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%98%A0%E5%B0%84%E7%BE%A4"><span class="toc-number">3.2.3.</span> <span class="toc-text">双线性映射群</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9B%B0%E9%9A%BE%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.</span> <span class="toc-text">密码学困难问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.1.</span> <span class="toc-text">离散对数问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0%E9%97%AE%E9%A2%98%E5%AE%9A%E4%B9%89"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">离散对数问题定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0%E9%97%AE%E9%A2%98%E6%80%A7%E8%B4%A8"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">离散对数问题性质</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.2.</span> <span class="toc-text">大整数分解问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CDH-DDH-%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.3.</span> <span class="toc-text">CDH&#x2F;DDH 问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BDH-DBDH-%E9%97%AE%E9%A2%98"><span class="toc-number">3.4.</span> <span class="toc-text">BDH&#x2F;DBDH 问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="toc-number">3.5.</span> <span class="toc-text">哈希函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-number">3.5.1.</span> <span class="toc-text">哈希函数定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E4%B8%BB%E8%A6%81%E6%80%A7%E8%B4%A8"><span class="toc-number">3.5.2.</span> <span class="toc-text">哈希函数主要性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">3.5.3.</span> <span class="toc-text">哈希函数安全性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8"><span class="toc-number">3.5.4.</span> <span class="toc-text">哈希函数主要应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91"><span class="toc-number">3.6.</span> <span class="toc-text">默克尔树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">3.7.</span> <span class="toc-text">布隆过滤器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D"><span class="toc-number">3.8.</span> <span class="toc-text">数字签名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.8.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D"><span class="toc-number">3.8.2.</span> <span class="toc-text">椭圆曲线数字签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EIGamal%E7%AD%BE%E5%90%8D"><span class="toc-number">3.8.3.</span> <span class="toc-text">EIGamal签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%AD%BE%E5%90%8D"><span class="toc-number">3.8.4.</span> <span class="toc-text">多重签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BE%A4%E7%AD%BE%E5%90%8D"><span class="toc-number">3.8.5.</span> <span class="toc-text">群签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E7%AD%BE%E5%90%8D"><span class="toc-number">3.8.6.</span> <span class="toc-text">环签名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.</span> <span class="toc-text">第4章 区块链共识协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAP%E5%8E%9F%E7%90%86"><span class="toc-number">4.1.</span> <span class="toc-text">CAP原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Paxos-%E7%AE%97%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">Paxos 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Raft-%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">Raft 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%9C%E5%8D%A0%E5%BA%AD%E9%97%AE%E9%A2%98%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="toc-number">4.4.</span> <span class="toc-text">拜占庭问题与算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B1%E8%AF%86%E5%9F%BA%E6%9C%AC%E9%9C%80%E6%B1%82"><span class="toc-number">4.5.</span> <span class="toc-text">区块链共识基本需求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BF%80%E5%8A%B1%E5%85%BC%E5%AE%B9"><span class="toc-number">4.5.1.</span> <span class="toc-text">激励兼容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E5%85%B1%E8%AF%86"><span class="toc-number">4.5.2.</span> <span class="toc-text">最终共识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BB%E8%B7%83%E6%80%A7"><span class="toc-number">4.5.3.</span> <span class="toc-text">活跃性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E6%80%A7"><span class="toc-number">4.5.4.</span> <span class="toc-text">正确性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E4%B8%8E%E9%9A%90%E7%A7%81"><span class="toc-number">5.</span> <span class="toc-text">第5章 区块链安全与隐私</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81"><span class="toc-number">5.1.</span> <span class="toc-text">区块链数据安全威胁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E9%9A%90%E7%A7%81%E6%B3%84%E9%9C%B2%E5%A8%81%E8%83%81"><span class="toc-number">5.2.</span> <span class="toc-text">区块链隐私泄露威胁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E7%9B%AE%E6%A0%87"><span class="toc-number">5.3.</span> <span class="toc-text">区块链安全目标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8"><span class="toc-number">5.3.1.</span> <span class="toc-text">数据安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E8%AF%86%E5%AE%89%E5%85%A8"><span class="toc-number">5.3.2.</span> <span class="toc-text">共识安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8"><span class="toc-number">5.3.3.</span> <span class="toc-text">智能合约安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8"><span class="toc-number">5.3.4.</span> <span class="toc-text">内容安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E5%AE%89%E5%85%A8"><span class="toc-number">5.3.5.</span> <span class="toc-text">密钥安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E9%93%BE%E4%BA%A4%E6%98%93%E5%AE%89%E5%85%A8"><span class="toc-number">5.3.6.</span> <span class="toc-text">跨链交易安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4"><span class="toc-number">5.3.7.</span> <span class="toc-text">隐私保护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E5%AE%89%E5%85%A8"><span class="toc-number">5.3.8.</span> <span class="toc-text">密码算法安全</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B1%82%E7%BA%A7%E5%88%86%E7%B1%BB%E5%AE%89%E5%85%A8"><span class="toc-number">5.4.</span> <span class="toc-text">区块链层级分类安全</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/6cfa7377.html" title="《用概率思维提高胜算》_刘润"><img src="/img/img/13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《用概率思维提高胜算》_刘润"/></a><div class="content"><a class="title" href="/posts/6cfa7377.html" title="《用概率思维提高胜算》_刘润">《用概率思维提高胜算》_刘润</a><time datetime="2023-12-23T01:57:57.000Z" title="发表于 2023-12-23 09:57:57">2023-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/79b9413.html" title="数学符号参考"><img src="/img/img/11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数学符号参考"/></a><div class="content"><a class="title" href="/posts/79b9413.html" title="数学符号参考">数学符号参考</a><time datetime="2023-12-16T11:49:27.000Z" title="发表于 2023-12-16 19:49:27">2023-12-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2fa412f3.html" title="MahtJax语法入门指南"><img src="/img/img/10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MahtJax语法入门指南"/></a><div class="content"><a class="title" href="/posts/2fa412f3.html" title="MahtJax语法入门指南">MahtJax语法入门指南</a><time datetime="2023-12-09T13:28:18.000Z" title="发表于 2023-12-09 21:28:18">2023-12-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d9c2fff.html" title="《可塑的我：自我发展心理学的35堂必修课》_陈婕君"><img src="/img/img/9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《可塑的我：自我发展心理学的35堂必修课》_陈婕君"/></a><div class="content"><a class="title" href="/posts/d9c2fff.html" title="《可塑的我：自我发展心理学的35堂必修课》_陈婕君">《可塑的我：自我发展心理学的35堂必修课》_陈婕君</a><time datetime="2023-12-09T11:20:29.000Z" title="发表于 2023-12-09 19:20:29">2023-12-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/64e2ab84.html" title="《启发》_罗振宇"><img src="/img/img/8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《启发》_罗振宇"/></a><div class="content"><a class="title" href="/posts/64e2ab84.html" title="《启发》_罗振宇">《启发》_罗振宇</a><time datetime="2023-12-08T07:20:00.000Z" title="发表于 2023-12-08 15:20:00">2023-12-08</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2023 By 水木时</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>